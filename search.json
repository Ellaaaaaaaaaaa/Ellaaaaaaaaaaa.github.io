[{"title":"vue学习笔记","url":"/2024/03/04/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"这份笔记主要记录的是vue2和补充vue3的语法\n\n\n看了一下这个vue2全家桶列举挺完整全面的https://blog.csdn.net/qq_44663761/article/details/122328822?spm=1001.2101.3001.6650.16&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;utm_relevant_index=17\nvue3的补充更新语法https://24kcs.github.io/vue3_study/chapter4/01_Composition%20API_%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86.html\nvue3的关键在于理解Composition (组合) API和setup的使用\nvue基本语法v-for绑定迭代v-on绑定事件，简写形式”@”v-model绑定数据\n&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;var app=new Vue(&#123;        el:&#x27;#app&#x27;,        data:&#123;            list:[&#x27;first&#x27;,&#x27;second&#x27;],            inputValue:&#x27;&#x27;        &#125;,        methods:&#123;            handleBtnClick:function()&#123;                this.list.push(this.inputValue)                this.inputValue=&#x27;&#x27;            &#125;        &#125;    &#125;)\n\nv-bind绑定对象，简写形式”:”component全局组件\n&lt;todo-item v-bind:content=&quot;item&quot; v-for=&quot;item in list&quot;&gt;&lt;/todo-item&gt;Vue.component(&quot;TodoItem&quot;, &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;);\n\n局部组件\nvar TodoItem = &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [&quot;first&quot;, &quot;second&quot;],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,    &#125;,  &#125;);\n\n父子组件传值父组件v-bind的格式向子组件传递，然后props里接收子组件$emit向上一层触发事件，父组件监听获取\n&lt;todo-item          v-bind:content=&quot;item&quot;          v-bind:index=&quot;index&quot;          v-for=&quot;(item, index) in list&quot;          @delete=&quot;handleItemDelete&quot;        &gt;        &lt;/todo-item&gt;var TodoItem = &#123;    props: [&#x27;content&#x27;, &#x27;index&#x27;],    template: &quot;&lt;li @click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,    methods: &#123;      handleItemClick: function () &#123;        this.$emit(&quot;delete&quot;, this.index);      &#125;,    &#125;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,      handleItemDelete: function (index) &#123;        this.list.splice(index, 1);      &#125;,    &#125;,  &#125;);      \n\n生命周期函数是指vue实例在某一个时间点会自动执行的函数图里是vue2的，vue3在命名上多了on和setup2.x 版本生命周期相对应的组合式 APIbeforeCreate -&gt; 使用 setup()created -&gt; 使用 setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured  \ntemplate插值表达式用两个大括号\n&lt;div v-text=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出字符串&lt;div v-html=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出解析成html格式的字符串&lt;div&gt;&#123;&#123;name+&#x27; abc&#x27;&#125;&#125;&lt;/div&gt; 输出字符串var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      name: &quot;&lt;h1&gt;ella&lt;/h1&gt;&quot;,    &#125;,      &#125;);\n\ncomputed属性会有缓存，methods没有缓存性能较差watch监听变化也有缓存\n&lt;div&gt;    &#123;&#123;fullName&#125;&#125;    &#123;&#123;age&#125;&#125;&lt;/div&gt; var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      firstName:&quot;Ella&quot;,      lastName:&quot;L&quot;,      age:20    &#125;,    computed:&#123;        fullName:function()&#123;            return this.firstName+&quot; &quot;+this.lastName        &#125;    &#125;,    watch:&#123;        firstName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,        lastName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,            &#125;,  &#125;);\n\nset和get设置方法\ncomputed: &#123;      fullName: &#123;        get: function () &#123;          return this.firstName + &quot; &quot; + this.lastName;        &#125;,        set:function(value)&#123;            var arr=value.split(&quot; &quot;);            this.firstName=arr[0];            this.lastName=arr[1];        &#125;      &#125;,    &#125;,\n\n样式绑定.通过v-band绑定class或者style来实现可以绑定对象也可以是数组\n&lt;style&gt;    .activated&#123;        color: aquamarine;    &#125;&lt;/style&gt;&lt;div @click=&quot;handleDivClick&quot;     :class=&quot;&#123;activated:isActivated&#125;&quot;    或者&quot;[activated]&quot;&gt;Ella&lt;/div&gt;methods: &#123;    handleDivClick:function()&#123;    this.isActivated=!this.isActivated;    或者this.activated=this.activated===&quot;activated&quot;?&quot;&quot;:&quot;activated&quot;;    &#125;&#125;,再或者&lt;div :style=&quot;styleObj&quot;&gt;hello world&lt;/div&gt;绑定style直接设置\n\n条件渲染v-if 对应的值为false直接在dom上不存在v-show 对应的值为false，dom上存在，不显示v-if可以写循环，必须连在一起\n&lt;div v-if=&quot;show===&#x27;a&#x27;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;show ===&#x27;b&#x27;&quot;&gt;B&lt;/div&gt;&lt;div v-else&gt;C&lt;/div&gt;\n\nkey值唯一可以保证不被复用在控制台直接用下标[]修改数组内容是不会改变页面显示要使用相应的修改函数才可以push pop shift unshift splice sort reverse或者直接改变数组引用对象也可以对象也可以循环，用set方法修改内容Vue.set(app.list,”number”,18)app.$set(app.list,”number”,18)Vue.set(target, key, val)\n&lt;div v-for=&quot;(item, index) of list&quot;           :key=&quot;item.id&quot;&gt;           &#123;&#123;item.text&#125;&#125;---&#123;&#123;index&#125;&#125;      &lt;/div&gt; 数组&lt;div v-for=&quot;(item, key) of list&quot;&gt;           &#123;&#123;item&#125;&#125;--&#123;&#123;key&#125;&#125;      &lt;/div&gt; 对象\n\n&lt;table&gt;里面有&lt;tbody&gt;里面有&lt;tr&gt;里面有&lt;td&gt;&lt;tbody&gt;里面不能直接用template，但是可以用is语句来指向template子组件ul,ol,select标签同理子组件里data必须是函数，不能是父组件中的对象，因为子组件都拥有独立数据不共享\n用ref来操作dom\n&lt;div  ref=&quot;hello&quot;             @click=&quot;handleClick&quot; &gt;hello world&lt;/div&gt;methods: &#123;      handleClick: function()&#123;        console.log(this.$refs.hello)；        console.log(this.$refs.hello.innerHTML)      &#125;    &#125;,\n\n\n父子组件传递父组件向子组件传数据，要在父组件components里先注册，然后标签里传参，子组件用props接收属性数据，且最好不要修改，克隆一个副本修改子组件向父组件传值调用$emit(方法名)，父组件在标签里用@监听方法然后触发事件子组件的\n&lt;div id=&quot;app&quot;&gt;      &lt;counter :count=&quot;0&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;注意在这里定义的事件是和父组件绑定的，要子组件$emit      &lt;counter :count=&quot;1&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;      &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;    &lt;/div&gt;var counter = &#123;    props: [&quot;count&quot;],    data: function () &#123;      return &#123;        number: this.count,      &#125;;    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&quot;,这里定义的事件才是子组件自定义事件，和子组件里面的method绑定    methods: &#123;      handleClick: function () &#123;        this.number++;        this.$emit(&quot;change&quot;, 1);      &#125;,    &#125;,  &#125;;  var vm = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      total: 1,    &#125;,    components: &#123;      counter: counter,    &#125;,    methods: &#123;      handelIncrease: function (step) &#123;        this.total += step;      &#125;,    &#125;,  &#125;);\n\n传参校验非props特性会显示在dom标签里，父组件传子组件不接收绑定原生事件只需要在事件后加上.native非父子组件传值bus 发布订阅模式 观察者模式\n&lt;div id=&quot;app&quot;&gt;      &lt;child content=&quot;ella&quot; &gt;&lt;/child&gt;      &lt;child content=&quot;syray&quot;&gt;&lt;/child&gt;    &lt;/div&gt;Vue.prototype.bus = new Vue();  Vue.component(&quot;child&quot;, &#123;    data:function()&#123;        return&#123;            selfContent:this.content        &#125;    &#125;,    props: &#123;      content: String,    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&quot;,    methods:&#123;        handleClick:function()&#123;            this.bus.$emit(&#x27;change&#x27;,this.selfContent)        &#125;    &#125;,    mounted:function()&#123;        var this_=this;        this.bus.$on(&#x27;change&#x27;,function(msg)&#123;            this_.selfContent=msg;        &#125;)    &#125;  &#125;);  var vm = new Vue(&#123;    el: &quot;#app&quot;,  &#125;);\n\n插槽\n&lt;div id=&quot;app&quot;&gt;      &lt;child&gt;        &lt;p slot=&quot;head&quot;&gt;ella1&lt;/p&gt;        &lt;p slot=&quot;foot&quot;&gt;ella2&lt;/p&gt;      &lt;/child&gt;    &lt;/div&gt; template: `&lt;div&gt;                    &lt;p&gt;hello&lt;/p&gt;                    &lt;slot name=&#x27;head&#x27;&gt;default&lt;/slot&gt;                    &lt;slot name=&#x27;foot&#x27;&gt;default&lt;/slot&gt;               &lt;/div&gt;`,\n\n\n动态组件v-once是创建一次就放入内存中，提高性能，不会反复创建\n&lt;div id=&quot;app&quot;&gt;      &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;      &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;  Vue.component(&#x27;child-one&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;one&lt;/div&gt;&#x27;  &#125;)  Vue.component(&#x27;child-two&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;two&lt;/div&gt;&#x27;  &#125;)    var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        type:&#x27;child-one&#x27;    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.type=this.type===&#x27;child-one&#x27;?&#x27;child-two&#x27;:&#x27;child-one&#x27;;        &#125;    &#125;  &#125;);\n\nCSS动画效果是通过在某一时间上自动往标签上增加一些样式实现的\n//过渡效果&lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;&lt;/style&gt;//弹跳效果&lt;style&gt;        @keyframes bounce-in &#123;            0%&#123;                transform:scale(0);            &#125;            50%&#123;                transform:scale(1.5);            &#125;            100%&#123;                transform:scale(1);            &#125;        &#125;        .v-enter-active&#123;            transform-origin: left center;            animation: bounce-in 1s;        &#125;        .v-leave-active&#123;            transform-origin: left center;            animation: bounce-in 1s reverse;        &#125;&lt;/style&gt;&lt;transition&gt;    &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;&lt;/transition&gt;    &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;//配合使用css动画库&lt;link    rel=&quot;stylesheet&quot;    href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot;    /&gt;    &lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;    &lt;/style&gt;&lt;div id=&quot;app&quot;&gt;        &lt;transition         type=&quot;transition&quot;        //这里可以自定义入场和出场动画时长        :duration=&quot;&#123;enter:5000,leave:10000&#125;&quot;        appear        enter-active-class=&quot;animate__animated animate__swing v-enter-active&quot;        leave-active-class=&quot;animate__animated animate__flip v-leave-active&quot;        appear-active-class=&quot;animate__animated animate__flash&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;//jS动画&lt;div id=&quot;app&quot;&gt;        &lt;transition             @before-enter=&quot;handleBeforeEnter&quot;            @enter=&quot;handleEnter&quot;            @after-enter=&quot;handleAfterEnter&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt; var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        show:true    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.show=!this.show;        &#125;,        handleBeforeEnter:function(el)&#123;            el.style.color=&#x27;red&#x27;        &#125;,        handleEnter:function(el,done)&#123;            setTimeout(()=&gt;&#123;                el.style.color=&#x27;green&#x27;            &#125;,2000)            setTimeout(()=&gt;&#123;                done()            &#125;,4000)        &#125;,        handleAfterEnter:function(el)&#123;            el.style.color=&#x27;blue&#x27;;        &#125;    &#125;  &#125;);//velocity库handleEnter:function(el,done)&#123;            Velocity(el,&#123;opacity:1&#125;,&#123;duration:1000,complete:done&#125;)        &#125;,\n\n\n动画封装\nVue3\n指令语法\n数组变更方法push()pop()shift()unshift()splice()sort()reverse()非变更方法filter(), concat(), slice()reverse()和sort()调用之前创建一个原数组的副本\n事件处理内敛事件 方法事件\n生命周期不要用箭头函数，否则无法用this访问组件实例\nwatch侦听器\n路由动态路由匹配 :传递routes:{}里面的的路由地址可以有相对路径，可以嵌套子路径&lt;router-link to&#x3D;””&gt;&lt;&#x2F;router-link&gt;里面必须是绝对路径$router.push(“”)JS实现页面跳转 ?传递使用命名路由跳转的时候注意要用v-bind:to&#x3D;”{name:’’,params:{}}”\n组件注意data是一个函数要返回return，组件之间不共享\n\n问题axios发送post请求会405\nbind()方法主要是可以改变原本函数的this指向\nref用法this.$ref.取到的是dom元素&#x2F;组件实例\n开发注意小知识点\n&lt;router-link&gt;传参是v-bind:to:to&#x3D;”{path:’&#x2F;root’,query:{id:value}}”\nv-bind:class以键值对的形式绑定操作\nimporthttps://blog.csdn.net/qq_40323256/article/details/101867706注意export导出的引入要{}，export default不需要\n\n前后端分离问题汇总完整逻辑https://blog.csdn.net/qq_42345108/article/details/108249173\n\nelement UI表单 验证https://blog.csdn.net/qq_41008567/article/details/115939951\naxioshttps://www.axios-http.cn/docs/intro请求&#x2F;响应前进行拦截拦截器逻辑顺序\n在vue.config.js里定义devServer的代理服务器和api前缀指向 \n然后定义utils文件夹里的request.js，在该文件里引入axios，创建axios对象和要访问的URL即前面定义的API前缀，然后定义请求和响应拦截器，最后export定义的request对象 \n在apis文件夹里引入定义好的request对象，开始编写具体的request函数，包括后台接口的url，http协议方法，传递的参数 \n在vue视图里引入apis里的request函数并调用，注意调用后的返回值这里同样可以直接在vue组件里面使用类似下方结构来调用\n\n\n\naxios.post(&quot;/users/payMent&quot;,&#123;                addressId:addressId,                orderTotal:this.orderTotal              &#125;).then((response)=&gt;&#123;                  let res = response.data;                  if(res.status==&quot;0&quot;)&#123;                      this.$router.push(&#123;                          path:&#x27;/orderSuccess?orderId=&#x27;+res.result.orderId                      &#125;)                  &#125;              &#125;)\n\nget请求参数不同posthttps://zhuanlan.zhihu.com/p/275695831\n\nvuex状态管理模式解构简写\n\nimport &#123; mapState &#125; from &#x27;vuex&#x27;computed:&#123;  ...mapState([&#x27;nickName&#x27;,&#x27;cartCount&#x27;])&#125;,\n\n\nstate唯一数据源，单一状态树computed里面定义this.$store.state.\ngetter可以派生出一些新的状态可以直接在state数据上包装而不用重新定义数据，类似数据库里视图的概念this.$store.state.getters\nmutation更改state的唯一方法是提交mutationthis.$store.commit()\naction提交的是mutation，而不是直接变更状态可以异步操作调用this.$store.dispatch(“f”)定义f(a){a.commit()}\nmodule将多个store对象分割成模块\n\n\nthisthis对象问题https://juejin.cn/post/7109889547537743886this.$https://segmentfault.com/a/1190000040894587\n\nvue插件extend和component类似https://juejin.cn/post/7239715295484821565\n\nwebpackhttps://cloud.tencent.com/developer/article/1797938\n\n跨域问题\n\n\necharts实战vue3部分问题解决方案\nvscode插件加载不全，重载几遍就好了\n.&#x2F;APP.vue找不到https://blog.csdn.net/XSL_HR/article/details/128437240\nrouter-view不渲染由于没有后端支持，创建路由的history部分要用hashhttps://blog.csdn.net/weixin_43575792/article/details/122655356\n基本都是围绕setup里面响应式数据声明出的问题ref和reactivereactive对象赋值是深拷贝地址会变化，如果不是每个内部属性挨个赋值响应式对象，整体对象就会失去响应性，reactive返回的是对原始对象的引用，使用toRefs来解构toRef是将对象的属性转化为ref对象，浅拷贝，跟原本对象的属性对应地址引用是同一个，可以修改\nvuex和vue-router部分有了更新\n\n","categories":["技术学习"],"tags":["前端","Vue.js","vue2","vue3"]},{"title":"JavaScript学习笔记","url":"/2024/03/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"主要是介绍了ES5的语法，后面补充了ES6的不同之处\n\n\nJavaScript三部分核心(ECMAScript)语言的基本组成部分文档对象模型(DOM)把页面映射成多层节点结构 XML 扩展HTML提供访问和操作网页内容的方法和接口浏览器对象模型(BOM)与浏览器交互的方法和接口  \n&lt; script&gt;async:下载脚本，外部脚本文件有效，不保证执行顺序charset:src属性指定的字符集defer:延迟到文档完全被解析后执行，外部脚本文件有效src:包含执行代码的外部文件type:脚本语言内容类型，默认值text&#x2F;javascript  \n放在HTML文件底部直接嵌入或包含外部文件直接嵌入要指定type属性&lt;script&gt; &lt;&#x2F;script&gt; 一对出现，函数内部出现记得用转义符号&lt;/script&gt;包含外部文件要指定src属性，&lt;script&gt; &lt;&#x2F;script&gt;中不包含额外代码&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”a.js”&gt; &lt;&#x2F;script&gt;放在&lt;body&gt;元素中页面内容的后面  \n基本概念(只记录了一些跟我印象中不同的点)区分大小写var创建变量是局部变量，省略后是全局变量使用var和function声明的变量不可删除，因为被标记成不可配置了delete不能删除全局变量，但是可以删除window对象上定义的属性delete操作符跟直接释放内存无关，是断开引用间接完成的，对象的属性和数组成员才可以删除这样的删除仍然占据内存空间，要设置null才能释放\n\n数据类型\n\n\nUndefined声明未初始化typeof()\nNull\nBooleantrue false 字面值 全小写其他类型的空值、0、NaN、null、undefined转换后都是false\nNumberNaN Number() parseInt() parseFloat()\nString转义字符不可变toString()\nobjectnew 跟Java蛮像的P35一些函数\n\ntypeof 返回数据类型 object null注意返回\n\n操作符（意外跟C很像）一元操作符自增自减前置后置位操作符~非&amp;与|或^异或&gt;&gt;右移&lt;&lt;左移 &gt;&gt;&gt;无符号右移&#x3D;&#x3D;会强制转换 &#x3D;&#x3D;&#x3D;不会强制转换?:\n语句if do-while while for for-inlabel标识特定位置 break continue with设置作用域switch\n函数function 参数不限制个数和类型 通过argument对象访问元素参数传递都是值传递没有重载，后面覆盖\n引用instanceof\n作用域没有块级作用域，if for语句中初始化变量在语句执行完之后依旧存在于语句外部执行环境var是添加到最近的环境，没有就是添加到全局环境\n垃圾收集标记清除\n\n引用类型\nobject类型用new创建；对象字面量很像字典，都是花括号里属性名：属性值\n\nArray类型每一项可以保存任何类型的数据，动态调整数组大小Array(数字)表示数组项目数量Array(其他类型参数)创建包含那个值的只有一项的数组方括号[]索引isArray()toString() 每个值的字符串形式，以逗号分隔valueOf()join()分隔符字符串push() pop() stackshift()移除第一个 unshift()前端添加 list queuereverse()翻转sort()比较字符串 小心15&lt;5，从字符串上看，定义compare函数作为参数传入sort()concat() 拼接字符串和多个数组的每一项slice() 返回[开始索引，结束索引)中间的项，负数则用数组长度加上该数来确定位置splice()\n\n删除 第一项位置，删除项数\n插入 起始位置，删除项数，插入的项\n替换 起始位置，删除项数，插入的项\n\nindexOf() lastIndexOf()查找位置，没找到返回-1\n\n\n迭代方法every() some() filter() forEach() map()reduce() reduceRight()\n\nDate类型\n\nRegExp类型 每一次要创建新的实例g全局i不分大小写m多行exec()\n\nfunction类型function 函数名(参数){语句;}var 函数名&#x3D;function(参数){语句;};一个函数可以有多个名字没有重载arguments callee用于解除代码和函数名的耦合this 先局部再全局call() apply()基本包装类型Boolean Number String不能添加属性和方法charAt() charCodeAt() slice() substr() substring() indexOf() trim() toLowerCase() toUpperCase() match() search() replace() split() localeCompare() fromCharCode()\n\n\n全局对象URI编码方法eval() 解析器 接受要执行的JS字符串window对象Math对象\n面向对象对象有属性和方法使用Object.defineProperty()来修改属性特性\n\n数据属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nWritable能否修改属性值\nValue读写值\n\n\n访问器属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nGet读取\nSet写入使用Object.defineProperties()定义多个属性\n\n\n\n工厂模式 在函数里面新创建一个对象构造函数模式 把函数当做构造函数，在外部直接new对象原型模式 一个函数有prototype属性，其他实例共享prototype里面的属性和函数，先找对象实例本身属性，再找原型对象的属性，实例和原型之间的连接是指针每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针hasOwnProperty()inconstructor()可以随时为原型添加属性和方法，但不要重写构造函数和原型模式的组合动态原型模式 在构造函数里初始化原型函数寄生构造函数 要用new的工厂模式稳妥构造函数 不能用this\n实现继承 原型链搜索属性会沿着原型链往上通过原型链实现继承的时候，不能使用对象字面量创建原型方法，因为会重写原型链在每一个创建的子类对象上使用超类对象的call或者apply方法进行所有对象初始化寄生组合式继承是最完美的继承方式不必为指定子类型的原型而调用超类型的构造函数\n函数表达式\n函数声明:function 函数名(){}函数声明可以置于调用语句之后\n函数表达式:var 变量名&#x3D;function(){};此为匿名函数要先赋值才可以调用编写递归函数，函数内部用argument.callee代替函数名函数第一次调用创建一个执行环境和作用域链，并把作用域连赋值给一个特殊的内部属性scope，然后初始化活动对象，外部，外部的外部，知道作用域链终点全局执行环境\n\n闭包，在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域闭包结构：\n\n一个函数，里面有一些变量和另一个函数\n外部函数里面的函数使用了外部函数的变量\n外部函数最后把它里面的那个函数用return抛出去\n\n闭包作用：\n\n在函数外部可以读取函数内部的变量\n让这些变量的值始终保持在内存中\n\n闭包只能取得包含函数中任何变量的最后一个值解决方法是再嵌套一层函数，形成一个闭包注意this的指向问题，可能闭包函数是在window作用域下执行的，this就不是指向外部函数而是window内存泄漏问题，闭包引用外层对象，写一个变量保存对象副本，结束闭包后把对象置为null多次声明同一变量，会对后续声明视而不见在匿名函数中定义的任何变量都会在执行结束时被销毁(function(){作用域})\nBOM\nwindow对象全局作用域中声明的变量和函数收拾window对象的属性和方法尝试访问未声明的变量会抛出错误，但是可以查询window对象判断未声明的对象是否存在窗口关系和框架top对象指向最外层框架即浏览器窗口parent对象指向当前框架的直接上层框架没有框架的情况下parent&#x3D;top&#x3D;window窗口位置和大小moveTo(x,y)移动到实际位置moveBy(x,y)移动量resizeTo(x,y)设置大小resizeBy(x,y)新的和原来的差导航和打开窗口window.open()参数：URL，窗口目标，特性字符串，新页面是否取代浏览器中当前加载页的布尔值window.setTimeout()执行代码和等待时间clearTimeout()取消超时调用setInterval()间隔时间重复执行clearInterval()\n\nlocation对象既是window的属性也是document的属性location.search访问URL里面的内容location.assign()传递URLlocation.reload()无参重载&#x2F;有参服务器重载\n\nnavigatorpluginsregisterContentHandler()\n\nscreen对象\n\nhistory对象\n\n\nDOM把HTML或者XML文档描绘成多层节点结构\n\nNode类型nodeType, nodeName, nodeValue, childNodes, NodeList, ownerDocumentappendChild(), insertBefore(),replaceChild(), cloneNode()(注意区别这里深复制是复制节点和子节点树，浅复制是只复制节点本身), normalize()\nDocument类型window对象的一个属性，可以当做全局对象来访问documentElement指向&lt;html&gt;body指向&lt;body&gt;title, URL, domain, referrergetElementById()getElementByTagName()返回的是同一个tag集合HTMLCollection.namedItem()HTMLCollection.getElementByNamed()特殊集合P258write(), writeln(), open(), close()\nElementattributes属性 get set remove\n\nquerySelector()接受CSS选择符\nHTML5getElementByClassName()classList属性 add() contains() remove() toggle()document.activeElement focus()HTMLDocument属性readyStatecompatModeheadcharsetdata-自定义数据属性innerHTMLouterHTMLscrollIntoView()简单描述一下就是一棵DOM树有节点和元素，还有自己对应的属性，可以创建节点然后添加到树里面，还可以直接设置元素的style属性可以直接查询包含某些类或者ID的元素遍历NodeIteratorTreeWalker\n事件ES6语法\n变量声明let const var可以创建块作用域\n剩余……参数 动态参数…variable…数组 拆解数组\napply(this,array) call(this,arg)\n解构赋值左侧定义了要取出的值剩余属性位于末尾结束解构模式\n箭头函数去掉function，直接(参数)&#x3D;&gt;{}不能用作方法function定义的函数this随上下文变化而变化箭头函数this始终指向定义函数的环境\npromisePromise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数，接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。then：用于处理 Promise 成功状态的回调函数。catch：用于处理 Promise 失败状态的回调函数。finally：无论 Promise 是成功还是失败，都会执行的回调函数。\nfor in和 for of数组遍历用for of，对象遍历用for infor…in 语句以任意顺序迭代对象的可枚举属性。for…of 语句遍历可迭代对象定义要迭代的数据。\n\n","categories":["技术学习"],"tags":["前端","JavaScript","ES6"]},{"title":"二战腾讯","url":"/2024/03/07/%E4%BA%8C%E6%88%98%E8%85%BE%E8%AE%AF/","content":"无笔试，面试初试(已挂)部门：技术架构团队(WXG)形式：视频时长：min时间：2024&#x2F;3&#x2F;8 10:00\n内容回忆反思","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"一战腾讯","url":"/2024/03/06/%E4%B8%80%E6%88%98%E8%85%BE%E8%AE%AF/","content":"无笔试，面试初试(已挂)部门：qq的PC端的某前端开发岗(PCG)形式：电话时长：15min时间：2024&#x2F;3&#x2F;6 11:00\n内容回忆\n投的前端岗位，为什么简历上无前端项目经历？ 当时写简历的时候觉得自己搞得全栈项目只做了部分功能，不太好意思写，总不能把跟着视频网站敲的项目放上去吧……但其实蓝鲸项目是有前端部分的，但貌似被面试官忽略了(尴尬)\n\n介绍自己开发过最难的一个前端项目，里面实现了哪些功能技术点，用的什么技术栈？ 因为确实没有做过很复杂的前端项目，自己搭建后端服务器和数据库做的全栈项目只完成了一部分，而且重点放在页面实现和美化上了，前后端交互的部分太简单了，也没有尝试过部署项目(还是太摆烂了)。我自己开发中遇到的比较多的都是页面渲染和JS交互逻辑的问题，而且都是服务器是本地搭建的，数据也很多是静态数据，所以在前后端交互上答得不太好(悲)\n\n登录与注册页面的原生逻辑是怎样实现的(不用插件)，如何保持浏览器登录状态？ 这里回答的有点不对题，我回答的是登录进去后在应用中如何保持登录状态(jwt返回的token值保存在localStorage里)，被打断了，应该是用户点进登录页面后浏览就要自动识别呈现是登录页还是注册页，面完后才想起来可能是回答cookie相关  \n\n是否了解过axios的使用过程，封装的源码逻辑？(vuex) 我其实没看过封装的源码(流汗)，只能按照自己的理解说，能感觉到应该没说到点子上\n\n我的项目中用了很多封装好的模块，被提问不用封装模块该怎么用JS原生代码实现？ 前面介绍自己的项目时说了一堆花里胡哨的功能，引入了一堆组件插件，回旋镖打在自己身上了(汗流浃背了)\n\n怎么处理跨域问题？(还有一些前后端交互的部分) 我说了两个，但感觉面试官觉得这两个方法都不是他想听的?\n\n\n反思整场面试都在围绕项目开发中的问题，算法&#x2F;数据结构、JS&#x2F;HTML&#x2F;CSS&#x2F;Vue语法、计算机网络、操作系统、后端&#x2F;数据库语法 全部都 没问，然后我复习的基本是这些内容。本以为具体项目开发二面三面才会，没想到一来就是项目开发里的问题，感觉就是婉拒了(bushi)。然后就是一直问有没有看过源码和封装逻辑，这个确实忽略了，都是直接用了，回答的时候很尴尬  \n总之，这次面试确实是太赶了，临时决定要投一下试试，很多东西都没准备好，果然挂了。现在的我对于前端知识很多处在一个知其然不知其所以然的状态，接下来还是要 搞一个复杂的项目实战，并且不能依赖插件，要看源码，尝试自己动手封装 ，当然 计算机基础知识和算法题 也要好好刷(也有点庆幸这次没问算法，不然挂的更快)，后续实习投递都有笔试或者现场手撕代码的\n没关系，第一次面试而已，来日方长~","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"前端面试知识点汇总","url":"/2024/03/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"记录了我自己准备前端面试时复习的内容  \n\n\n参考了 https://vue3js.cn/interview/\nHTML CSSJavaScript\n回调函数嵌套 函数体在完成某种操作后由内向外调用某个外部函数函数作为参数传递给另外一个函数回调地狱回调函数是一个this对象的方法时，必须保证this对象的上下文，Call和Apply函数来保存this\n\nES6\nvar let const作用域. 变量提升. 重复声明. 暂时性死区\n数组新增\n… 数组变成参数序列 浅拷贝 解构赋值 参数最后一位 iterator对象转成数组\n构造函数 Array.from() Array.of()\n实例对象方法 copyWithin() 复制覆盖 find(). findIndex() 查找 fill() 填充 entries()，keys()，values() 遍历 includes() 判断是否包含 flat()，flatMap() 扁平化（层数）\n\n\n对象新增\n简写\n属性名表达式\nsuper指向当前对象的原型对象\n扩展运算符 解构赋值 浅拷贝\n属性遍历 数值键-&gt;字符串键-&gt;symbol键 for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n方法 Object.is() 严格相等 +0不等于-0，NaN等于自身 Object.assign() 对象合并 浅拷贝替换 Object.getOwnPropertyDescriptors() Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.fromEntries()\n\n\n函数新增\n参数 尾参数\nlength name\n箭头函数 参数&#x3D;&gt;返回值\n\n\nSet Map\nSet add() delete() has() clear() keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 数组字符串去重 filter 并集交集差集\nMap set() get() has() delete() clear() keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历 Map 的所有成员 weak没有遍历属性\n\n\npromise Promise(function(resolve, reject) {})then()catch()finally()Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\ngeneratorfunction关键字与函数名之间有一个星号函数体内部使用yield表达式，定义不同的内部状态通过next方法才会遍历，直到一个yield表达式暂停，返回值是yield表达式的值，下一次next方法继续，直到returnnext可以带一个参数，当做一个yield表达式的返回值返回的是Iterator对象，可以通过for…of进行遍历\n异步处理回调函数Promise 对象generator 函数 可以控制迭代async&#x2F;await 本质上generator\nproxy用于创建一个对象的代理，从而实现基本操作的拦截和自定义var proxy &#x3D; new Proxy(target, handler)Reflect 的所有属性和方法都是静态的（ Math 对象），提供拦截 JavaScript 操作的方法get() set() deleteProperty()Proxy.revocable(target, handler);取消代理在复杂操作前对操作进行校验或对所需资源进行管理拦截和监视外部对对象的访问使用 Proxy 保障数据类型的准确性使用Proxy实现观察者模式，观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\nmodule静态化 在编译时就完成模块加载export：用于规定模块的对外接口import：用于输入其他模块提供的功能\ndecorator装饰器命名相当于一个注释，在不改变原有代码情况下，对类和类属性原来功能进行扩充不能修饰函数\n\nVue.jsNode.jsNode.js 是一个开源与跨平台的 JavaScript 运行时环境事件驱动、非阻塞和异步输入输出模型\n算法\n前端diff算法 深度优先算法 时间复杂度:O(n) 最小量更新patch 比较虚拟DOM根节点是否同一类型，不同直接替换|patchVnode 进一步比较两个虚拟节点 有无text和children|updateChildren 都有子节点的情况下比较更新真实节点 四个指针，指向oldVnode子节点列表中的第一个节点和最后一个节点以及指向newVnode子节点列表中的第一个节点和最后一个节点，节点比较过，前的指针++，后的指针–\noldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)\noldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)，相同的话移动真实节点OE之后\noldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)，相同的话移动真实节点OS之前\noldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)\n如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置\nold先处理完，新增newS和newE之间的节点\nnew先处理完，删除oldS和oldE之间的节点key的设置 判断两个虚拟节点是否为相同节点不建议用index作为循环项的key，因为操作过程中index会改变，一些相同节点index变了会被当成新的节点，用id的话每个节点key都不同，便于更新时复用节点\n\n\n排序\n数据结构数组栈队列链表树图堆散列表  \n经典算法\n\n网络协议\nHTTPC&#x2F;S模式 可以传输任意类型数据对象  明文传输，无身份验证 不安全默认端口80无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间无状态：HTTP协议无法根据之前的状态进行本次的请求处理  \n\nHTTPS加密传输  让HTTP运行安全的SSL&#x2F;TLS协议(TCP&#x2F;IP 协议与应用层协议之间)上默认端口443  因为加密和多次握手，性能相对较差通信过程:\n\n首先客户端通过URL访问服务器建立SSL连接\n服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端\n客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级\n客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站\n服务器利用自己的私钥解密出会话密钥\n服务器利用会话密钥加密与客户端之间的通信\n\n\nSSL\n\n对称加密：加密和解密使用的秘钥是同一个，秘钥发送的过程中容易被窃取\n非对称加密：有公钥和私钥，公钥加密后只能用私钥解密，私钥加密后也只能用公钥解密  \n混合加密： 发送者用会话密钥加密消息（对称），用公钥加密的会话密钥（非对称），两个一起发送 消息接收者用自己的私钥解密出会话密钥，用会话密钥解密消息\n\n 摘要算法： 会话密钥 对称的 明文和摘要一起加密 验证信息的完整性  散列函数、哈希函数 把消息数据转化成一个特殊字符串，接收者比对接收到的明文计算出的消息摘要和接收到的信息摘要  \n 数字签名： 公私钥 非对称  身份验证 摘要私钥加密成数字签名，公钥解开后再比对原文验证  \n CA验证机构:     1. 服务器有一套公钥和私钥，把公钥发给CA机构     2. CA机构用机构私钥给服务器公钥署数字签名，颁发公钥证书(服务器公钥+数字签名)     3. 浏览器中预设了机构公钥，客户端拿到服务器的公钥证书，可以自行解密数字签名，得到服务器公钥，跟公钥证书比对     4. 客户端用服务器公钥加密报文，服务器用服务器私钥解密\n\nUDP\n\nTCP\n\n\nGit\necharts可视化最重要的就是id问题，不能重复\n\nprovide inject导入echarts对象\n获取后端数据\nonMounted里初始化渲染，因为要获取dom元素\n看文档setOption，notMerge: true\n自适应大小window.onresize &#x3D; function () {myChart1.resize();}\n放echarts的容器要预先设置大小才会渲染\n\nexpressMongoDB","categories":["技术学习"],"tags":["前端","面试"]},{"title":"算法学习笔记","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前言主要是用 JavaScript 来刷题目前先看了一下算法基础，可以参考以下链接，基本上js扫盲没问题，然后开始力扣刷题https://juejin.cn/post/7087134135193436197\n力扣目前是先把LeetCode75刷完，进行算法扫盲  \n唉，没想到上一次刷力扣都是一年前了，这一次争取刷题量大一点，坚持的久一点  \n本笔记记录中等及以上难度的题和一些特殊思想\n\n334.递增的三元子序列题目：给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。\n\n解析：\n\n双向遍历 其实本质上就是找到数组中的一个元素，左边有值比它小，右边有值比它大。那么新创建两个长度为n的MIN和MAX数组，即MIN[i]表示nums[0]到nums[i]中的最小值，MAX[i]表示nums[0]到nums[i]中的最大值，然后遍历nums数组找到MIN[i-1]&lt;nums[i]&lt;MAX[i+1]的返回true  \n 整个逻辑需要遍历数组三遍，额外创建两个数组\n\n贪心算法 简单说就是寻找局部最优解，再把每次迭代后的最优解叠加\n 本题目怎么联想到贪心呢，因为看完题目后三元组中的第一个肯定是越小越容易满足递增的情况，所以就是要找到最小的做first，第二小的做second，这样遍历只用找到比second大就返回true  \n 那么迭代思路就是先令nums[0]为first，second为正无穷，开始遍历。遇到nums[i]&gt;second的返回true;遇到first&lt;nums[i]&lt;second，second换成更小的nums[i]；遇到first&gt;&#x3D;nums[i]，first换成更小的nums[i]。\n 注意第三种情况second是没变的，那么新的first位置是在second后面的，只要后续遍历找到一个nums[i]大于second，曾经的first肯定排在second前面，那么就找到了；如果nums[i]小于second大于新的first，second就直接更新了，那么又回到了first位置在second前面的情况。\n\n\n/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var increasingTriplet = function (nums) &#123;    const len = nums.length;    if (len &lt; 3) &#123;        return false    &#125;    let first = nums[0]    let second = Number.MAX_VALUE;    for (let i = 1; i &lt; len; i++) &#123;        const num = nums[i]        if (num &gt; second) &#123;            return true        &#125; else if (num &gt; first) &#123;            second = num        &#125; else &#123;            first = num        &#125;    &#125;    return false&#125;;\n\n215.数组中的第K个最大元素题目：给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n\n解析：\n\n快排 之前看快排的时候只记得二分迭代，其实忽略了每一次迭代中的中间值的最终位置会被确定下来，可以利用这一点在迭代的过程中就确定某些顺序位置上的值。简单来说就是某次二分时中间值被放到了了nums[k]的位置(降序)，那么这个中间值就是第k大的元素\n\n","categories":["技术学习"],"tags":["前端","算法"]}]