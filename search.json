[{"title":"JavaScript学习笔记","url":"/2024/03/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"主要是介绍了ES5的语法，后面补充了ES6的不同之处\nJavaScript三部分核心(ECMAScript)语言的基本组成部分文档对象模型(DOM)把页面映射成多层节点结构 XML 扩展HTML提供访问和操作网页内容的方法和接口浏览器对象模型(BOM)与浏览器交互的方法和接口  \n&lt; script&gt;async:下载脚本，外部脚本文件有效，不保证执行顺序charset:src属性指定的字符集defer:延迟到文档完全被解析后执行，外部脚本文件有效src:包含执行代码的外部文件type:脚本语言内容类型，默认值text/javascript  \n放在HTML文件底部直接嵌入或包含外部文件直接嵌入要指定type属性\\ \\ 一对出现，函数内部出现记得用转义符号&lt;\\/script&gt;包含外部文件要指定src属性，\\ \\中不包含额外代码\\ \\放在\\元素中页面内容的后面  \n基本概念(只记录了一些跟我印象中不同的点)区分大小写var创建变量是局部变量，省略后是全局变量使用var和function声明的变量不可删除，因为被标记成不可配置了delete不能删除全局变量，但是可以删除window对象上定义的属性delete操作符跟直接释放内存无关，是断开引用间接完成的，对象的属性和数组成员才可以删除这样的删除仍然占据内存空间，要设置null才能释放\n\n数据类型  \n\n\nUndefined声明未初始化typeof()\nNull\nBooleantrue false 字面值 全小写其他类型的空值、0、NaN、null、undefined转换后都是false\nNumberNaN Number() parseInt() parseFloat()\nString转义字符\\不可变toString()\nobjectnew 跟Java蛮像的P35一些函数\n\ntypeof 返回数据类型 object null注意返回\n\n操作符（意外跟C很像）一元操作符自增自减前置后置位操作符~非&amp;与|或^异或&gt;&gt;右移&lt;&lt;左移 &gt;&gt;&gt;无符号右移==会强制转换 ===不会强制转换?:\n语句if do-while while for for-inlabel标识特定位置 break continue with设置作用域switch\n函数function 参数不限制个数和类型 通过argument对象访问元素参数传递都是值传递没有重载，后面覆盖\n引用instanceof\n作用域没有块级作用域，if for语句中初始化变量在语句执行完之后依旧存在于语句外部执行环境var是添加到最近的环境，没有就是添加到全局环境\n垃圾收集标记清除\n\n引用类型\nobject类型用new创建；对象字面量很像字典，都是花括号里属性名：属性值\nArray类型每一项可以保存任何类型的数据，动态调整数组大小Array(数字)表示数组项目数量Array(其他类型参数)创建包含那个值的只有一项的数组方括号[]索引isArray()toString() 每个值的字符串形式，以逗号分隔valueOf()join()分隔符字符串push() pop() stackshift()移除第一个 unshift()前端添加 list queuereverse()翻转sort()比较字符串 小心15&lt;5，从字符串上看，定义compare函数作为参数传入sort()concat() 拼接字符串和多个数组的每一项slice() 返回[开始索引，结束索引)中间的项，负数则用数组长度加上该数来确定位置splice()\n\n删除 第一项位置，删除项数\n插入 起始位置，删除项数，插入的项\n替换 起始位置，删除项数，插入的项\n\nindexOf() lastIndexOf()查找位置，没找到返回-1迭代方法every() some() filter() forEach() map()reduce() reduceRight()\n\nDate类型\n\nRegExp类型 每一次要创建新的实例g全局i不分大小写m多行exec()\n\nfunction类型function 函数名(参数){语句;}var 函数名=function(参数){语句;};一个函数可以有多个名字没有重载arguments callee用于解除代码和函数名的耦合this 先局部再全局call() apply()基本包装类型Boolean Number String不能添加属性和方法charAt() charCodeAt() slice() substr() substring() indexOf() trim() toLowerCase() toUpperCase() match() search() replace() split() localeCompare() fromCharCode()\n\n全局对象URI编码方法eval() 解析器 接受要执行的JS字符串window对象Math对象\n面向对象创建对象的方式\n\n使用对象字面量：这是最简单和最常见的方式，直接在代码中定义对象。例如：\nvar person = &#123;    name: &#x27;John&#x27;,    age: 30,    greet: function() &#123;        console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);    &#125;&#125;;// 访问属性和调用方法console.log(person.name); // 输出：Johnperson.greet(); // 输出：Hello, my name is John and I am 30 years old.\n\n使用构造函数：构造函数允许你创建一个对象模板，然后通过 new 关键字调用构造函数,创建对象的实例。构造函数使用 this 关键字来指向新创建的对象。使用 this 关键字来创建属性或方法时，这些属性和方法会在使用 new 关键字创建对象时自动创建和声明.\n//构造函数function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;Person.prototype.greet = function() &#123;    console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);&#125;;// 创建实例var person1 = new Person(&#x27;Alice&#x27;, 25);var person2 = new Person(&#x27;Bob&#x27;, 30);// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n使用工厂函数：工厂函数是一种创建对象的函数，它类似于构造函数，但是不使用 new 关键字。它直接返回一个新的对象实例。例如：\nfunction createPerson(name, age) &#123;    return &#123;        name: name,        age: age,        greet: function() &#123;            console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);        &#125;    &#125;;&#125;// 创建对象实例var person1 = createPerson(&#x27;Alice&#x27;, 25);var person2 = createPerson(&#x27;Bob&#x27;, 30);// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n使用 ES6 中的类：在 ES6（ECMAScript 2015）以及之后的版本中，引入了类的概念，可以更方便地创建对象。类的语法更类似于其他面向对象语言。例如：\nclass Person &#123;    constructor(name, age) &#123;        this.name = name;        this.age = age;    &#125;    greet() &#123;        console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);    &#125;&#125;// 创建实例var person1 = new Person(&#x27;Alice&#x27;, 25);var person2 = new Person(&#x27;Bob&#x27;, 30);// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n使用 Object.create()：Object.create() 方法允许你基于一个现有的对象创建一个新的对象，可以指定新对象的原型。例如：\nvar personProto = &#123;    greet: function() &#123;        console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);    &#125;&#125;;var person1 = Object.create(personProto);person1.name = &#x27;Alice&#x27;;person1.age = 25;var person2 = Object.create(personProto);person2.name = &#x27;Bob&#x27;;person2.age = 30;// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n\n对象有属性和方法使用Object.defineProperty()来修改属性特性\n\n数据属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nWritable能否修改属性值\nValue读写值\n\n\n访问器属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nGet读取\nSet写入使用Object.defineProperties()定义多个属性\n\n\n\n工厂模式 在函数里面新创建一个对象构造函数模式 把函数当做构造函数，在外部直接new对象原型模式 一个函数有prototype属性，其他实例共享prototype里面的属性和函数，先找对象实例本身属性，再找原型对象的属性，实例和原型之间的连接是指针每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针hasOwnProperty()inconstructor()可以随时为原型添加属性和方法，但不要重写构造函数和原型模式的组合动态原型模式 在构造函数里初始化原型函数寄生构造函数 要用new的工厂模式稳妥构造函数 不能用this\n实现继承 原型链搜索属性会沿着原型链往上通过原型链实现继承的时候，不能使用对象字面量创建原型方法，因为会重写原型链在每一个创建的子类对象上使用超类对象的call或者apply方法进行所有对象初始化寄生组合式继承是最完美的继承方式不必为指定子类型的原型而调用超类型的构造函数\n函数表达式\n函数声明:function 函数名(){}函数声明可以置于调用语句之后\n函数表达式:var 变量名=function(){};此为匿名函数要先赋值才可以调用编写递归函数，函数内部用argument.callee代替函数名函数第一次调用创建一个执行环境和作用域链，并把作用域连赋值给一个特殊的内部属性scope，然后初始化活动对象，外部，外部的外部，知道作用域链终点全局执行环境\n\n闭包，在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域闭包结构：\n\n一个函数，里面有一些变量和另一个函数\n外部函数里面的函数使用了外部函数的变量\n外部函数最后把它里面的那个函数用return抛出去\n\n闭包作用：\n\n在函数外部可以读取函数内部的变量\n让这些变量的值始终保持在内存中\n\n闭包只能取得包含函数中任何变量的最后一个值解决方法是再嵌套一层函数，形成一个闭包注意this的指向问题，可能闭包函数是在window作用域下执行的，this就不是指向外部函数而是window内存泄漏问题，闭包引用外层对象，写一个变量保存对象副本，结束闭包后把对象置为null多次声明同一变量，会对后续声明视而不见在匿名函数中定义的任何变量都会在执行结束时被销毁(function(){作用域})\nBOM\nwindow对象全局作用域中声明的变量和函数收拾window对象的属性和方法尝试访问未声明的变量会抛出错误，但是可以查询window对象判断未声明的对象是否存在窗口关系和框架top对象指向最外层框架即浏览器窗口parent对象指向当前框架的直接上层框架没有框架的情况下parent=top=window窗口位置和大小moveTo(x,y)移动到实际位置moveBy(x,y)移动量resizeTo(x,y)设置大小resizeBy(x,y)新的和原来的差导航和打开窗口window.open()参数：URL，窗口目标，特性字符串，新页面是否取代浏览器中当前加载页的布尔值window.setTimeout()执行代码和等待时间clearTimeout()取消超时调用setInterval()间隔时间重复执行clearInterval()\n\nlocation对象既是window的属性也是document的属性location.search访问URL里面的内容location.assign()传递URLlocation.reload()无参重载/有参服务器重载\n\nnavigatorpluginsregisterContentHandler()\n\nscreen对象\n\nhistory对象\n\nDOM把HTML或者XML文档描绘成多层节点结构\n\nNode类型nodeType, nodeName, nodeValue, childNodes, NodeList, ownerDocumentappendChild(), insertBefore(),replaceChild(), cloneNode()(注意区别这里深复制是复制节点和子节点树，浅复制是只复制节点本身), normalize()\nDocument类型window对象的一个属性，可以当做全局对象来访问documentElement指向\\body指向\\title, URL, domain, referrergetElementById()getElementByTagName()返回的是同一个tag集合HTMLCollection.namedItem()HTMLCollection.getElementByNamed()特殊集合P258write(), writeln(), open(), close()\nElementattributes属性 get set remove\n\nquerySelector()接受CSS选择符\nHTML5getElementByClassName()classList属性 add() contains() remove() toggle()document.activeElement focus()HTMLDocument属性readyStatecompatModeheadcharsetdata-自定义数据属性innerHTMLouterHTMLscrollIntoView()简单描述一下就是一棵DOM树有节点和元素，还有自己对应的属性，可以创建节点然后添加到树里面，还可以直接设置元素的style属性可以直接查询包含某些类或者ID的元素遍历NodeIteratorTreeWalker\n事件ES6语法\n变量声明let const var可以创建块作用域\n剩余……参数 动态参数…variable…数组 拆解数组\napply(this,array) call(this,arg)\n解构赋值左侧定义了要取出的值剩余属性位于末尾结束解构模式\n箭头函数去掉function，直接(参数)=&gt;{}不能用作方法function定义的函数this随上下文变化而变化箭头函数this始终指向定义函数的环境\npromisePromise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数，接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。then：用于处理 Promise 成功状态的回调函数。catch：用于处理 Promise 失败状态的回调函数。finally：无论 Promise 是成功还是失败，都会执行的回调函数。\nfor in和 for of数组遍历用for of，对象遍历用for infor…in 语句以任意顺序迭代对象的可枚举属性。for…of 语句遍历可迭代对象定义要迭代的数据。\n\n运行时 runtimeJavaScript是一门解释执行语言。这意味着源代码在执行前，无需编译为二进制文件。JavaScript引擎以一段程序的形式存在，负责将源代码翻译为机器码，并通过 CPU来执行翻译后的机器码\n对比Java是先编译后执行的，能够将代码语法错误立即反馈给你。在JavaScript 中，只有当引擎尝试执行到有问题的那行代码时，才知道哪里出了问题。\n在 Web 开发中，引擎并不会被开发者直接使用到。JavaScript 引擎是运行在一个环境中的，这个环境提供了代码在执行时能够利用的附加特性。\n对比Java，Java 运行时环境（JRE）提供了访问所支持类库的方式，并且扮演了程序与操作系统之间的桥梁的角色。\nJavaScript 运行时是指 JavaScript 代码执行的环境。Web 浏览器和 Node.js 是两种常见的 JavaScript 运行环境。\n\nweb浏览器\n\nNode.js\n\n\n事件循环机制JavaScript 代码是在单一线程中执行的，但是JavaScript 运行时是存在线程池的\nJavaScript 代码分为立即调用代码和事件回调代码\n事件循环机制是处理回调的机制。创建回调时，通常把它与一个特定事件关联起来。当特定事件发生时，运行时环境会将相关回调推入一个所谓的事件处理队列。事件循环机制会持续监控队列，并且按照先来后到的顺序执行其中的回调。\nv8https://v8.js.cn/docs/\n","categories":["技术学习"],"tags":["前端","JavaScript","ES6"]},{"title":"vue学习笔记","url":"/2024/03/04/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"这份笔记主要记录的是vue2和补充vue3的语法\n看了一下这个vue2全家桶列举挺完整全面的https://blog.csdn.net/qq_44663761/article/details/122328822?spm=1001.2101.3001.6650.16&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;utm_relevant_index=17\nvue3的补充更新语法https://24kcs.github.io/vue3_study/chapter4/01_Composition%20API_%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86.html\nvue3的关键在于理解Composition (组合) API和setup的使用\nvue基本语法v-for绑定迭代v-on绑定事件，简写形式”@”v-model绑定数据\n&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;var app=new Vue(&#123;        el:&#x27;#app&#x27;,        data:&#123;            list:[&#x27;first&#x27;,&#x27;second&#x27;],            inputValue:&#x27;&#x27;        &#125;,        methods:&#123;            handleBtnClick:function()&#123;                this.list.push(this.inputValue)                this.inputValue=&#x27;&#x27;            &#125;        &#125;    &#125;)\nv-bind绑定对象，简写形式”:”component全局组件\n&lt;todo-item v-bind:content=&quot;item&quot; v-for=&quot;item in list&quot;&gt;&lt;/todo-item&gt;Vue.component(&quot;TodoItem&quot;, &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;);\n局部组件\nvar TodoItem = &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [&quot;first&quot;, &quot;second&quot;],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,    &#125;,  &#125;);\n父子组件传值父组件v-bind的格式向子组件传递，然后props里接收子组件$emit向上一层触发事件，父组件监听获取\n&lt;todo-item          v-bind:content=&quot;item&quot;          v-bind:index=&quot;index&quot;          v-for=&quot;(item, index) in list&quot;          @delete=&quot;handleItemDelete&quot;        &gt;        &lt;/todo-item&gt;var TodoItem = &#123;    props: [&#x27;content&#x27;, &#x27;index&#x27;],    template: &quot;&lt;li @click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,    methods: &#123;      handleItemClick: function () &#123;        this.$emit(&quot;delete&quot;, this.index);      &#125;,    &#125;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,      handleItemDelete: function (index) &#123;        this.list.splice(index, 1);      &#125;,    &#125;,  &#125;);      \n生命周期函数是指vue实例在某一个时间点会自动执行的函数图里是vue2的，vue3在命名上多了on和setup2.x 版本生命周期相对应的组合式 APIbeforeCreate -&gt; 使用 setup()created -&gt; 使用 setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured  \ntemplate插值表达式用两个大括号\n&lt;div v-text=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出字符串&lt;div v-html=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出解析成html格式的字符串&lt;div&gt;&#123;&#123;name+&#x27; abc&#x27;&#125;&#125;&lt;/div&gt; 输出字符串var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      name: &quot;&lt;h1&gt;ella&lt;/h1&gt;&quot;,    &#125;,      &#125;);\ncomputed属性会有缓存，methods没有缓存性能较差watch监听变化也有缓存\n&lt;div&gt;    &#123;&#123;fullName&#125;&#125;    &#123;&#123;age&#125;&#125;&lt;/div&gt; var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      firstName:&quot;Ella&quot;,      lastName:&quot;L&quot;,      age:20    &#125;,    computed:&#123;        fullName:function()&#123;            return this.firstName+&quot; &quot;+this.lastName        &#125;    &#125;,    watch:&#123;        firstName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,        lastName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,            &#125;,  &#125;);\nset和get设置方法\ncomputed: &#123;      fullName: &#123;        get: function () &#123;          return this.firstName + &quot; &quot; + this.lastName;        &#125;,        set:function(value)&#123;            var arr=value.split(&quot; &quot;);            this.firstName=arr[0];            this.lastName=arr[1];        &#125;      &#125;,    &#125;,\n样式绑定.通过v-band绑定class或者style来实现可以绑定对象也可以是数组\n&lt;style&gt;    .activated&#123;        color: aquamarine;    &#125;&lt;/style&gt;&lt;div @click=&quot;handleDivClick&quot;     :class=&quot;&#123;activated:isActivated&#125;&quot;    或者&quot;[activated]&quot;&gt;Ella&lt;/div&gt;methods: &#123;    handleDivClick:function()&#123;    this.isActivated=!this.isActivated;    或者this.activated=this.activated===&quot;activated&quot;?&quot;&quot;:&quot;activated&quot;;    &#125;&#125;,再或者&lt;div :style=&quot;styleObj&quot;&gt;hello world&lt;/div&gt;绑定style直接设置\n条件渲染v-if 对应的值为false直接在dom上不存在v-show 对应的值为false，dom上存在，不显示v-if可以写循环，必须连在一起\n&lt;div v-if=&quot;show===&#x27;a&#x27;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;show ===&#x27;b&#x27;&quot;&gt;B&lt;/div&gt;&lt;div v-else&gt;C&lt;/div&gt;\nkey值唯一可以保证不被复用在控制台直接用下标[]修改数组内容是不会改变页面显示要使用相应的修改函数才可以push pop shift unshift splice sort reverse或者直接改变数组引用对象也可以对象也可以循环，用set方法修改内容Vue.set(app.list,”number”,18)app.$set(app.list,”number”,18)Vue.set(target, key, val)\n&lt;div v-for=&quot;(item, index) of list&quot;           :key=&quot;item.id&quot;&gt;           &#123;&#123;item.text&#125;&#125;---&#123;&#123;index&#125;&#125;      &lt;/div&gt; 数组&lt;div v-for=&quot;(item, key) of list&quot;&gt;           &#123;&#123;item&#125;&#125;--&#123;&#123;key&#125;&#125;      &lt;/div&gt; 对象\n\\里面有\\里面有\\里面有\\\\里面不能直接用template，但是可以用is语句来指向template子组件ul,ol,select标签同理子组件里data必须是函数，不能是父组件中的对象，因为子组件都拥有独立数据不共享\n用ref来操作dom\n&lt;div  ref=&quot;hello&quot;             @click=&quot;handleClick&quot; &gt;hello world&lt;/div&gt;methods: &#123;      handleClick: function()&#123;        console.log(this.$refs.hello)；        console.log(this.$refs.hello.innerHTML)      &#125;    &#125;,\n\n父子组件传递父组件向子组件传数据，要在父组件components里先注册，然后标签里传参，子组件用props接收属性数据，且最好不要修改，克隆一个副本修改子组件向父组件传值调用$emit(方法名)，父组件在标签里用@监听方法然后触发事件子组件的\n&lt;div id=&quot;app&quot;&gt;      &lt;counter :count=&quot;0&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;注意在这里定义的事件是和父组件绑定的，要子组件$emit      &lt;counter :count=&quot;1&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;      &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;    &lt;/div&gt;var counter = &#123;    props: [&quot;count&quot;],    data: function () &#123;      return &#123;        number: this.count,      &#125;;    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&quot;,这里定义的事件才是子组件自定义事件，和子组件里面的method绑定    methods: &#123;      handleClick: function () &#123;        this.number++;        this.$emit(&quot;change&quot;, 1);      &#125;,    &#125;,  &#125;;  var vm = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      total: 1,    &#125;,    components: &#123;      counter: counter,    &#125;,    methods: &#123;      handelIncrease: function (step) &#123;        this.total += step;      &#125;,    &#125;,  &#125;);\n传参校验非props特性会显示在dom标签里，父组件传子组件不接收绑定原生事件只需要在事件后加上.native非父子组件传值bus 发布订阅模式 观察者模式\n&lt;div id=&quot;app&quot;&gt;      &lt;child content=&quot;ella&quot; &gt;&lt;/child&gt;      &lt;child content=&quot;syray&quot;&gt;&lt;/child&gt;    &lt;/div&gt;Vue.prototype.bus = new Vue();  Vue.component(&quot;child&quot;, &#123;    data:function()&#123;        return&#123;            selfContent:this.content        &#125;    &#125;,    props: &#123;      content: String,    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&quot;,    methods:&#123;        handleClick:function()&#123;            this.bus.$emit(&#x27;change&#x27;,this.selfContent)        &#125;    &#125;,    mounted:function()&#123;        var this_=this;        this.bus.$on(&#x27;change&#x27;,function(msg)&#123;            this_.selfContent=msg;        &#125;)    &#125;  &#125;);  var vm = new Vue(&#123;    el: &quot;#app&quot;,  &#125;);\n插槽\n&lt;div id=&quot;app&quot;&gt;      &lt;child&gt;        &lt;p slot=&quot;head&quot;&gt;ella1&lt;/p&gt;        &lt;p slot=&quot;foot&quot;&gt;ella2&lt;/p&gt;      &lt;/child&gt;    &lt;/div&gt; template: `&lt;div&gt;                    &lt;p&gt;hello&lt;/p&gt;                    &lt;slot name=&#x27;head&#x27;&gt;default&lt;/slot&gt;                    &lt;slot name=&#x27;foot&#x27;&gt;default&lt;/slot&gt;               &lt;/div&gt;`,\n\n动态组件v-once是创建一次就放入内存中，提高性能，不会反复创建\n&lt;div id=&quot;app&quot;&gt;      &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;      &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;  Vue.component(&#x27;child-one&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;one&lt;/div&gt;&#x27;  &#125;)  Vue.component(&#x27;child-two&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;two&lt;/div&gt;&#x27;  &#125;)    var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        type:&#x27;child-one&#x27;    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.type=this.type===&#x27;child-one&#x27;?&#x27;child-two&#x27;:&#x27;child-one&#x27;;        &#125;    &#125;  &#125;);\nCSS动画效果是通过在某一时间上自动往标签上增加一些样式实现的\n//过渡效果&lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;&lt;/style&gt;//弹跳效果&lt;style&gt;        @keyframes bounce-in &#123;            0%&#123;                transform:scale(0);            &#125;            50%&#123;                transform:scale(1.5);            &#125;            100%&#123;                transform:scale(1);            &#125;        &#125;        .v-enter-active&#123;            transform-origin: left center;            animation: bounce-in 1s;        &#125;        .v-leave-active&#123;            transform-origin: left center;            animation: bounce-in 1s reverse;        &#125;&lt;/style&gt;&lt;transition&gt;    &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;&lt;/transition&gt;    &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;//配合使用css动画库&lt;link    rel=&quot;stylesheet&quot;    href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot;    /&gt;    &lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;    &lt;/style&gt;&lt;div id=&quot;app&quot;&gt;        &lt;transition         type=&quot;transition&quot;        //这里可以自定义入场和出场动画时长        :duration=&quot;&#123;enter:5000,leave:10000&#125;&quot;        appear        enter-active-class=&quot;animate__animated animate__swing v-enter-active&quot;        leave-active-class=&quot;animate__animated animate__flip v-leave-active&quot;        appear-active-class=&quot;animate__animated animate__flash&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;//jS动画&lt;div id=&quot;app&quot;&gt;        &lt;transition             @before-enter=&quot;handleBeforeEnter&quot;            @enter=&quot;handleEnter&quot;            @after-enter=&quot;handleAfterEnter&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt; var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        show:true    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.show=!this.show;        &#125;,        handleBeforeEnter:function(el)&#123;            el.style.color=&#x27;red&#x27;        &#125;,        handleEnter:function(el,done)&#123;            setTimeout(()=&gt;&#123;                el.style.color=&#x27;green&#x27;            &#125;,2000)            setTimeout(()=&gt;&#123;                done()            &#125;,4000)        &#125;,        handleAfterEnter:function(el)&#123;            el.style.color=&#x27;blue&#x27;;        &#125;    &#125;  &#125;);//velocity库handleEnter:function(el,done)&#123;            Velocity(el,&#123;opacity:1&#125;,&#123;duration:1000,complete:done&#125;)        &#125;,\n\n动画封装\nVue3\n指令语法\n数组变更方法push()pop()shift()unshift()splice()sort()reverse()非变更方法filter(), concat(), slice()reverse()和sort()调用之前创建一个原数组的副本\n事件处理内敛事件 方法事件\n生命周期不要用箭头函数，否则无法用this访问组件实例\nwatch侦听器\n路由动态路由匹配 :传递routes:{}里面的的路由地址可以有相对路径，可以嵌套子路径\\&lt;/router-link>里面必须是绝对路径$router.push(“”)JS实现页面跳转 ?传递使用命名路由跳转的时候注意要用v-bind:to=”{name:’’,params:{}}”\n组件注意data是一个函数要返回return，组件之间不共享\n\n问题axios发送post请求会405\nbind()方法主要是可以改变原本函数的this指向\nref用法this.$ref.取到的是dom元素/组件实例\n开发注意小知识点\n\\传参是v-bind:to:to=”{path:’/root’,query:{id:value}}”\nv-bind:class以键值对的形式绑定操作\nimporthttps://blog.csdn.net/qq_40323256/article/details/101867706注意export导出的引入要{}，export default不需要\n\n前后端分离问题汇总完整逻辑https://blog.csdn.net/qq_42345108/article/details/108249173\n\nelement UI表单 验证https://blog.csdn.net/qq_41008567/article/details/115939951\naxioshttps://www.axios-http.cn/docs/intro请求/响应前进行拦截拦截器逻辑顺序\n在vue.config.js里定义devServer的代理服务器和api前缀指向\n然后定义utils文件夹里的request.js，在该文件里引入axios，创建axios对象和要访问的URL即前面定义的API前缀，然后定义请求和响应拦截器，最后export定义的request对象\n在apis文件夹里引入定义好的request对象，开始编写具体的request函数，包括后台接口的url，http协议方法，传递的参数\n在vue视图里引入apis里的request函数并调用，注意调用后的返回值这里同样可以直接在vue组件里面使用类似下方结构来调用\n\n\n\naxios.post(&quot;/users/payMent&quot;,&#123;                addressId:addressId,                orderTotal:this.orderTotal              &#125;).then((response)=&gt;&#123;                  let res = response.data;                  if(res.status==&quot;0&quot;)&#123;                      this.$router.push(&#123;                          path:&#x27;/orderSuccess?orderId=&#x27;+res.result.orderId                      &#125;)                  &#125;              &#125;)\nget请求参数不同posthttps://zhuanlan.zhihu.com/p/275695831\n\nvuex状态管理模式解构简写\n\nimport &#123; mapState &#125; from &#x27;vuex&#x27;computed:&#123;  ...mapState([&#x27;nickName&#x27;,&#x27;cartCount&#x27;])&#125;,\n\nstate唯一数据源，单一状态树computed里面定义this.$store.state.\ngetter可以派生出一些新的状态可以直接在state数据上包装而不用重新定义数据，类似数据库里视图的概念this.$store.state.getters\nmutation更改state的唯一方法是提交mutationthis.$store.commit()\naction提交的是mutation，而不是直接变更状态可以异步操作调用this.$store.dispatch(“f”)定义f(a){a.commit()}\nmodule将多个store对象分割成模块\n\n\nthisthis对象问题https://juejin.cn/post/7109889547537743886this.$https://segmentfault.com/a/1190000040894587\n\nvue插件extend和component类似https://juejin.cn/post/7239715295484821565\n\nwebpackhttps://cloud.tencent.com/developer/article/1797938\n\n跨域问题\n\n\necharts实战vue3部分问题解决方案\nvscode插件加载不全，重载几遍就好了\n./APP.vue找不到https://blog.csdn.net/XSL_HR/article/details/128437240\nrouter-view不渲染由于没有后端支持，创建路由的history部分要用hashhttps://blog.csdn.net/weixin_43575792/article/details/122655356\n基本都是围绕setup里面响应式数据声明出的问题ref和reactivereactive对象赋值是深拷贝地址会变化，如果不是每个内部属性挨个赋值响应式对象，整体对象就会失去响应性，reactive返回的是对原始对象的引用，使用toRefs来解构toRef是将对象的属性转化为ref对象，浅拷贝，跟原本对象的属性对应地址引用是同一个，可以修改\nvuex和vue-router部分有了更新\n\n","categories":["技术学习"],"tags":["前端","Vue.js","vue2","vue3"]},{"title":"一战腾讯","url":"/2024/03/06/%E4%B8%80%E6%88%98%E8%85%BE%E8%AE%AF/","content":"无笔试，面试初试(已挂)部门：qq的PC端的某前端开发岗(PCG)形式：电话时长：15min时间：2024/3/6 11:00\n内容回忆\n投的前端岗位，为什么简历上无前端项目经历？\n 当时写简历的时候觉得自己搞得全栈项目只做了部分功能，不太好意思写，总不能把跟着视频网站敲的项目放上去吧……但其实蓝鲸项目是有前端部分的，但貌似被面试官忽略了(尴尬)\n\n介绍自己开发过最难的一个前端项目，里面实现了哪些功能技术点，用的什么技术栈？\n 因为确实没有做过很复杂的前端项目，自己搭建后端服务器和数据库做的全栈项目只完成了一部分，而且重点放在页面实现和美化上了，前后端交互的部分太简单了，也没有尝试过部署项目(还是太摆烂了)。我自己开发中遇到的比较多的都是页面渲染和JS交互逻辑的问题，而且都是服务器是本地搭建的，数据也很多是静态数据，所以在前后端交互上答得不太好(悲)\n\n登录与注册页面的原生逻辑是怎样实现的(不用插件)，如何保持浏览器登录状态？\n 这里回答的有点不对题，我回答的是登录进去后在应用中如何保持登录状态(jwt返回的token值保存在localStorage里)，被打断了，应该是用户点进登录页面后浏览就要自动识别呈现是登录页还是注册页，面完后才想起来可能是回答cookie相关  \n 才发现应该想问的是如何实现单点登录(悲，是JavaScript里面的，只顾着看Vue.js了)，参考这个网址 https://vue3js.cn/interview/JavaScript/single_sign.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88\n\n是否了解过axios的使用过程，封装的源码逻辑？(vuex)\n 我其实没看过封装的源码(流汗)，只能按照自己的理解说，能感觉到应该没说到点子上\n\n我的项目中用了很多封装好的模块，被提问不用封装模块该怎么用JS原生代码实现？\n 前面介绍自己的项目时说了一堆花里胡哨的功能，引入了一堆组件插件，回旋镖打在自己身上了(汗流浃背了)\n\n怎么处理跨域问题？(还有一些前后端交互的部分)\n 我说了两个，但感觉面试官觉得这两个方法都不是他想听的?\n\n\n反思整场面试都在围绕项目开发中的问题，算法/数据结构、JS/HTML/CSS/Vue语法、计算机网络、操作系统、后端/数据库语法 全部都 没问，然后我复习的基本是这些内容。本以为具体项目开发二面三面才会，没想到一来就是项目开发里的问题，感觉就是婉拒了(bushi)。然后就是一直问有没有看过源码和封装逻辑，这个确实忽略了，都是直接用了，回答的时候很尴尬  \n总之，这次面试确实是太赶了，临时决定要投一下试试，很多东西都没准备好，果然挂了。现在的我对于前端知识很多处在一个知其然不知其所以然的状态，接下来还是要 搞一个复杂的项目实战，并且不能依赖插件，要看源码，尝试自己动手封装 ，当然 计算机基础知识和算法题 也要好好刷(也有点庆幸这次没问算法，不然挂的更快)，后续实习投递都有笔试或者现场手撕代码的\n没关系，第一次面试而已，来日方长~","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"二战腾讯","url":"/2024/03/07/%E4%BA%8C%E6%88%98%E8%85%BE%E8%AE%AF/","content":"无笔试，面试初试部门：技术架构团队(WXG)形式：视频时长：一个半小时时间：2024/3/8 10:00\n内容回忆\n问了一下项目经历\n 我投的是前端岗位，然后揪着我的后端项目问了快20min，我真的忘了我那个后端做的是什么了(感觉越讲越乱，有点崩溃)，我发现面试都喜欢问登录和注册问题\n 后续面试前还是要把自己所有项目都过一遍，讲清楚业务场景，功能逻辑以及技术栈的使用\n\nJavaScript\n 现在有点后悔，当时JavaScript ES5的语法书只看到了第十三章，只看了DOM和BOM，后面的就没看了，然后八股文也还没来得及看完，面试的时候很多都不会答(叹气)\n 这里只能先记录一下子问到过的点，我之后重新彻底学一遍\n 事件循环、runtime、异步(setTimeout、setInterval、promise、async/await的区别)、JS底层逻辑、js和浏览器、内存泄露、跨域问题、查错调试、原型链\n\nVue.js\n 一来先问我为什么要学习vue框架以及怎么学习vue的，项目中遇到的一个难题以及如何解决\n 这里只能先记录一下子问到过的点，我之后重新彻底学一遍\n vue2和vue3的优劣(选项式和组合式API)、vue3的响应式实现、reactive和ref、跨域问题\n\n算法题\n 我最怕的事情还是发生了，算法题刚刚开始练习，js用的都不太顺手，一上来还要手撕代码，我以为手撕完就结束了，结果还要我自己讲解算法逻辑，分析时间复杂度和空间复杂度，看着我写的稀烂的代码，我讲的巨尴尬\n 题目分为两种，一种是 **纯算法，一种是 实现封装函数功能**\n 今天一类题是解决配对问题，我曾经好像一年前力扣刷过类似的，但是忘记解法了，当时用的还是C++写的，转换成JS逻辑反应了半天，等我去力扣找一下重新做一下\n 二类题是实现String里面indexOf方法，Array里面的reduce方法，Function里面的bind方法。我写倒是没问题，只是代码风格很偏Java和C++，被评价逻辑是对的，但是不符合语言规范，这里主要是怎么用原型链调用自身我真忘了，写不出来了\n\nbind方法调用方法查看https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind讲的蛮抽象的，简单讲就是修改this对象的指向以及传递参数几个参考的文章https://www.cnblogs.com/echolun/p/12178655.htmlhttps://juejin.cn/post/7207587475169476667\n\nreduce方法调用方法参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce参数如下：reduce(callbackFn, initialValue)callbackFn(accumulator,currentValue,currentIndex,array)实现参考https://zhuanlan.zhihu.com/p/356678016\n  Array.prototype.myReduce = function(reducer, initialValue) &#123;const hasInitial = arguments.length &gt; 1;let ret = hasInitial ? initialValue : this[0];for (let i = hasInitial ? 0 : 1; i &lt; this.length; i++) &#123;    ret = reducer.call(undefined, ret, this[i], i, this);&#125;return ret;&#125;\n等我把js再学得透彻点后就去看v8源码，那个是c++写的JavaScript引擎底层逻辑，可以看看一些内置对象的实现\n\n\n\n\n反思整场面试长达一个半小时，两个面试官轮流面试我，我也是第一次参加这种技术面试，有点赶鸭子上架，JS语法、Vue语法还有算法都没准备好，加上面试前一天晚上临时熬到三点，恶补算法，看来用处不大, 算法还是要一步一步稳扎稳打的来\nJS和vue的基础语法是不可能考的，问的都是比较难的的点，我也知道这些是重要考点但还没来得及复习到或者没理解透(悲)，所以还是要 重新系统的过一遍，把重难点彻底掌握倒背如流\n后期还是要整一下自己的 前端项目，不然我的简历上只能放后端项目，还要被揪着问后端问题\n这里放一个本次面试涉及到的知识点汇总，需要重新学过\n[ ] 事件循环\n[ ] runtime\n[ ] 异步(setTimeout、setInterval、promise、async/await的区别)\n[ ] JS底层逻辑\n[ ] js和浏览器\n[ ] 内存泄露\n[ ] 跨域问题\n[ ] 查错调试\n[ ] 原型链\n[ ] vue2和vue3的优劣(选项式和组合式API)\n[ ] vue3的响应式实现\n[ ] reactive和ref\n[ ] 跨域问题\n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"LearningNotes","url":"/2024/03/08/LearningNotes/","content":"数据结构数据结构笔记\n","categories":["大学笔记"],"tags":["学习"]},{"title":"前端面试知识点汇总","url":"/2024/03/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"记录了我自己准备前端面试时复习的内容\n参考了 https://vue3js.cn/interview/\nHTML CSSJavaScript\n回调函数嵌套 函数体在完成某种操作后由内向外调用某个外部函数函数作为参数传递给另外一个函数回调地狱回调函数是一个this对象的方法时，必须保证this对象的上下文，Call和Apply函数来保存this\n\nES6\nvar let const作用域. 变量提升. 重复声明. 暂时性死区\n数组新增\n… 数组变成参数序列浅拷贝 解构赋值 参数最后一位 iterator对象转成数组\n构造函数 Array.from() Array.of()\n实例对象方法copyWithin() 复制覆盖find(). findIndex() 查找fill() 填充entries()，keys()，values() 遍历includes() 判断是否包含flat()，flatMap() 扁平化（层数）\n\n\n对象新增\n简写\n属性名表达式\nsuper指向当前对象的原型对象\n扩展运算符 解构赋值 浅拷贝\n属性遍历 数值键-&gt;字符串键-&gt;symbol键for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n方法Object.is() 严格相等 +0不等于-0，NaN等于自身Object.assign() 对象合并 浅拷贝替换Object.getOwnPropertyDescriptors()Object.setPrototypeOf()，Object.getPrototypeOf()Object.keys()，Object.values()，Object.entries()Object.fromEntries()\n\n\n函数新增\n参数 尾参数\nlength name\n箭头函数 参数=&gt;返回值\n\n\nSet Map\nSetadd() delete() has() clear()keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员数组字符串去重filter 并集交集差集\nMapset() get() has() delete() clear()keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回所有成员的遍历器forEach()：遍历 Map 的所有成员weak没有遍历属性\n\n\npromisePromise(function(resolve, reject) {})then()catch()finally()Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\ngeneratorfunction关键字与函数名之间有一个星号函数体内部使用yield表达式，定义不同的内部状态通过next方法才会遍历，直到一个yield表达式暂停，返回值是yield表达式的值，下一次next方法继续，直到returnnext可以带一个参数，当做一个yield表达式的返回值返回的是Iterator对象，可以通过for…of进行遍历\n异步处理回调函数Promise 对象generator 函数 可以控制迭代async/await 本质上generator\nproxy用于创建一个对象的代理，从而实现基本操作的拦截和自定义var proxy = new Proxy(target, handler)Reflect 的所有属性和方法都是静态的（ Math 对象），提供拦截 JavaScript 操作的方法get() set() deleteProperty()Proxy.revocable(target, handler);取消代理在复杂操作前对操作进行校验或对所需资源进行管理拦截和监视外部对对象的访问使用 Proxy 保障数据类型的准确性使用Proxy实现观察者模式，观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\nmodule静态化 在编译时就完成模块加载export：用于规定模块的对外接口import：用于输入其他模块提供的功能\ndecorator装饰器命名相当于一个注释，在不改变原有代码情况下，对类和类属性原来功能进行扩充不能修饰函数\n\nVue.jsNode.jsNode.js 是一个开源与跨平台的 JavaScript 运行时环境事件驱动、非阻塞和异步输入输出模型\n算法\n前端diff算法 深度优先算法 时间复杂度:O(n) 最小量更新patch 比较虚拟DOM根节点是否同一类型，不同直接替换|patchVnode 进一步比较两个虚拟节点 有无text和children|updateChildren 都有子节点的情况下比较更新真实节点 四个指针，指向oldVnode子节点列表中的第一个节点和最后一个节点以及指向newVnode子节点列表中的第一个节点和最后一个节点，节点比较过，前的指针++，后的指针—\noldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)\noldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)，相同的话移动真实节点OE之后\noldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)，相同的话移动真实节点OS之前\noldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)\n如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置\nold先处理完，新增newS和newE之间的节点\nnew先处理完，删除oldS和oldE之间的节点key的设置 判断两个虚拟节点是否为相同节点不建议用index作为循环项的key，因为操作过程中index会改变，一些相同节点index变了会被当成新的节点，用id的话每个节点key都不同，便于更新时复用节点\n\n\n排序\n数据结构数组栈队列链表树图堆散列表  \n经典算法\n\n网络协议\nHTTPC/S模式 可以传输任意类型数据对象  明文传输，无身份验证 不安全默认端口80无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间无状态：HTTP协议无法根据之前的状态进行本次的请求处理  \nHTTPS加密传输  让HTTP运行安全的SSL/TLS协议(TCP/IP 协议与应用层协议之间)上默认端口443  因为加密和多次握手，性能相对较差通信过程:\n\n首先客户端通过URL访问服务器建立SSL连接\n服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端\n客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级\n客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站\n服务器利用自己的私钥解密出会话密钥\n服务器利用会话密钥加密与客户端之间的通信\n\n\nSSL\n\n对称加密：加密和解密使用的秘钥是同一个，秘钥发送的过程中容易被窃取\n非对称加密：有公钥和私钥，公钥加密后只能用私钥解密，私钥加密后也只能用公钥解密  \n混合加密：发送者用会话密钥加密消息（对称），用公钥加密的会话密钥（非对称），两个一起发送消息接收者用自己的私钥解密出会话密钥，用会话密钥解密消息  \n摘要算法：会话密钥 对称的 明文和摘要一起加密验证信息的完整性  散列函数、哈希函数把消息数据转化成一个特殊字符串，接收者比对接收到的明文计算出的消息摘要和接收到的信息摘要  \n数字签名：公私钥 非对称  身份验证摘要私钥加密成数字签名，公钥解开后再比对原文验证  \nCA验证机构:  \n\n服务器有一套公钥和私钥，把公钥发给CA机构\nCA机构用机构私钥给服务器公钥署数字签名，颁发公钥证书(服务器公钥+数字签名)\n浏览器中预设了机构公钥，客户端拿到服务器的公钥证书，可以自行解密数字签名，得到服务器公钥，跟公钥证书比对\n客户端用服务器公钥加密报文，服务器用服务器私钥解密\n\n\n\n\nUDP\n\nTCP\n\n\nGit\necharts可视化最重要的就是id问题，不能重复\n\nprovide inject导入echarts对象\n获取后端数据\nonMounted里初始化渲染，因为要获取dom元素\n看文档setOption，notMerge: true\n自适应大小window.onresize = function () {myChart1.resize();}\n放echarts的容器要预先设置大小才会渲染\n\nexpressMongoDB","categories":["技术学习"],"tags":["前端","面试"]},{"title":"小说设定","url":"/2024/03/22/%E5%B0%8F%E8%AF%B4/","content":"\n  07ed7c46d3dc6a1a93d603326c60ccbcc94e56516da55d898759613cc12ffaa5c8d75fc065932f3369dbb0173dedbe55\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["OC","小说"],"tags":["小说","OC"]},{"title":"计算机网络","url":"/2024/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"","categories":["技术学习","八股文"],"tags":["计算机网络"]},{"title":"算法学习笔记（二）","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（一），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \n题库LeetCode75本题库涉及到的知识点一览\n\n[ ] 数组 / 字符串\n[ ] 双指针\n[ ] 滑动窗口\n[ ] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈\n[ ] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[ ] 二叉搜索树\n[ ] 图 - 深度优先搜索\n[ ] 图 - 广度优先搜索\n[ ] 堆 / 优先队列\n[ ] 二分查找\n[ ] 回溯\n[ ] 动态规划 - 一维\n[ ] 动态规划 - 多维\n[ ] 位运算 338\n[ ] 前缀树\n[ ] 区间集合\n[x] 单调栈\n\n238.除自身以外数组的乘积题目：\n给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n\n解析：\n经典的前缀和和后缀和，不做多解释了，不过可以稍微优化一下，毕竟维护两个数组内存消耗太大了\n/** * @param {number[]} nums * @return {number[]} */var productExceptSelf = function(nums) {    const len=nums.length;    let ans=new Array(len).fill(1);    let L=1;    for(let i=0;i&lt;len;i++){        ans[i]*=L;        L*=nums[i];    }    let R=1;    for(let i=len-1;i&gt;=0;i--){        ans[i]*=R;        R*=nums[i];    }    return ans;};\n206.反转链表进阶题目：\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。使用递归完成\n\n解析：\n简单解法就是迭代，双指针，保存当前和之前节点，然后遍历修改指向对象\n比较复杂的是递归，需要理解想让指向，可以通过，然后要注意的下一个节点要指向null\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function(head) {    if(head==null||head.next==null){        return head    }    //靠这一步一直递归到列表的最后一个节点    const newHead=reverseList(head.next);    /*    第一轮出栈，head为5，head.next为空，返回5    第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，        把当前节点的子节点的子节点指向当前节点        此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null        此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5        返回节点5    第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，        此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null        此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5        返回节点5    第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，        此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null        此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5        返回节点5    出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1     */    head.next.next=head;    head.next=null;    return newHead};s\n1969.数组元素的最小非零乘积题目：\n给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：从 nums 中选择两个元素 x 和 y  。选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。注意：答案应为取余 之前 的最小值。\n\n解析：​贪心：为了使整体的乘积最小，缩小时优先缩小最小的元素，增加时优先增加最大的元素\n证明：假设a &lt; b &lt; c。选择a缩小1时，此时三者乘积为 (a−1)bc，整体较 abc 缩小了 bc，缩小的幅度最大；当选择b增加1时，此时三者乘积为(a−1)(b+1)c，整体较(a−1)bc 增加了 (a−1)c，增加的幅度最小，得证。\n两个数在进行相同的位交换时，本质即将一个元素缩小 ，另外一个元素增加，为了让这两个数乘积最小，应该尽量把小的那个数换成1。\n根据上述分析，进行相同位交换时，优先缩小数组中最小的元素，再增加数组中最大的元素。\n可以以p为分界线，小于p的为一组，大于p的为一组，大小组的每一个元素(除了)外，遵循最大配最小，第二大配第二小的原则，两两配对(每组两个数之和为)，交换后的必然为和1，乘积是。\n最后，最小乘积为\n由于幂次很大，计算时需要用到快速幂，之前有题目用到了快速幂(指路算法笔记（一）1137.第N个泰波那契数 https://ella1019.site/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/#1137-%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)\n/** * @param {number} p * @return {number} */const MOD = 1_000_000_007n;function pow(x, p) {    let res = 1n;    while (p--) {        res = res * x % MOD;        x = x * x % MOD;    }    return res;}var minNonZeroProduct = function(p) {    const k = (1n &lt;&lt; BigInt(p)) - 1n;    return k * pow(k - 1n, p - 1) % MOD;};\n338.比特位计数题目：\n给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。\n\n解析：\n借由本题学习一下位运算相关的知识\n\nBrian Kernighan 算法 对于任意整数x，令 ，该运算将x的二进制表示的最后一个1变成 0，以及后面的0都变成1，而1前面的数不会变。进行&amp;操作之后原本最后一个1以及后面所有的0都会变成0，这样成功实现了减少一个1的目的，可以用这个方法来计数所有的1的个数\n 总的时间复杂度为O(nlogn)\n /** * @param {number} n * @return {number[]} */var countBits = function (n) {    const bits = new Array(n + 1).fill(0);    const countOnes = (x) =&gt; {        let ones = 0;        while (x &gt; 0) {            x &amp;= (x - 1);            ones++;        }        return ones;    }    for (let i = 0; i &lt; n + 1; i++) {        bits[i] = countOnes(i);    }    return bits;};\n\n动态规划(最高有效位) 主要是利用2的整数幂(  )对应的二进制表示都是最高位是1，其余位都是0，这里尝试抽象出状态变化 \n 举一个例子，13的二进制表达为1101，它的最高位是1000，即为8(  )，减去最高位后5的二进制表达式为101，1的个数比13要少1\n 那么只需要遍历然后判断2的整数幂即可\n var countBits = function(n) {    const bits = new Array(n + 1).fill(0);    let highBit = 0;    for (let i = 1; i &lt;= n; i++) {        if ((i &amp; (i - 1)) == 0) {            highBit = i;        }        bits[i] = bits[i - highBit] + 1;    }    return bits;};\n\n动态规划(最低有效位)\n\n\n\n未完待续~","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（一）","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言最近在准备面试，投递岗位主要是前端，但是本人也有点想转后端，所以算法题必刷不可。本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java数据结构部分回顾直接看我大二上的数据结构复习笔记，感觉网上查到的没有总结的特别好和全面的(如果我还有精力，会考虑把之前专业课的笔记也放上来。以前的笔记都是OneNote里写的，不是Markdown语法，还都是全英的，整理起来有点复杂)目前先看了一下算法基础，可以参考以下文章的介绍，基本上js扫盲没问题，然后开始力扣刷题https://juejin.cn/post/7087134135193436197\n力扣目前是先把LeetCode75刷完，同时也做每日一题，进行算法扫盲  \n唉，没想到上一次刷力扣都是一年前了，这一次争取刷题量大一点，坚持的久一点，会持续更新的  \n算法笔记（一）已经记录了二十道题，后续每二十道题会新开笔记，刷完后会对题型类别进行再整理\n\n\n题库LeetCode75本笔记涉及到的知识点一览\n\n[ ] 数组 / 字符串 334 151 1071 605 2789\n[ ] 双指针\n[ ] 滑动窗口 1493 1004 1793\n[ ] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈 735\n[ ] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[ ] 二叉搜索树\n[ ] 图 - 深度优先搜索 1261 841\n[ ] 图 - 广度优先搜索 2684 310\n[ ] 堆 / 优先队列 215\n[ ] 二分查找 875\n[ ] 回溯\n[ ] 动态规划 - 一维 1137\n[ ] 动态规划 - 多维 72 2312 62\n[ ] 位运算\n[ ] 前缀树\n[ ] 区间集合\n[x] 单调栈 739 901\n\n334.递增的三元子序列题目：\n给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。\n\n解析：\n\n双向遍历 其实本质上就是找到数组中的一个元素，左边有值比它小，右边有值比它大。那么新创建两个长度为n的MIN和MAX数组，即MIN[i]表示nums[0]到nums[i]中的最小值，MAX[i]表示nums[0]到nums[i]中的最大值，然后遍历nums数组找到MIN[i-1]&lt;nums[i]&lt;MAX[i+1]的返回true  \n 整个逻辑需要遍历数组三遍，额外创建两个数组\n\n贪心算法 简单说就是寻找局部最优解，再把每次迭代后的最优解叠加\n 本题目怎么联想到贪心呢，因为看完题目后三元组中的第一个肯定是越小越容易满足递增的情况，所以就是要找到最小的做first，第二小的做second，这样遍历只用找到比second大就返回true  \n 那么迭代思路就是先令nums[0]为first，second为正无穷，开始遍历。遇到nums[i]&gt;second的返回true;遇到first","categories":["技术学习","算法"],"tags":["前端","算法"]}]