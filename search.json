[{"title":"JavaScript学习笔记","url":"/2024/03/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"主要是介绍了ES5的语法，后面补充了ES6的不同之处\nJavaScript三部分核心(ECMAScript)语言的基本组成部分文档对象模型(DOM)把页面映射成多层节点结构 XML 扩展HTML提供访问和操作网页内容的方法和接口浏览器对象模型(BOM)与浏览器交互的方法和接口  \n&lt; script&gt;async:下载脚本，外部脚本文件有效，不保证执行顺序charset:src属性指定的字符集defer:延迟到文档完全被解析后执行，外部脚本文件有效src:包含执行代码的外部文件type:脚本语言内容类型，默认值text/javascript  \n放在HTML文件底部直接嵌入或包含外部文件直接嵌入要指定type属性\\ \\ 一对出现，函数内部出现记得用转义符号&lt;\\/script&gt;包含外部文件要指定src属性，\\ \\中不包含额外代码\\ \\放在\\元素中页面内容的后面  \n基本概念(只记录了一些跟我印象中不同的点)区分大小写var创建变量是局部变量，省略后是全局变量使用var和function声明的变量不可删除，因为被标记成不可配置了delete不能删除全局变量，但是可以删除window对象上定义的属性delete操作符跟直接释放内存无关，是断开引用间接完成的，对象的属性和数组成员才可以删除这样的删除仍然占据内存空间，要设置null才能释放\n\n数据类型  \n\n\nUndefined声明未初始化typeof()\nNull\nBooleantrue false 字面值 全小写其他类型的空值、0、NaN、null、undefined转换后都是false\nNumberNaN Number() parseInt() parseFloat()\nString转义字符\\不可变toString()\nobjectnew 跟Java蛮像的P35一些函数\n\ntypeof 返回数据类型 object null注意返回\n\n操作符（意外跟C很像）一元操作符自增自减前置后置位操作符~非&amp;与|或^异或&gt;&gt;右移&lt;&lt;左移 &gt;&gt;&gt;无符号右移==会强制转换 ===不会强制转换?:\n语句if do-while while for for-inlabel标识特定位置 break continue with设置作用域switch\n函数function 参数不限制个数和类型 通过argument对象访问元素参数传递都是值传递没有重载，后面覆盖\n引用instanceof\n作用域没有块级作用域，if for语句中初始化变量在语句执行完之后依旧存在于语句外部执行环境var是添加到最近的环境，没有就是添加到全局环境\n垃圾收集标记清除\n\n引用类型\nobject类型用new创建；对象字面量很像字典，都是花括号里属性名：属性值assign 静态方法将一个或者多个源对象中所有可枚举的自有属性复制到目标对象，并返回修改后的目标对象，当复制引用类型的属性时是浅拷贝，原型链上的属性和不可枚举的属性不能被复制\n\nArray类型每一项可以保存任何类型的数据，动态调整数组大小Array(数字)表示数组项目数量Array(其他类型参数)创建包含那个值的只有一项的数组方括号[]索引isArray()toString() 每个值的字符串形式，以逗号分隔valueOf()join()分隔符 转换成字符串push() pop() stackshift()移除第一个 unshift()前端添加 list queuereverse()翻转sort()比较字符串 默认UTF-16 码元值升序排序 小心15&lt;5，从字符串上看 定义compare函数作为参数传入sort() 就地排序 不会复制concat() 拼接字符串和多个数组的每一项 在内部元素为引用类型时是浅拷贝！slice() 返回[开始索引，结束索引)中间的项，负数则用数组长度加上该数来确定位置 在内部元素为引用类型时是浅拷贝！splice()\n\n删除 第一项位置，删除项数\n插入 起始位置，删除项数，插入的项\n替换 起始位置，删除项数，插入的项\n\n\n\nindexOf() lastIndexOf() includes() find()查找位置，没找到返回-1迭代方法 都不会改变原数组every() some() filter() forEach() map()reduce() reduceRight()\n\nString类型增删改查 都不是在原本字符串上修改，会创建新的副本+或者concat()会创建新的字符串副本slice() [开始索引，结束索引)前参数小于后参数否则返回空(负数加上字符串长度)substr() [开始索引，开始索引+索引长度)substring()[开始索引，结束索引)负数会看做0，参数可以任意顺序trim()、trimLeft()、trimRight()删除字符串前后空格符，中间不删repeat(n) 返回重复n次的拼接成果padStart()、padEnd()复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件toLowerCase()、 toUpperCase()chatAt()返回给定索引位置的字符indexOf()返回给定字符的索引位置，没有-1startWith() 返回是否包含的布尔值includes() 返回是否包含的布尔值split()把字符串按照指定的分割符，拆分成数组中的每一项match()返回正则表达式匹配后分割的数组 search()返回第一个匹配项第一个字符索引 replace(a,b) 把字符串中的a替换成b返回\n\nDate类型\n\nRegExp类型 每一次要创建新的实例g全局i不分大小写m多行exec()\n\nfunction类型function 函数名(参数){语句;}var 函数名=function(参数){语句;};一个函数可以有多个名字没有重载arguments callee用于解除代码和函数名的耦合this 先局部再全局call() apply()基本包装类型Boolean Number String不能添加属性和方法charAt() charCodeAt() slice() substr() substring() indexOf() trim() toLowerCase() toUpperCase() match() search() replace() split() localeCompare() fromCharCode()\n\n全局对象URI编码方法eval() 解析器 接受要执行的JS字符串window对象Math对象\n类型转换时的小坑Boolean({}) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true隐式转换有自动转布尔值，自动转换字符串(+运算符)，自动转换数值(除+运算符)\n面向对象创建对象的方式\n\n使用对象字面量：这是最简单和最常见的方式，直接在代码中定义对象。例如：\nvar person = &#123;    name: &#x27;John&#x27;,    age: 30,    greet: function() &#123;        console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);    &#125;&#125;;// 访问属性和调用方法console.log(person.name); // 输出：Johnperson.greet(); // 输出：Hello, my name is John and I am 30 years old.\n\n使用构造函数：构造函数允许你创建一个对象模板，然后通过 new 关键字调用构造函数,创建对象的实例。构造函数使用 this 关键字来指向新创建的对象。使用 this 关键字来创建属性或方法时，这些属性和方法会在使用 new 关键字创建对象时自动创建和声明，并绑定到实例对象上.\nnew主要是先创建一个新的对象obj，将对象与构建函数通过原型链连接起来(_proto_指向。prototype)，将构建函数中的this绑定到新建的对象obj上，根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理\n//构造函数function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;Person.prototype.greet = function() &#123;    console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);&#125;;// 创建实例var person1 = new Person(&#x27;Alice&#x27;, 25);var person2 = new Person(&#x27;Bob&#x27;, 30);// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n使用工厂函数：工厂函数是一种创建对象的函数，它类似于构造函数，但是不使用 new 关键字。它直接返回一个新的对象实例。例如：\nfunction createPerson(name, age) &#123;    return &#123;        name: name,        age: age,        greet: function() &#123;            console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);        &#125;    &#125;;&#125;// 创建对象实例var person1 = createPerson(&#x27;Alice&#x27;, 25);var person2 = createPerson(&#x27;Bob&#x27;, 30);// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n使用 ES6 中的类：在 ES6（ECMAScript 2015）以及之后的版本中，引入了类的概念，可以更方便地创建对象。类的语法更类似于其他面向对象语言。例如：\nclass Person &#123;    constructor(name, age) &#123;        this.name = name;        this.age = age;    &#125;    greet() &#123;        console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);    &#125;&#125;// 创建实例var person1 = new Person(&#x27;Alice&#x27;, 25);var person2 = new Person(&#x27;Bob&#x27;, 30);// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n使用 Object.create()：Object.create() 方法允许你基于一个现有的对象创建一个新的对象，可以指定新对象的原型。例如：\nvar personProto = &#123;    greet: function() &#123;        console.log(&#x27;Hello, my name is &#x27; + this.name + &#x27; and I am &#x27; + this.age + &#x27; years old.&#x27;);    &#125;&#125;;var person1 = Object.create(personProto);person1.name = &#x27;Alice&#x27;;person1.age = 25;var person2 = Object.create(personProto);person2.name = &#x27;Bob&#x27;;person2.age = 30;// 访问属性和调用方法console.log(person1.name); // 输出：Aliceperson2.greet(); // 输出：Hello, my name is Bob and I am 30 years old.\n\n\n对象有属性和方法使用Object.defineProperty()来修改属性特性\n\n数据属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nWritable能否修改属性值\nValue读写值\n\n\n访问器属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nGet读取\nSet写入使用Object.defineProperties()定义多个属性\n\n\n\n工厂模式 在函数里面新创建一个对象构造函数模式 把函数当做构造函数，在外部直接new对象原型模式 一个函数有prototype属性，其他实例共享prototype里面的属性和函数，先找对象实例本身属性，再找原型对象的属性，实例和原型之间的连接是指针每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针hasOwnProperty()inconstructor()可以随时为原型添加属性和方法，但不要重写\n构造函数和原型模式的组合动态原型模式 在构造函数里初始化原型函数寄生构造函数 要用new的工厂模式稳妥构造函数 不能用this\n实现继承 原型链搜索属性会沿着原型链往上通过原型链实现继承的时候，不能使用对象字面量创建原型方法，因为会重写原型链在每一个创建的子类对象上使用超类对象的call或者apply方法进行所有对象初始化寄生组合式继承是最完美的继承方式不必为指定子类型的原型而调用超类型的构造函数\n函数表达式\n函数声明:function 函数名(){}函数声明可以置于调用语句之后\n函数表达式:var 变量名=function(){};此为匿名函数要先赋值才可以调用编写递归函数，函数内部用argument.callee代替函数名函数第一次调用创建一个执行环境和作用域链，并把作用域连赋值给一个特殊的内部属性scope，然后初始化活动对象，外部，外部的外部，知道作用域链终点全局执行环境\n\n匿名函数function(){}如果是单独写匿名函数，要在外面加一个括号(function(){})，赋值/回调/返回时不加括号然后单独要运行要在后面再加一个括号(function(){})()，这样可以模拟私有作用域\n\n\n闭包，在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域闭包结构：\n\n一个函数，里面有一些变量和另一个函数\n外部函数里面的函数使用了外部函数的变量\n外部函数最后把它里面的那个函数用return抛出去\n\n闭包作用：\n\n在函数外部可以读取函数内部的变量，创建私有变量\n让这些变量的值始终保持在内存中，延长变量的生命周期\n\n闭包只能取得包含函数中任何变量的最后一个值解决方法是再嵌套一层函数，形成一个闭包注意this的指向问题，可能闭包函数是在window作用域下执行的，this就不是指向外部函数而是window内存泄漏问题，闭包引用外层对象，写一个变量保存对象副本，结束闭包后把对象置为null多次声明同一变量，会对后续声明视而不见在匿名函数中定义的任何变量都会在执行结束时被销毁(function(){作用域})\n//因为var不是块级作用域，而setTimeout是会等当前作用域的函数调用栈清空了，才开始执行，所以for里面i会先加到6，才执行5个setTimeout，最后导致输出都是6//最简单的办法是把var改成let，let有块级作用域，每次循环都是一个独立作用域中i，互不干扰for (var i = 1; i &lt;= 5; i++) &#123;  setTimeout(()=&gt;&#123;    console.log(i);  &#125;, 1000);&#125;//用闭包模拟了块级作用域for (var i = 1; i &lt;= 5; i++) &#123;  (function (j) &#123;    setTimeout(()=&gt;&#123;      console.log(j);    &#125;, 1000);  &#125;)(i)&#125;\n\nsetTimeout()\n\nBOM\nwindow对象全局作用域中声明的变量和函数收拾window对象的属性和方法尝试访问未声明的变量会抛出错误，但是可以查询window对象判断未声明的对象是否存在窗口关系和框架top对象指向最外层框架即浏览器窗口parent对象指向当前框架的直接上层框架没有框架的情况下parent=top=window窗口位置和大小moveTo(x,y)移动到实际位置moveBy(x,y)移动量resizeTo(x,y)设置大小resizeBy(x,y)新的和原来的差导航和打开窗口window.open()参数：URL，窗口目标，特性字符串，新页面是否取代浏览器中当前加载页的布尔值window.setTimeout()执行代码和等待时间clearTimeout()取消超时调用setInterval()间隔时间重复执行clearInterval()\n\nlocation对象既是window的属性也是document的属性location.search访问URL里面的内容location.assign()传递URLlocation.reload()无参重载/有参服务器重载\n\nnavigatorpluginsregisterContentHandler()\n\nscreen对象\n\nhistory对象\n\nDOM把HTML或者XML文档描绘成多层节点结构\n\nNode类型nodeType, nodeName, nodeValue, childNodes, NodeList, ownerDocumentappendChild(), insertBefore(),replaceChild(), cloneNode()(注意区别这里深复制是复制节点和子节点树，浅复制是只复制节点本身), normalize()\nDocument类型window对象的一个属性，可以当做全局对象来访问documentElement指向\\body指向\\title, URL, domain, referrergetElementById()getElementByTagName()返回的是同一个tag集合HTMLCollection.namedItem()HTMLCollection.getElementByNamed()特殊集合P258write(), writeln(), open(), close()\nElementattributes属性 get set remove\n\nquerySelector()接受CSS选择符\nHTML5getElementByClassName()classList属性 add() contains() remove() toggle()document.activeElement focus()HTMLDocument属性readyStatecompatModeheadcharsetdata-自定义数据属性innerHTMLouterHTMLscrollIntoView()简单描述一下就是一棵DOM树有节点和元素，还有自己对应的属性，可以创建节点然后添加到树里面，还可以直接设置元素的style属性可以直接查询包含某些类或者ID的元素遍历NodeIteratorTreeWalker\n事件事件捕获阶段(capture phase)处于目标阶段(target phase)事件冒泡阶段(bubbling phase)\naddEventListener(eventType, handler, useCapture)removeEventListener(eventType, handler, useCapture)\nuseCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false在冒泡过程中执行处理函数，与IE浏览器保持一致\nES6语法\n变量声明let const var可以创建块作用域\n剩余……参数 动态参数…variable…数组 拆解数组\napply(this,array) call(this,arg)\n解构赋值左侧定义了要取出的值剩余属性位于末尾结束解构模式\n箭头函数去掉function，直接(参数)=&gt;{}不能用作方法function定义的函数this随上下文变化而变化箭头函数this始终指向定义函数的环境\npromisePromise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数，接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。then：用于处理 Promise 成功状态的回调函数。catch：用于处理 Promise 失败状态的回调函数。finally：无论 Promise 是成功还是失败，都会执行的回调函数。\nfor in和 for of数组遍历用for of，对象遍历用for infor…in 语句以任意顺序迭代对象的可枚举属性。for…of 语句遍历可迭代对象定义要迭代的数据。\n\n运行时 runtimeJavaScript是一门解释执行语言。这意味着源代码在执行前，无需编译为二进制文件。JavaScript引擎以一段程序的形式存在，负责将源代码翻译为机器码，并通过 CPU来执行翻译后的机器码\n对比Java是先编译后执行的，能够将代码语法错误立即反馈给你。在JavaScript 中，只有当引擎尝试执行到有问题的那行代码时，才知道哪里出了问题。\n在 Web 开发中，引擎并不会被开发者直接使用到。JavaScript 引擎是运行在一个环境中的，这个环境提供了代码在执行时能够利用的附加特性。\n对比Java，Java 运行时环境（JRE）提供了访问所支持类库的方式，并且扮演了程序与操作系统之间的桥梁的角色。\nJavaScript 运行时是指 JavaScript 代码执行的环境。Web 浏览器和 Node.js 是两种常见的 JavaScript 运行环境。\n\nweb浏览器\n\nNode.js\n\n\n事件循环机制JavaScript 代码是在单一线程中执行的\nJavaScript 代码分为立即调用代码和事件回调代码\n事件循环机制是处理回调的机制。创建回调时，通常把它与一个特定事件关联起来。当特定事件发生时，运行时环境会将相关回调推入一个所谓的事件处理队列。事件循环机制会持续监控队列，并且按照先来后到的顺序执行其中的回调。\n同步任务进入主线程，即主执行栈，异步任务进入任务/回调队列，主线程内的任务执行完毕为空，会去任务/回调队列读取对应的任务，推入主线程执行\n\n微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 Promise.then\n执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完\nasync函数返回一个promise对象，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值，然后await会阻塞后面的代码(加入微任务队列)\nv8https://v8.js.cn/docs/\n执行环境this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象\n函数中的this也只能在运行时才能最终确定运行环境\n箭头函数再编译时就绑定了this指向\napply、call、bind三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入bind是返回永久改变this指向的函数，apply、call 则是立即执行，临时改变this指向一次\nFunction.prototype.myBind = function (context) &#123;    // 判断调用对象是否为函数    if (typeof this !== &quot;function&quot;) &#123;        throw new TypeError(&quot;Error&quot;);    &#125;    // 获取参数    const args = [...arguments].slice(1),          fn = this;    return function Fn() &#123;        // 根据调用方式，传入不同绑定值        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments));     &#125;&#125;\n原型每个对象的proto都是指向它的构造函数的原型对象prototype的构造函数是一个函数对象，是通过 Function构造器产生的，proto指向它的构造函数Function的原型对象prototype原型对象本身是一个普通对象，而普通对象的构造函数都是Object，proto指向它的构造函数Object的原型对象prototypeObject的原型对象proto属性指向null，null是原型链的顶端\n\n一切对象都是继承自Object对象，Object 对象直接继承根源对象null\n一切的函数对象（包括 Object 对象），都是继承自 Function 对象\nObject 对象直接继承自 Function 对象\nFunction对象的proto会指向自己的原型对象，最终还是继承自Object对象\n\n\najax和axios实现 Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤：创建 Ajax的核心对象 XMLHttpRequest对象通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态接受并处理服务端向客户端响应的数据结果将处理结果更新到 HTML页面中\naxios是通过Promise实现对ajax技术的一种封装\n正则表达式https://blog.csdn.net/weixin_52148548/article/details/123233957\nACM模式\njs node\n\nconst rl = require(&quot;readline&quot;).createInterface(&#123; input: process.stdin&#125;);var iter = rl[Symbol.asyncIterator]();const readline = async () =&gt; (await iter.next()).value;void async function () &#123;    // Write your code here    while(line = await readline())&#123;      //直接把函数内容写进来        let tokens = line.split(&#x27; &#x27;);        let a = parseInt(tokens[0]);        let b = parseInt(tokens[1]);        console.log(a + b);    &#125;&#125;()\nconst readline = require(&#x27;readline&#x27;);const rl = readline.createInterface(&#123;    input: process.stdin,    output: process.stdout&#125;);const inputArr = [];//存放输入的数据rl.on(&#x27;line&#x27;, function(line)&#123;  //line是输入的每一行，为字符串格式    inputArr.push(line.split(&#x27; &#x27;));//将输入流保存到inputArr中（注意为字符串数组）    //数字的话用parseInt(inputArr[0])转一下&#125;).on(&#x27;close&#x27;, function()&#123;    console.log(fun(inputArr))//调用函数并输出&#125;)//函数function fun() &#123; return xx&#125;\n","categories":["技术学习"],"tags":["前端","JavaScript","ES6"]},{"title":"LearningNotes","url":"/2024/03/08/LearningNotes/","content":"数据结构数据结构笔记\n","categories":["大学笔记"],"tags":["学习"]},{"title":"vue学习笔记","url":"/2024/03/04/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"这份笔记主要记录的是vue2和补充vue3的语法\n看了一下这个vue2全家桶列举挺完整全面的https://blog.csdn.net/qq_44663761/article/details/122328822?spm=1001.2101.3001.6650.16&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;utm_relevant_index=17\nvue3的补充更新语法https://24kcs.github.io/vue3_study/chapter4/01_Composition%20API_%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86.html\nvue3的关键在于理解Composition (组合) API和setup的使用\nvue基本语法v-for绑定迭代v-on绑定事件，简写形式”@”v-model绑定数据\n&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;var app=new Vue(&#123;        el:&#x27;#app&#x27;,        data:&#123;            list:[&#x27;first&#x27;,&#x27;second&#x27;],            inputValue:&#x27;&#x27;        &#125;,        methods:&#123;            handleBtnClick:function()&#123;                this.list.push(this.inputValue)                this.inputValue=&#x27;&#x27;            &#125;        &#125;    &#125;)\nv-bind绑定对象，简写形式”:”component全局组件\n&lt;todo-item v-bind:content=&quot;item&quot; v-for=&quot;item in list&quot;&gt;&lt;/todo-item&gt;Vue.component(&quot;TodoItem&quot;, &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;);\n局部组件\nvar TodoItem = &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [&quot;first&quot;, &quot;second&quot;],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,    &#125;,  &#125;);\n父子组件传值父组件v-bind的格式向子组件传递，然后props里接收子组件$emit向上一层触发事件，父组件监听获取\n&lt;todo-item          v-bind:content=&quot;item&quot;          v-bind:index=&quot;index&quot;          v-for=&quot;(item, index) in list&quot;          @delete=&quot;handleItemDelete&quot;        &gt;        &lt;/todo-item&gt;var TodoItem = &#123;    props: [&#x27;content&#x27;, &#x27;index&#x27;],    template: &quot;&lt;li @click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,    methods: &#123;      handleItemClick: function () &#123;        this.$emit(&quot;delete&quot;, this.index);      &#125;,    &#125;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,      handleItemDelete: function (index) &#123;        this.list.splice(index, 1);      &#125;,    &#125;,  &#125;);      \n生命周期函数是指vue实例在某一个时间点会自动执行的函数图里是vue2的，vue3在命名上多了on和setup2.x 版本生命周期相对应的组合式 APIbeforeCreate -&gt; 使用 setup()created -&gt; 使用 setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured  \ntemplate插值表达式用两个大括号\n&lt;div v-text=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出字符串&lt;div v-html=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出解析成html格式的字符串&lt;div&gt;&#123;&#123;name+&#x27; abc&#x27;&#125;&#125;&lt;/div&gt; 输出字符串var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      name: &quot;&lt;h1&gt;ella&lt;/h1&gt;&quot;,    &#125;,      &#125;);\ncomputed属性会有缓存，methods没有缓存性能较差watch监听变化也有缓存\n&lt;div&gt;    &#123;&#123;fullName&#125;&#125;    &#123;&#123;age&#125;&#125;&lt;/div&gt; var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      firstName:&quot;Ella&quot;,      lastName:&quot;L&quot;,      age:20    &#125;,    computed:&#123;        fullName:function()&#123;            return this.firstName+&quot; &quot;+this.lastName        &#125;    &#125;,    watch:&#123;        firstName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,        lastName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,            &#125;,  &#125;);\nset和get设置方法\ncomputed: &#123;      fullName: &#123;        get: function () &#123;          return this.firstName + &quot; &quot; + this.lastName;        &#125;,        set:function(value)&#123;            var arr=value.split(&quot; &quot;);            this.firstName=arr[0];            this.lastName=arr[1];        &#125;      &#125;,    &#125;,\n样式绑定.通过v-band绑定class或者style来实现可以绑定对象也可以是数组\n&lt;style&gt;    .activated&#123;        color: aquamarine;    &#125;&lt;/style&gt;&lt;div @click=&quot;handleDivClick&quot;     :class=&quot;&#123;activated:isActivated&#125;&quot;    或者&quot;[activated]&quot;&gt;Ella&lt;/div&gt;methods: &#123;    handleDivClick:function()&#123;    this.isActivated=!this.isActivated;    或者this.activated=this.activated===&quot;activated&quot;?&quot;&quot;:&quot;activated&quot;;    &#125;&#125;,再或者&lt;div :style=&quot;styleObj&quot;&gt;hello world&lt;/div&gt;绑定style直接设置\n条件渲染v-if 对应的值为false直接在dom上不存在v-show 对应的值为false，dom上存在，不显示v-if可以写循环，必须连在一起\n&lt;div v-if=&quot;show===&#x27;a&#x27;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;show ===&#x27;b&#x27;&quot;&gt;B&lt;/div&gt;&lt;div v-else&gt;C&lt;/div&gt;\nkey值唯一可以保证不被复用在控制台直接用下标[]修改数组内容是不会改变页面显示要使用相应的修改函数才可以push pop shift unshift splice sort reverse或者直接改变数组引用对象也可以对象也可以循环，用set方法修改内容Vue.set(app.list,”number”,18)app.$set(app.list,”number”,18)Vue.set(target, key, val)\n&lt;div v-for=&quot;(item, index) of list&quot;           :key=&quot;item.id&quot;&gt;           &#123;&#123;item.text&#125;&#125;---&#123;&#123;index&#125;&#125;      &lt;/div&gt; 数组&lt;div v-for=&quot;(item, key) of list&quot;&gt;           &#123;&#123;item&#125;&#125;--&#123;&#123;key&#125;&#125;      &lt;/div&gt; 对象\n\\里面有\\里面有\\里面有\\\\里面不能直接用template，但是可以用is语句来指向template子组件ul,ol,select标签同理子组件里data必须是函数，不能是父组件中的对象，因为子组件都拥有独立数据不共享\n用ref来操作dom\n&lt;div  ref=&quot;hello&quot;             @click=&quot;handleClick&quot; &gt;hello world&lt;/div&gt;methods: &#123;      handleClick: function()&#123;        console.log(this.$refs.hello)；        console.log(this.$refs.hello.innerHTML)      &#125;    &#125;,\n\n父子组件传递父组件向子组件传数据，要在父组件components里先注册，然后标签里传参，子组件用props接收属性数据，且最好不要修改，克隆一个副本修改子组件向父组件传值调用$emit(方法名)，父组件在标签里用@监听方法然后触发事件子组件的\n&lt;div id=&quot;app&quot;&gt;      &lt;counter :count=&quot;0&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;注意在这里定义的事件是和父组件绑定的，要子组件$emit      &lt;counter :count=&quot;1&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;      &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;    &lt;/div&gt;var counter = &#123;    props: [&quot;count&quot;],    data: function () &#123;      return &#123;        number: this.count,      &#125;;    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&quot;,这里定义的事件才是子组件自定义事件，和子组件里面的method绑定    methods: &#123;      handleClick: function () &#123;        this.number++;        this.$emit(&quot;change&quot;, 1);      &#125;,    &#125;,  &#125;;  var vm = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      total: 1,    &#125;,    components: &#123;      counter: counter,    &#125;,    methods: &#123;      handelIncrease: function (step) &#123;        this.total += step;      &#125;,    &#125;,  &#125;);\n传参校验非props特性会显示在dom标签里，父组件传子组件不接收绑定原生事件只需要在事件后加上.native非父子组件传值bus 发布订阅模式 观察者模式\n&lt;div id=&quot;app&quot;&gt;      &lt;child content=&quot;ella&quot; &gt;&lt;/child&gt;      &lt;child content=&quot;syray&quot;&gt;&lt;/child&gt;    &lt;/div&gt;Vue.prototype.bus = new Vue();  Vue.component(&quot;child&quot;, &#123;    data:function()&#123;        return&#123;            selfContent:this.content        &#125;    &#125;,    props: &#123;      content: String,    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&quot;,    methods:&#123;        handleClick:function()&#123;            this.bus.$emit(&#x27;change&#x27;,this.selfContent)        &#125;    &#125;,    mounted:function()&#123;        var this_=this;        this.bus.$on(&#x27;change&#x27;,function(msg)&#123;            this_.selfContent=msg;        &#125;)    &#125;  &#125;);  var vm = new Vue(&#123;    el: &quot;#app&quot;,  &#125;);\n插槽\n&lt;div id=&quot;app&quot;&gt;      &lt;child&gt;        &lt;p slot=&quot;head&quot;&gt;ella1&lt;/p&gt;        &lt;p slot=&quot;foot&quot;&gt;ella2&lt;/p&gt;      &lt;/child&gt;    &lt;/div&gt; template: `&lt;div&gt;                    &lt;p&gt;hello&lt;/p&gt;                    &lt;slot name=&#x27;head&#x27;&gt;default&lt;/slot&gt;                    &lt;slot name=&#x27;foot&#x27;&gt;default&lt;/slot&gt;               &lt;/div&gt;`,\n\n动态组件v-once是创建一次就放入内存中，提高性能，不会反复创建\n&lt;div id=&quot;app&quot;&gt;      &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;      &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;  Vue.component(&#x27;child-one&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;one&lt;/div&gt;&#x27;  &#125;)  Vue.component(&#x27;child-two&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;two&lt;/div&gt;&#x27;  &#125;)    var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        type:&#x27;child-one&#x27;    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.type=this.type===&#x27;child-one&#x27;?&#x27;child-two&#x27;:&#x27;child-one&#x27;;        &#125;    &#125;  &#125;);\nCSS动画效果是通过在某一时间上自动往标签上增加一些样式实现的\n//过渡效果&lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;&lt;/style&gt;//弹跳效果&lt;style&gt;        @keyframes bounce-in &#123;            0%&#123;                transform:scale(0);            &#125;            50%&#123;                transform:scale(1.5);            &#125;            100%&#123;                transform:scale(1);            &#125;        &#125;        .v-enter-active&#123;            transform-origin: left center;            animation: bounce-in 1s;        &#125;        .v-leave-active&#123;            transform-origin: left center;            animation: bounce-in 1s reverse;        &#125;&lt;/style&gt;&lt;transition&gt;    &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;&lt;/transition&gt;    &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;//配合使用css动画库&lt;link    rel=&quot;stylesheet&quot;    href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot;    /&gt;    &lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;    &lt;/style&gt;&lt;div id=&quot;app&quot;&gt;        &lt;transition         type=&quot;transition&quot;        //这里可以自定义入场和出场动画时长        :duration=&quot;&#123;enter:5000,leave:10000&#125;&quot;        appear        enter-active-class=&quot;animate__animated animate__swing v-enter-active&quot;        leave-active-class=&quot;animate__animated animate__flip v-leave-active&quot;        appear-active-class=&quot;animate__animated animate__flash&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;//jS动画&lt;div id=&quot;app&quot;&gt;        &lt;transition             @before-enter=&quot;handleBeforeEnter&quot;            @enter=&quot;handleEnter&quot;            @after-enter=&quot;handleAfterEnter&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt; var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        show:true    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.show=!this.show;        &#125;,        handleBeforeEnter:function(el)&#123;            el.style.color=&#x27;red&#x27;        &#125;,        handleEnter:function(el,done)&#123;            setTimeout(()=&gt;&#123;                el.style.color=&#x27;green&#x27;            &#125;,2000)            setTimeout(()=&gt;&#123;                done()            &#125;,4000)        &#125;,        handleAfterEnter:function(el)&#123;            el.style.color=&#x27;blue&#x27;;        &#125;    &#125;  &#125;);//velocity库handleEnter:function(el,done)&#123;            Velocity(el,&#123;opacity:1&#125;,&#123;duration:1000,complete:done&#125;)        &#125;,\n\n动画封装\nVue3\n指令语法\n数组变更方法push()pop()shift()unshift()splice()sort()reverse()非变更方法filter(), concat(), slice()reverse()和sort()调用之前创建一个原数组的副本\n事件处理内敛事件 方法事件\n生命周期不要用箭头函数，否则无法用this访问组件实例\nwatch侦听器\n路由动态路由匹配 :传递routes:{}里面的的路由地址可以有相对路径，可以嵌套子路径\\&lt;/router-link>里面必须是绝对路径$router.push(“”)JS实现页面跳转 ?传递使用命名路由跳转的时候注意要用v-bind:to=”{name:’’,params:{}}”\n组件注意data是一个函数要返回return，组件之间不共享\n\n问题axios发送post请求会405\nbind()方法主要是可以改变原本函数的this指向\nref用法this.$ref.取到的是dom元素/组件实例\n开发注意小知识点\n\\传参是v-bind:to:to=”{path:’/root’,query:{id:value}}”\nv-bind:class以键值对的形式绑定操作\nimporthttps://blog.csdn.net/qq_40323256/article/details/101867706注意export导出的引入要{}，export default不需要\n\n前后端分离问题汇总完整逻辑https://blog.csdn.net/qq_42345108/article/details/108249173\n\nelement UI表单 验证https://blog.csdn.net/qq_41008567/article/details/115939951\naxioshttps://www.axios-http.cn/docs/intro请求/响应前进行拦截拦截器逻辑顺序\n在vue.config.js里定义devServer的代理服务器和api前缀指向\n然后定义utils文件夹里的request.js，在该文件里引入axios，创建axios对象和要访问的URL即前面定义的API前缀，然后定义请求和响应拦截器，最后export定义的request对象\n在apis文件夹里引入定义好的request对象，开始编写具体的request函数，包括后台接口的url，http协议方法，传递的参数\n在vue视图里引入apis里的request函数并调用，注意调用后的返回值这里同样可以直接在vue组件里面使用类似下方结构来调用\n\n\n\naxios.post(&quot;/users/payMent&quot;,&#123;                addressId:addressId,                orderTotal:this.orderTotal              &#125;).then((response)=&gt;&#123;                  let res = response.data;                  if(res.status==&quot;0&quot;)&#123;                      this.$router.push(&#123;                          path:&#x27;/orderSuccess?orderId=&#x27;+res.result.orderId                      &#125;)                  &#125;              &#125;)\nget请求参数不同posthttps://zhuanlan.zhihu.com/p/275695831\n\nvuex状态管理模式解构简写\n\nimport &#123; mapState &#125; from &#x27;vuex&#x27;computed:&#123;  ...mapState([&#x27;nickName&#x27;,&#x27;cartCount&#x27;])&#125;,\n\nstate唯一数据源，单一状态树computed里面定义this.$store.state.\ngetter可以派生出一些新的状态可以直接在state数据上包装而不用重新定义数据，类似数据库里视图的概念this.$store.state.getters\nmutation更改state的唯一方法是提交mutationthis.$store.commit()\naction提交的是mutation，而不是直接变更状态可以异步操作调用this.$store.dispatch(“f”)定义f(a){a.commit()}\nmodule将多个store对象分割成模块\n\n\nthisthis对象问题https://juejin.cn/post/7109889547537743886this.$https://segmentfault.com/a/1190000040894587\n\nvue插件extend和component类似https://juejin.cn/post/7239715295484821565\n\nwebpackhttps://cloud.tencent.com/developer/article/1797938\n\n跨域问题\n\n\necharts实战vue3部分问题解决方案\nvscode插件加载不全，重载几遍就好了\n./APP.vue找不到https://blog.csdn.net/XSL_HR/article/details/128437240\nrouter-view不渲染由于没有后端支持，创建路由的history部分要用hashhttps://blog.csdn.net/weixin_43575792/article/details/122655356\n基本都是围绕setup里面响应式数据声明出的问题ref和reactivereactive对象赋值是深拷贝地址会变化，如果不是每个内部属性挨个赋值响应式对象，整体对象就会失去响应性，reactive返回的是对原始对象的引用，使用toRefs来解构toRef是将对象的属性转化为ref对象，浅拷贝，跟原本对象的属性对应地址引用是同一个，可以修改\nvuex和vue-router部分有了更新\n\n","categories":["技术学习"],"tags":["前端","Vue.js","vue2","vue3"]},{"title":"一战腾讯面经","url":"/2024/03/06/%E4%B8%80%E6%88%98%E8%85%BE%E8%AE%AF/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e605826219ca03ec7a232d33371b59f5a33eb0185a109abf0b933d9eea08fba01a1768937410ac4115234896675b8ed452e6e0c3b3d8879d3ebef46b0d798aa0375faf3b1fb5b89c4c82a7ba00ddc5acca93ab47e3a08e26d270fd666777ba6e097b779651c81eeb58bdaeb13cd78d6ab60844ee6ecc336e37a64d13ff42f21271eb2f2d1f813d9bc49ca58c2cdd52b44ac4b82a2e7910e234306fc34b5c224b5846b94119540d8515e457a0956f44352c32b9a6b1257b8e33875bcaec3eed7f80d1eabaaab1e8125c68aa01becc0b9749c06e1c1e40f786b1899fc9c43fc4b8a6fd89e5ce073d27ba4750438a2f286b020977e0634f3943379600960f244114f306094796f35c2b0075932226796073233fb5bf25764c9ae57d4d7e52cc668d6c0bbf4fa6074da7fb2f34590a456b4c3069fb8495e3487a1784ec4c9c9d4c18879ca7b8dfcf481cc82550384a24325c2b2177582ee48912dd02f3b0c22eee7857a3198e8adcf89847e273fd9cce4b2c921b165c26b0d1a9315b2a5eed8a791047873d7ba9fae14a4e469e53444669047913fc1ea766e88e06ad2275decc565dd976981b6b02439ca7c3b5c6848c2a578305128be6e97193da8b97e417ffb09dbf1756d40de8a92cc52b5e05667dec2a2eda3db5683c6385d1f2ba254efb424a3d557d8ccb2a48b7630808023032cd3b2effe452369c475638b66fd1c9d69b59933494458544a7182999545fe3b29838fe91ae84788b3db3e67b511e9aeeb35ecb65fb650bd7c5ea2d1719a3fb2fb927dec4060a345344663da2fc60aebc96ca0c1cf214baa93ae36e49470bf835cac3e854fa0738f8f0053f20b92200636fb0ff7637e82070d5dffda905499155b897bb4d270d746f5d19689d3575996ad60e675ff92d29fca2bd3d35dc953258387d780e917f487981e2f4c2d37cc3e134e208851b7bea395f8d0f34fdb80f0e543b389ead141886514a957446635f6efb4eb17cf803cb2f9596d8199f386df2f00c00b011829a6f092d25da2478e8da9e4332e1c12ace51a49186fbc02abb1cca7a64b5a0f32d4a585c80d265f31777f3f61e98f4f0996d397dbe3779b808f4d0e0d285ac5ff129c74d7baa7c26756bbba0e306401745ed155cdfa37fc1b68c8d824a93c6d82d4da8a3a17fa745c23d4927a0edf29b08d57eb3db1d21262d3d12cb4dca898af4da056dfe0cc84efa075e3ea2fc453a7a71add9afcb14adea69ca0574ab96d9522b54303f79616b833338b0af62afbb997ba66795719dd5c9ba483c9141fcf39d4ebc0194c0aeea4e92d1d4564f0adf83723a24dbbb3f78482cacb62867495f0e5b47218f9fd66576d12232d50e83363ff9ea39deced697ebf5bb8f798225367b4171ca96e17acbaed6bd6660552d216b4bd74937e4f15b8f5a3086f166ca7410fe13d704fb03e5d0df923b163e983c594a6f2e66058b5884d6d1c71389965f74c3c4fc0f9bfe916166515bde37c12dbca4af486a9ef936542742d008f8c6f56c907408bd05e52335d9b7b6b1faca82f33cb982f7319b0857f2b8e63336d86a5d671ca510cbc3ff440e6b90a1b044871aca1be51f1b62bdebdc7712f41f96981b7127de222de0514a49808409e600cbc1f9aa6bd3001fac71d5694e01c6baccf52860da20b1f7c9c87de1d25286a5506ee2e668872a88f12e848e3b03dac9219ec2c14e73ebe2cb2f93148cfb73e6071e986d530857bd8552a5d6cd3313cb5281ceb4aa246204e91051c0c062d57dd658d01764bd95d3d2d3e7a1057bf44c4ba7ec9faa181c45c1d33ca89e55c835a3c22655f5a98a62e2aed1d7fabc476624542fa7d014cd74074dc8049e0b521d845b84fe53e9c27f0a4a237667b03c7da30009f1ceeb2e6eeb5c2a6d753c5ab8ecff32f6585f436d85677c6efe7593b7fe5a038096d476ab12123a5b72075da691bb3fd10b797fb6af67831122bfd400487f76873274f94758373382788453d46dc4ae033a75d473c81079e29d84913ff503f09577bb17cbff80653f8fa095dec8bf6b37f082d892cadf73ddb2ee59f1cd87bbbda18fbaee9a51cd2e9e07197add7a19335478615c52433b2485fdb0624d4f2cfff5ad3d1e965d9558ac5b5937b0b781bb67b010bb89e4fb164bfcbd6688364695c9c4da12a8e39b3a5e5865aa848a97039c2c7d41e6981d1faa515cd682107c040d6461eb279014b0b15031beed9b68d16c74898ae2685e3f67a05e0a57f7a070c2f2b35fdd5e8c9eafa336e90081e804f49ff67c59174d584b8882a7bf3060383faec1d9fd429c3ffb81734537a2eae1661fff6ab3dbf3b5b53be453750284da08b43f00def01bad289fdb942c433238529488c55e00d856100f623e4ce0e946cf5e687315653655c2cae876189fa0ad02cfbbd000021a8778384fd27b7935a9e63f4e2c7b19b097d46f654b8eabd6fd685197fb193a185083a72ffc7d24c7a9833e5e1f6213c10848f90e84b027bf9b7f325951ec00ed990c331463fbcc8b7dcad59e1f07d6367656b082db8c33fa1edffa6e55f51f99d3a0d2139f4f1af1eaa570c49dcf99305e65f3f24c20e2f240d85c1585525d2527cb8da233a99d91cd4715bea886d83223fcaaae1a60a26a9826d68380aa4ec6b55fdbdce05390278c6b03014b19af6d4657ebb4e0dab7ccc8449584558eacad43d4b928b480ef5495a0e2f48fd9fb2353430d246d828506104cdc11be81b29253bf90ce7415bcf4e794ac6504f06ea0b4480f09040c8f6bbb4421abe5a7211e7f0bc0fa9caee13c51db448536d902f654c5fa5c403c83bac0287e0f5a0fc12d9cd9dd26f117cfa5ee01895d57d37cd8199447709d6a1ab5d6d16cf6690671852a99587f0da10631826b573a43912ab626be32c727a779cde5cabaeb497e81c98ecb78049a3c18d6a65758741e1f661632aae9d4b09f76051c41afb7bc554a0ae0538ab4e07383bfdc9355aa578562984395b3c23cdea9f04a4854ea7bd913664c0bd556ff5579d56557caa3bf5db68c530205e09d73a8fd9bb5a0978a5fee4f7317ce960f1ff6f4071fa76604f11d9424f3835109d9deb430cce40a7a05fd6ee1113cd5fb2db1d9b7afd6766416a3adb409d1f72e5571cf32293af7bb5cb83057efac0aa40369c23d62b3891453dd3ba7edb486f14fb8ec63431e18ec9785ce86cf08b48df10e9124807ad50c7c459098b85a1b93fd9ecce57a85d61ecf168f168474ee1636b783af3ce09bff74ff933cb8ca0b7f1db68e57fd4ec1b4fee00a5f4c38b134d1de3f50952903f6453cd7b85fa468a2ad5653c9fe615918859bbb0fd2e74312c1c087cadd7a12b815d3574d0bb0c0beadec754ea7cef5e7560a40378cfa69447299e05b4e22f273cc274f6e7e5c48847b50b6f57414af8655836056176243e9ccc980d4484dd074fd58dd33ff34cd8ca37b76cb43625bdd47d47fe92dbbaaa3adfb259151f72878c4baed5c5d594ba0ff2312f311bafd979ed2e3f0b9d961533afea0d537697659602f22dcba82370fbbb0a0c2aea75c680263f5cf044ea08ec7274245e810ae0e588375273e8f20e384c0f1039e9e711ed28de2f89f0cbb0a1af8919fbe47dfdd3782c7866d52960b207dd9b4d78a60594bf390475592281431d3dc465d6f1e27d8a7ff67644977ba9595d9ad5e4ea7eece894ccc248849cd751d63db7e427943fcbd16bc2db9ef2168d531e4947205d0cde3a851965f7c4fba691a536830b59493f2862e99f74b69d120d31971f38a37bd4a725d8f597c07faa0b70854b9c4f218bb2b68636e305e751618e98985fb19e1a5b6d493e4528070254830efaa7135402bd9ae8ba82d04da40bf40c54ac955a78f3b83954e660068bfda75ac2466ca0c913278f02534c43ea748d2b16efe080c3cc32c3a2a80f1108fa50087b1f2d928db3f41d14903328cd4799ac3c603fd076ae04e78fb03679cb628a4c48b5cc29754b1999980bd1582468c328a947f0451a00252fdcacb55603d1efd9bf2b7d0aa659bd90c2b29a5e3115df46f2d034535c8059e4203778e44d713b15abac6f5a50af3c7ae02b49de9fcc135d26ae72bd34cc1d6da28923ca7ae1f05197d549d47a6aa1fb7b589a0b6ac45fcf037ec0f160bcfe0d2e5ca2f92c0b974a83db981354a867862fe6c413a6e83425112492ad99d83141d028d9469322c86e7b34ff3c8b5fb8a76ffe5475735e1622797f461baebbe8629a265b1f2baed0913ec037a0d2ceb7f3668da4758b944ff1e5d601e3dce72454ff0c24d9c2774c7a08ebc9c270229537988ff64d2e818de2195aa913f35b276d0bfe5cf6c1afc35ac9f8f0a95ba4fb1d6b7a3badfe2e913971e66ce4025825ffeaaa673c15ef3cf89477d6552cf00c5c621831d25a70217b125699b3568f9eb60ae7368c2cb6f6acd4f158baa87d04d7bb7b6ac3acf9ce193228e35d9b0909670f21c03d75e85bea0ece1a357c6987517a95cf4aca5d87742830bed93aa4564ad485ed028623440cc34617b5e513345ac3db8a805bf9367fda3eaf71803d8c01bb4f5262498d5f57ab359aa961d557a9f24ecb81f5df5cfdf3a3b94be8a5a13c0dd7e56472dd9da17d81178d48ed2842dc16e10a73020b9445e906b6f7bd717fb651fa83175f4f081d441021c36dde80895ac452d1c1be5f1f803b74c29b91397adb0117028c58ab2521e6f36bc2cf1a85efb84b5f6a01209050478ea0de11dd6e9688f6ceb2b220cab6384adc1e677af72b75570660f8bf26edd1893b9ee49518e3017c9ef32f9c7ee6f8bbcaac49e774bdd834c456f2b07cd87696414806d5211c45fb19dde5d54200f92cec4a0bb213c8fafceb2641c8d2434c8618ac7e614bcab323c057324351386bd268f7a0da88d53e56002f7e4c4ea062105e13ea70937318758c06fac646b2a2e539ba3a4acaf574b0f8533d6bdc2c9708491ee2cb931bc92b9996e47838447fc9ba9d40a9707dcc29f969742e9290d8408a68989651369f4936d5c8d6262e0ad21e687aaddfd765821176d5b12c4e4dcda9e25dddcc5df1b7b5d56b614c4bcb3bce09f2fdf831d0f413e3b51444e62629936e9260dc49619d5a9f70b28b0d0aa66ba0a4260c3bbcdb54b390839fd938bd3ea3162f36a1abe8d14df503428e0062c31e6413e4aa5230bdf762946acf278a210d0767b3ebbf6c31355db6e9567f71db6f4394e91bbb1fec1bff3dbcbdfcfe67f6d9b28fac8b35cce3f332f04861e2aee1dfae688c3dd2f63a2aef6aa4818e5cbcffcf053895e15274ba80f60ec697a4d4184984da2a263e12afba10a02254b5db5e31b30b51494947c7e64e76a6f7a588b992e8b4eca38c53be2b4f242ee23382f2afbe902c0bcf72bc1fb574ffb72280021585ddff93f85594587f01ed26b3d14cb3b994c6ab599d39fa5d809dfb34864ede212bfff16c94bd0b09c2072ee9412ef0b89fb54c45bcd27ad3cf0bade4d9f345d6838c5482c66144f4c026212f4341e19f8d9362f143e6e3c283387b5cdaf6f2861aa9214f8c3234beecb48e9f3d1df52ea814fc9792ed54d2d3948ebed49d6645daea039ee7f427cc9066073dd293ef0a8f56f637f944023eccda525a39188c95eaacba8f25dab503fed1260bf746dda972d0e6cafe126a4cd946238d8f0197cda201fc2fa5f875a9985530325afa25be12d5d2fb228ac10aa744c8ce65030aac34c5d2520c28a877952cad262e6693a939c6101278f5688b0ae96d82b75212f1a2852c237c3a9ad8e91bd3aee8beaf871a35180dc1114eb544bf6434e245197f4ce65b14e27923ef4108bf6d4d75fa35fcf0883b3b4196a2f33362069d13329cd90343f6358210d993a67314e88f6adb9c6ece37178eb01e28c2f6282d3aeff62318a6c719660f540c9fe0c81eb070683c76e7560b8939b1228effbfcc1d461bf519d236e1321b51d11e7b34aa99956c7824318ab82f668e2a6f3ea040e219263a7b45b1f264ed72b884cb89e1642a298eb843d708655705c6d2bd1ca35c51b436d87640845f604758301e0ea7914faeea0c4723b010efba48b56a77c4ccc025d1076de4851e496689141f29d637ba48dada7f1b2b975b60e521327f790b1415498fb26c7759d3659bac7f18ff2de9a20b4eea6f0680c6268883527aae51a574d59e1d90070851574a06211b65894c7c5eaa0ae655483862d6b355ec273016085d4438d44f7b4981ad464f26baeeb247522fcad037250c5b14b19a3d304bcae12876bf9144c0d193c2bd0db2fc5f236125562959ae116fdfb73761a953bb3e4fe29fee41e6ed8e5b5c8f9af5c5aa9974bc1ffd360174950229d5a078ae7f59ae8731e7ddd4644137182fdaa16f84c5c08d9745684db2b956393533e9fc2fa5f121b8e37b3358a3a5dcefc9bc0c77001adbed02b247d7889c0be063030bea7298e35c1f26d69c2b04e04191a4efe49e32f5030a81a0bc94960aeacb0f240551ffef66ecbd7\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"三战腾讯面经","url":"/2024/04/03/%E4%B8%89%E6%88%98%E8%85%BE%E8%AE%AF/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e605826219ca03ec7a232d33371b59f5a33eb0185a109abf0b933d9eea08fba01a1768937410ac4115234896675b8ed452e6e0c3b3d8879d3ebef46b0d798aa0375faf3b1fb5b89c4c82a7ba00ddc5acca93ab47e3a08e26d270fd666777ba6e097b779651c81eeb58bdaeb13cd78d6ab60844ee6ecc336e37a64d13ff42f21271eb2f2d1f813d9bc49ca58c2cdd52b44ac4b82a2e7910e234306fc34b5c224b5846b94119540d8515e457a0956f44352c32b9a6b1257b8e33875bcaec3eed7f80d1eabaaab1e8125c68aa01becc0b9749c06e1c1e40f786b1899fc9c43fc4b8a6fd89e5ce2bc68235ac7a4cbec7052efa8cbee1f375751f6dd079ddd9efd430478be3a480845e39c33a6375d13e5e89ca9fc2459dcdd0a83dc57fc210cfd09add0564b311ace348fe5d014363407bdc51db2fdd39484a5313d1de85b905b8b838605a48134120728bce4ed312fb514611f50c608435d15fb52803fd5b3710c4254930a928ae0e35a88fff28a300af1d6b6fff98be62191c9f3b2b075778b566b4ba331e5aff01e5083b4d36e66b24e6f95d6d4b97aa713ca5e7f56c9e15f321292527a902ef265440fb4fe58ea6cf793f1a55c5f95e0e1270c807f8083a41a71c6804c63e951372dc8d53c2744758307a426b481191d5c25eba8758e970b98d31bb78a08a4893085e42c4994718b13f2287c77645425cf47baae9d0f142f0051a91ba504ab144328294875dc5aed46bbcecc52de10a4a236cf2fee7a3cc01d022bdb6031b254ccc0ff4e900e0f3b3d0615c5a4b7c223ae1fee33dab4217625e65a7794ac220930e03458d256859b9b58dc1079ea364325b4266c8767fd0495aa651b3c1c20174cdf4b8b77b33360db6aa90e7f127322006f2e93052708d4aed256203286ac9d7dd847b99fb1da5dcc4899968ef0a0bd81621d35ac90c222347f603517211c765f770a5e855941a74db1f1f2f90c3f11a83926e37ac6fd5280cbabb2a7ea1b3115af522d02f5d67450b116ae761a3c69e02b4f75f58208e7afdeac556132643c5c9f88879315256eac4c6cccca8a8101ec04c88af5ea6db2d0987964670bfd1bc38d8ceee516d278b5128a1739efefe5c723c91102e3c1f86da9e1a885a85931787ccd0957ac4cfb3cc39db6c013ed0c767e8d557525b4b9e8c9c2fbe60fa85a8fe494bdc4afecf1b4eb4c0f72e86ab59be4c78e9a2e341a3698d88740aa78d72d7dca753401fafd4edc128deabd8cb8b3875b0dbe8459dc5a51eb45ef56b8ab8f80c9c04f55c4fed21b8d1878c05065502465089f1c68b76d15de2cef8b9487c9a397c884a600b4bedccddcef9f9585a358056a3be1adb6e988e17e976c6\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"二战腾讯面经","url":"/2024/03/07/%E4%BA%8C%E6%88%98%E8%85%BE%E8%AE%AF/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e605826219ca03ec7a232d33371b59f5a33eb0185a109abf0b933d9eea08fba01a1768937410ac4115234896675b8ed452e6e0c3b3d8879d3ebef46b0d798aa0375faf3b1fb5b89c4c82a7ba00ddc5acca93ab47e3a08e26d270fd666777ba6e097b779651c81eeb58bdaeb13cd78d6ab60844ee6ecc336e37a64d13ff42f21271eb2f2d1f813d9bc49ca58c2cdd52b44ac4b82a2e7910e234306fc34b5c224b5846b94119540d8515e457a0956f44352c32b9a6b1257b8e33875bcaec3eed7f80d1eabaaab1e8125c68aa01becc0b9749c06e1c1e40f786b1899fc9c43fc4b8a6fd89e5ceee5e3763ad03d562db9dffada4b7968ea3a6cac9303b85dd0b794ddab6adfef6a7ddde080d581d0f97eb5d672e46a937e0f50fc0c55ef50abd980c1b6c08d71e9ada54d29b3dc0bda84bf2d7c261ed2e509acc90b99cd4700e71413e1b017e107e27fe5598e9f27a37552fdf8a5cf1c2c8dd8784c5aaba1cb68a4131b7b9c631894a7c2a198953ae6fe8c3eafd3ce96f381ea9ca0c50363ebd6966929bd658b247f3557aa08d46982f2ff16adaad73fa23ef10fc068f4459101fa1c39e841914bf4de22665c875f8816bf4323abc812fc6022404bb2aada583f2400dca9ec9adbaadc21ff926de38eb1725cdf27d0ddd7d87978171fdd743dc5e02dfdecbfdaabd597168dd4e39e3ef206aad2f16217d932c67bceeb6a63a1bb3a389fd13c5f7b5948c4448c018ae63cb12aa6ff80fb699a05ad10c8cbeee231996787bbebfc46a1271a9ff6eaae1071d0a825f4f746ad21a2c8f8f0393d8776a3fdf014bec2c8d87788d3ce6214f43ecf23d9bcb80dc403f21b58adfb04a123d107c9d7eb31db10a5eb7461ea043774006c98bc44163d5777234805050187ff3887d3b5e92b0bf6f933217ce1b0e434df226100fbfe2f1c3994171966ea42e655473b5a75592f7bedf930ed4f5485a2be9b67f0dc788164409a58acdbc9b91a4a954641ec1b23cadb374b13110c52fd0c5822f77de8079758f4cf0cba73c0b358f79aee145d973dc5f82e624e9be29b0adfe03ad70012467e584f65dfd2a43004aae0cb444aec5b228c5ef0cc224cd1420dffca43f36f687f82671b864b4865fb6fc197595aff417d52f4c88e39859f18208c805e4bd888e7ad80f538cca5f869008a948c30d3b0b35ca93321233a439fc8ac49b0fe473f5d688df61c14533ec7aa7f0a57a9088a6e747c01670030a244f0f3aa871a3c994551ae4bd8422378b555fb626510a3c38273798f2540c558aa9277ed7930ccd27efe1975a623aecc8917ba17e9e8dd30479b1fbaa85a2ae1adc976a1bbb30c9c2c1dd441f217a596bdf293db08473185bb59eede4690bcee155a45a94cb66bb0563ed85f931fd780242ffd0c48e05958ad1c68f865d289ed099441e72f5eb4fb287d041ba993d9cb69c543fa8cf7d5abc12247eb134d22e8bce73cc4d1ab8a47ff81160b27d10e63335d05036fcce2589e880a63ba26c68de0f74048171a37fc75bf5d9ceee2e09183300ffcb028f52672b3c210c81bff526d466a5a1ef99310a5d8a268fcd648004486f12e85051845cfa87ed33284b34176721eb42c350474b971b024f3855ae6ad738efd65b4039dc3f59da35be9e2cd1ecf790fde21f2f82db7bbb17bbf28bd2a19c673177afc8f31f660c3ec5a775cc1551618e79fc50eb16e236fd2f4915bffc0059f734342183023f63cc95dfe3a83d049681c4a15a12195af647a3cfaee8d76d4bb5fb66b1282e533d1587f80f7a998fd317395ddb89c578c19f41639c7675aeb89d3e0119e0eb68b74531f1e23031e5760eb738313d6771d0c61a67ca93ace9d79856c1a4c308c4fbbffbae1cb6f3ffef93a53ed632c3cae75f592c5c936608029cf484d53734ee89554bee26a3639311ef0e7da4af142b902d75c7053afc81295989ff6b5c7466bc52514bbc1c5725cc24fbb3e7f80512b8119e9a0a81539a6009d0ae03f5831465d937b3f3ebaf461cd9f3e0e2f1ab6f55200df712353874021f9c45da64b0a72c71ce45bffc492567a433ec9bde3c7b3653e5f5bf3c5b8a82f9666828027ad3ba893c17b207e073c809d8353b8cd37ff9a91a14dd449293e196767446e6dca9d46b8ec9b376d01bc34a800af798605ae2371c49d0018f51f1672776e7c99bf2d15e7004702b6e75aeec8fbb8b25af4eda5c2eab78c47d0b9fb0287709995f2b6cec9d9bcdd3c0351e8500a92583ea1d16518c98147254fc6aebad2ce647f8763dba621ae1d3a4ec30fa278a6a33ef99adfa3970baab5610b8fd5765a262f5e0a68d335d0665788fae84e819e03c8d43ec72eac3977e4cd82034ec26310484e4fda64368a33ed0b871a8b5ae5900865a41f25c7c7d90f351769436ccab82a6b0254d843ad106decf66ea67fecea9d221c101c842f585e005d5f702531403b29056d45007d34a65fc9b748ee90ab3e4a0e0b30f96cb66b62f6f004c9252d893023373a9f50a475dd88d7b1845da18cb16eb6700c8b5b4d304844952b28619118149927f6afbcf83812788ba791ad3faee0121044c860789bfdf0bc82e1d54c85d40e767f999d724a1aa1bbe0217c150ab963d5a550483545210597e46ba6a81393c8b2d421bdd7f930b11b2bc49f879ea355e5dabaab4fe0eaef5227c57833cc7926e8904b3b1456c7aa83dab83bf3a556477a33711ea6ceb6c83f971fa4b36b2ea0f7609ffcadf8f2335af6afab96f491b941f1f7a20188653f16f3cd2a8f4166826e4f7063103632cc9b09a400e0a626aead31738847d3d4255bd888e68aa8ac2af192f80b08a44e82c0bc9873b942228b3606db1ebcec920a6c3a7a4d371f7490c1c86caf9542a7f8752b6484f1ec267b7375badaca05bc120055d7e5b26bb8238f9a2298d8043519bfbb74bc5a831d70a230ab65d2b4c636cff76d1f1fc6eabc83b92a45273421eb20bd9eda0383041d6384b7b4458812978e007d0ce3092ed42a2677b0b16934f82ceebf2ddd806b686eef8fadde562e6cee519d1c9e131e87d8873eb509378c4e0deb6f7ca441a3af5f952abbd398596e13887ce905698bb91e60716a2187e09658af18846f3ddc251236ec76821f02bcbeacc56b01d913ce0f811f456c2374ff70f7b4accb567a82d27d49281a8084dfefb1f20efc520bb48103cf6fe8a0cc155b1f090e020ee4f64ea076f0982916a39e95d9cbb94741f1264e534c4c9a0193f6df9a7518690839a7f10e5f9d8d21d0f696986c5d1e8c0567d7fe045c539e63498e6155791e283d6be5e858d81fa392f1b5549ba94eb3818fec53809d44e67dc1e2912a783eb02ae26b86dd7dc7ff14d4faefbb5ececee718a96bb914572f16b709a0529c93471580084409311cc4549702281ca1edc1e9e3f436c2aa4c39a6641cbbbc6264bf1b3b2bff15666a16baf4da45b83d188959efaebe5d9ef314da633a491e0d22ee37768ef67d8d5364510f62df6119ab463fb05b10810a328c9227fba7b7529f0da22fbdbf931bd49b5bdd142e10fd0c2cc8c702f3d84d5c401afebd283c24342f606e66fc37f789f0bd6553e091b6b32345fe6775c4fceac3a9ba291c3a0c2ddf319ccacac861d37b8077d199c9d85741cc62caa6cb52b9aeb9a4493fc2816502d093c118881b3511137e37a9fb2a87beaa2a0c512df909f6ddb97f101ea0424bf1ab00337ea8cb508fda151554ec535ba4729419838ecc5b2157d873ec68b2c5ada6b056fafd89b389e9af611c8f443d6825db61d05b6359581b49fe6d79afe0ac8e11125601a750a14186866bd719619e88b70b773d902a4661d769ff34199ed2de41540243e0428761193b63e59ecaa17106d44a0c1bde933c2bc5d3bd602ab5969818aed79c7801899b586abaf5193b3133fe0992efc139cfcdb8beaaa75533a70d38d7fb417e91fc1b8f765ee0e7182ced54ce00d76163af946b3461eb14c0301542a43ca7ac81d59bd45bf8cc7e5bc99d90a2c381ca9b7afd4a6e8ff4c2af63660dbfdcc1e9a15f0a1dfcae792d7448ec76d29c30b070e3faa55f8ab40ca02084f12943c7f40ec9160f90ece18970c17d8b34fb39497b1ab60df3a8f3c6d7a086f337e9f30c148ef5aaa103cdf7d591727b2374ddd74fed1267dc46b8576d350aec4c05f390bc007efe79435d794304a669f950351fb1d82bb41e61a6e2b72325486d974453588bdf4eb4311cb5ec885ad9a92861925cfccd5f868b6692b799d72da0e65ba32b2f05fcec928056c5e1fcfac7381378dc2e2b53a613b4de42a3a1efa2bb7b3235e3604ad074b34394c4ec969d6f303bb07690574180823fbb7bcd23edde7543424a90a4122c953d2fea8ea9836b6f67df4f853a7de6822fbc39774d73c3224dac298ab75b69ad89c50952c6d097789fdf3b1e8e7a85214398156f37e6b2b9aa3c051491a4ace463f3f1d38d83a8c7949e4b1a29e78816b10160f25b7aec39e03baf0d13fd5a84b95eeb2559484458368be570c75634b38dea27e30ffdb252ac62117ab86a18d74f39164c6e2217e46010e7ea1c2d4da3461604e256d9ef5a67ac0995f585e9812fb8281815033e2c350987f6144af395343ad0fe18b828a3631a99f26e37133c61ccef25e9678de418853a752854ee3f6e7f5ea24d256f18fc3387e266b367c69b83db54dcac07aaa98ab18a7623f8818c935aed12c4cc1b1bb2d84157a3be62296a57063bf87e646864677c1e2bf2aab3ac93d446030009575a09b84c9042df3810d737fc3699a7d1ac7ce8689ad501708a9d09b12b75ac15b90ba1ca08a480e1b682fac075539a6a2f4be29f0a1a8f139736336375b5099c28ba62f57cac9e245bea46435baf61110f4cb16a250fc841f881321e9434ac23a3c959d1a97f97edd76c5d8f9e7328c128247c08ad067bec1780e8c885eb0a58344a2d393b480a1e27a7da56d2550e8a9d5242a1e19e40445ff5ae38e6217ecad6d1fc861855ed46fa2e8f87105c595343c0bcc893a244cd9a9044c5254b50e04ec463281361e7c56a94da1bd06f9c8b56872ae0d3a63f94092356f3f49583b07cd4be503f1eebff7b9d14cb9808ed2d30b07f39bceb9dec0dcf3fe3149869384b8594ad5bac008115abc0a6dfb55bdf8811636ceb70aca943390a56b52e9e2f207c033ab35c1d9782bca8f0e29287ca2ba652d7dd45bac7e3ed13e8dc1063a650fb7559e468e65fbe863745e48208b22a0cce87db371b7d46f2dd9bdd201e66471934082eef93883fe6152cdda239c0de779d07991ceff4c1cdde46401e92d7aa7f768fdc3b68633ba9fd5faa1d73932c58ac96698d01b7feb31079502c735869720e74f307bce7e955e185f92bf375051de7f451d8adad547e1b7be03bc9df1ae92b03da3709f53734f49d96262c1f74a4b3d81ce199f9a04adfd9ea00d057fd33f64828a3f86c52e6b062a52eca648b1779c3ae9107300c5319667d57f36c47635305417ff291154bdc24a3b992e68bf5deb44d722e373aade5e275e48ec1f618d22818445def94a3a8c3e2ab3fb9166dcf43e55b775dcbd026960820eb74eeb6b908d7b3fa0eda36e6303b0d04fed3a06663ae402ecdf6453439cef550f15b875eb1e5a061c8294e7c8fbc7669ae980b98f9d6c10945ca5f98b9a81735d87db7b4ee685343ab7adf62add5be826c95c98abb170506828c5947dca79353cef6fd45365c49252ffd39bd425ab30818b203eb373f6f0374098f5fe33414317a5bc2d8124cf656b127d8f7755ec6e2753f3fc3ae268a8615ea3e4258340cf9aa1d46e52cb8720df6cc1195d0c7ac29583c7631709b0d97f4e987f7eee589c64191d719027f76d2123d4404b1411c235d7269839a221a1038354c4b286236fcbf6777f948e2b5991d80515c92dc09020d82ed291bff6ac24506a70491c3140d170baa4dc51cb8393e958f8e559b0d907b302a2274562903f5f1c821e1934de174cc9d538310cd3ecc7873de355174722f0b5b92f0856ff55db413845996f72dcba275922cb95ee31fffa048fa3572595c52a406385bb89fe09e6fcfcb3f531825d55d73abef556ae3d70a5876977a80957e41c969fcc32cf561bdc97b6281677b36b97e2b4010c35097fe9d2208bf49307963a36582139e7b0194084d56486ab76a28f333788b0a0943df4f93b1b575ca9196e105065abea96b167d67fd1e18ef37050f990428a6f3188fbfa00484e4f45b4143fce73d56d5dca57e34d3263691655d3589681d4ddfb03153584be05efc6fb7f6c0ee6739b18f72f9354cb80b3e030799563c2f3f1095b99a72b920323d9e61f68d46ab2c293b5f32712033524128be03224f7e67240b85307ab79515cc66167c3ceefa453d9e7bf6dcc392896f22e6722f722ec06e8bfeba4010ce771ecd996af987796cfa35fa790a1ef1f69320a51326a102b2b3d60029f576a2f675e6adab3ca7faa59cd174932b6ba35c685619d2be81a7ae1d565d1318e733990bdfdc2d9a343b0beebad46b77935b887026162fffb09a6da02442354e6973811059d4d52911b34ff64c6d5cc73187522de69dd23854562a90b0c583afa357f915a47d6f480e06d9d6202a3903dedf60eaaa34213cc4780c366f7c7c66cbeb9b970dd4e5e2788400b4d5317cda7d4998a664039310b10d660bbf71398b99400c0310c143702be1d95097f3bdcab092d21f90f74179222cf2f43632aba70825cf33e8243f67b61b07d036a6af15ed117b832152c233b1d3bd91de13f29214523d3a6fefc5d67fd48b367966918ce6be2f5b0d2af6edb06a5566ccf705406780e33feab90b205650631458b9cae780c222d4de28c58bf3caa0e3a91530cce903448e7f512e135a6bf46ddb27b3d98e012e394dd976bc5aaf6f284389b47e4bfb9530dd9dd47eed4367249e34cb2a962f6e6208024cd1c0f6c184d9073987420cc6896c554a848629fd580580bf98e6aefd2fd4067381e6c2467a6342c1907d53338a756f010e197c4299b984195230a5e933517cd75562c0de07faa61e4f73c8146ea0c2529abd4e157a27a51cf3d87085f6b346e4e4cebc245a68d8bae24a6f4e3a1036ad2e00ffb016d104be2f1569cc079ffde4eaea0a63ba6a8cdf5152d8c8dbc7dac2fd3719f94a71ae4eb0e8b3856bd2b7c421faccc6bdcbff1526c3bca858877567501856afb1b458617ac8a9aafa88df76277d1df6d72e90733982d88961bafc12fda7ddb28ed0777cdc18e823ca38a75d41975e8aa0e97c5f440da1b8d28f016ca5807d563051022ee363fb3fe5ad4e4a224341d61a63e00a56f5a7bdddb909776542116e920d4f1543b815165285de6ab8e59e161a74c90f2ad3211817836a2147f32248dab93df3d5107aa6d81309277c308ac213e62b07ff4796f5a5ecb62d320d1a9dd95ef449316597ce5300906c18d3469d109e026c2e374f8a45a95f96d3678e06f4f13189e6bf8db25b4dc514e30606e3cae77d84727871130ac23694e5d49d4ff88e8a83c89bf44d364480b0dca1775683f0c51eb96bcc893227be7c9f9c404164187eda5aa46dd181c4516eceb9a21d2c433a715558b8f01596559182346778fdbce85863774290e81fb1f1ea266fa8e8bfd6d2371c3205fbcd3ff902a6d77c4c72054c5fbc8c7487ed11ce0dcb1055637e0cbfd0ed2382fca5f15faa51995228e3e03110dfea9b6568ec5b03e97f2714fa17aa873423769bf7eeef5bd1c198c3dea332162595617c1468bb4a9afdd1661d24228c7748d21cddbd1a371e2931c91a8874d33d28c5620a2253c0b448220229189ce7871aeef7f4c352c0ab34698767630f3b58b359f4e2c3a00f038cd6960481988c48daa6d69cd255ec1c66a3e016735a2fdc59be6073abc1b30d7fe2a13f2430af2c4b3f6825cd7db5aded9ddf64b2790a548c70595a49c0eae2d7aed62138353f9178ceb336a6a308670127ecd599d92962a617acdd4a306eac3b8da363cdf3f327848c886b88e5b2358e2880a596255f9ad61e0be0dc2d201d1a6dd32513fb8b538a271e25eb623ab1e5e0a1007d97a93dbd9815997f251c56b89ffd67e64b754bfdeed1684fa3f04d7682b508203861478158d08c49789c0e4d8a7887174fce32c38a6fd1e575aab2f210cf98487ca7b72caa526e9d3028ba88c8fae09ac78573abd0001961119b17ab89d7211c845260e9db7a5bedb9befaa9cbbffad8bb9102197a1ba4b541543c77f3bbae068651417134cbe4cf63a6152b1272cc873c36198ce8f728b99024bcd4b2937890fae9be972abb2ccbf3cea85bddee2afecbe708511acaafed4f8319e200ff86daebac6f57736d6a017d924414fecd360ef1cd7ee0454365230aea8e2e0c6d6c9b5e0ce58c2fe382098ea65efdc6ffbc3bf0fa79189d1993f4b4eafeaeea6ff463d6446a7bbaa317df2a070711ff5eb9e860b5fd815dbbed67b0c75ffafb29f8bffbf747367d741cf1f35ea11e7a1a511da3e143dab4576a54604ec7ba1f91db6f56cc237be1a99eb7217c1e0da09ff957ee48f2e50a5ccbc6e5c403cdeff7bbf0df9cd102200f203d0a331fc86f7dc43187678afc7ee548cdd4412c6537f074e6f90b169c37bc0597636cdd6482343f665244b4db5974b2b2a38de3f3246ea6afb4d3cd28b5f9377174d431710b794239f4beebd1cd27740c05b8a9f311558858420e6eafbacb31c291e0ae6cfb46bcee2814baba2ca06db122d0154a2353b12902fb23ec7e9d2b3ea87297c56324b9a9ccd337479cbbe9654fc24f14e52cb2a0549103272a7853f6e1fbaf28c8a854de2d1dcb015a8b3a4ca27fbd62461f44cc049c4f830b3cf1a9eccd5d04aa075b67a8c4704143a1b6e08635df56d25b86a9c8e5ed412d0720c234594f2b3399f16ab46f9f7285f2cff0a4f9e3d7af0f643d6f8a86874b90cc9ee7e3a425243346e8b1ddd38edf2aeb88d4584a1e627f50377a5eed22aac53e1390e5a0b2ec6b3e554d9892b2f4630de7f2b5484a05d4bfc093e1b1075afb9079796dec6b454aabe68b50e231dd655876455eb3ab800d7044d6044432919d2f33c2d69ff1196718fb00c8e33cea959dd8a4546d4d652bdb4ce3ccb64ed128f355fe2abeafed2919ca414177396795931d7b6590dc35abb6d32418369efaa99bac76e1a6e451c2bcf6987241ee7ea80e1617aaf564c31b139aec1820be47381f0856e937ab379f2f82b5a273e52bfab0bd9bbc1b5af5225449a2c80efad607d2f763cece2120c0f6156cf8f3fc46736c4c19b76493f30412740d4be913aab06b89e1db1c557d1f03d356451ed910e3d8d3224989cef7cd2a23d9c24a575be9ee03ec59aa4a64dbc3e2ede8e87cfe9bea27733ac434d27d388f71a204291db6cef49ed2b5aca2b200ceb663452b8dc6932ea5b273341ffbc844b55391c736b385065d3ac6559f2fae80c3576b29b8e87f0c82ae2cb30d537f690570db5916c13cebecbf65babd050ccae071f7ac852046092edafb2b099e343132914fe6169577dd9b36a21e273a01ea380a9478893caacfdb8163ff75670e67444d2be8c799dd02450b9bb193d95a8bac708792f8e5c24c35bf16d4ceba1a8c9ff0fe913f0a4f4af9c4b0a31e3e5d88c5fec0017aa6abb1bd9be0dbf01c0a707d092de59d3ffd1b740c2e689d761833a1ce6853735191e53a916facbf5335eaaa89cc1d2dde91a0bc909bf14e2892a1da0cb26138d91ada458c0f852073cdd418fb3f59045d96f20f0d917a347c9ef9bc06dbdbc45514adbb36d89c1a26d068f6213855367e5059e396a6f82e463042edccd954a19520380bfaeaa51734e773b637ec0404da8633799273cd2d863362fbd27d501d99d23d3048d6c3208d856cce3000ecc84f86353c3de3bb83f56330216ae4bce190537b1ebcfbc9fc2188a4af7cbf21f72c9061bd42d5f89642f6d127ed81c1f0586b6e52145957f61fb9836e47434c2d06d6d5b3558bdea2b8584232cf34e5719f1222d24af763897353175eee69315ce4f4b6fbb909383cec04ee8e3ff20a0fb78d6fc7e42309ba6831ba6979b096595bcabbb5d5c849fc6dec892e21a1325e4af6e47242a78a7d64de7897d2cc19acb1e8c778ec4402fce4154f79496b9205187fc28941145702c01cb2bccb393c32d9bbbbbd4c39dc787b673488ef5deead81b7b02194fe522448de45c4c9f35076f512c5124a0b009d778c2419d86e0b6836dc0bcc5a5b883e2313fb404553e4c3b1fcafa1c7837c91848981712dcd56969c1461271ba97fc9850d358e238d060c29d26ea6b548a251886c9929908288556eb2803fb13a8f9c5bacab1171d9cff034424455f16af7e1cc5b87530863f1e8f2d8918a9228b36c5a785d5ca54f6a1f52c60630acddf48e445ae3988c8e2130f888f8b9a1c836a206ea6143c1f1e70778d735d94f4960a0f8919c7e8469d46a18304484c3864614fd7cf6b3abdca1c9a2bfe932853e4703fd1e50686271d7420cbd4b13a8910137caa4637ccc62b157509944f8d23c47673d93eaed7415cb17a472c989453c51ac92e7247fb253321cc8498eca803f934bdddabfbcddd5b22c353a3fb20d7d44b19a817bac88f92e373b8fb05cbd62c1495734ad286aa87e89aaf9732996effcbf5e9e76eebeec8fb004b6831ce65b48749720b17f1c9bb9064348b135d42555e927716d6ca78646a8d05627d56506411bf0d45f7fe77bc4d7e7dcfa822519d16c62ea19996df06d395b167269397c280bade6ff493c7add05d9d875afcb110e2a7188f020556d0fac5980a16eb2b6e0b1a31c89e7e48846b9f704524aa8989105e19564a2f10a3ef436ce3bd9fa51ed5507f96a4d2329ac4b6235a597a297e66cf89cfcd1989a20844c75558238a9a2ecb441530f5703452d6ae379615939194db2e36c19ae55a82b86c4f82e9e8ac3689b206847c213d67393e459122f73302bc2f7c0916b243b69c7ed10ce406211b4d29a8e14e1cdaa2fcf4b0f52bb39408a80dc7fa4057ab641bce4c6640f5feae644a9acff86207f27e3d448a84bfb965dc19e37c2bb88382adca45a59484f74e613e60414021b78eae02516da909a2fd8e9c561bbca1affb27a46818f4b162a62a2e970feb5e88eba0b764814ef58b68771c5b72f944379f43c55e580956b3a278117bce7a8c68d9d6d77fa61d5d272f3e7adb8d2e50dd9ad580b3702009b0e71822a71c6c445022e977a25cd2\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"前端面试知识点汇总","url":"/2024/03/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"记录了我自己准备前端面试时复习的内容\n参考了 https://vue3js.cn/interview/\nHTML CSSJavaScript\n回调函数嵌套 函数体在完成某种操作后由内向外调用某个外部函数函数作为参数传递给另外一个函数回调地狱回调函数是一个this对象的方法时，必须保证this对象的上下文，Call和Apply函数来保存this\n\nES6\nvar let const作用域. 变量提升. 重复声明. 暂时性死区\n数组新增\n… 数组变成参数序列浅拷贝 解构赋值 参数最后一位 iterator对象转成数组\n构造函数 Array.from() Array.of()\n实例对象方法copyWithin() 复制覆盖find(). findIndex() 查找fill() 填充entries()，keys()，values() 遍历includes() 判断是否包含flat()，flatMap() 扁平化（层数）\n\n\n对象新增\n简写\n属性名表达式\nsuper指向当前对象的原型对象\n扩展运算符 解构赋值 浅拷贝\n属性遍历 数值键-&gt;字符串键-&gt;symbol键for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n方法Object.is() 严格相等 +0不等于-0，NaN等于自身Object.assign() 对象合并 浅拷贝替换Object.getOwnPropertyDescriptors()Object.setPrototypeOf()，Object.getPrototypeOf()Object.keys()，Object.values()，Object.entries()Object.fromEntries()\n\n\n函数新增\n参数 尾参数\nlength name\n箭头函数 参数=&gt;返回值\n\n\nSet Map\nSetadd() delete() has() clear()keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员数组字符串去重filter 并集交集差集\nMapset() get() has() delete() clear()keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回所有成员的遍历器forEach()：遍历 Map 的所有成员weak没有遍历属性\n\n\npromisePromise(function(resolve, reject) {})then()catch()finally()Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\ngeneratorfunction关键字与函数名之间有一个星号函数体内部使用yield表达式，定义不同的内部状态通过next方法才会遍历，直到一个yield表达式暂停，返回值是yield表达式的值，下一次next方法继续，直到returnnext可以带一个参数，当做一个yield表达式的返回值返回的是Iterator对象，可以通过for…of进行遍历\n异步处理回调函数Promise 对象generator 函数 可以控制迭代async/await 本质上generator\nproxy用于创建一个对象的代理，从而实现基本操作的拦截和自定义var proxy = new Proxy(target, handler)Reflect 的所有属性和方法都是静态的（ Math 对象），提供拦截 JavaScript 操作的方法get() set() deleteProperty()Proxy.revocable(target, handler);取消代理在复杂操作前对操作进行校验或对所需资源进行管理拦截和监视外部对对象的访问使用 Proxy 保障数据类型的准确性使用Proxy实现观察者模式，观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\nmodule静态化 在编译时就完成模块加载export：用于规定模块的对外接口import：用于输入其他模块提供的功能\ndecorator装饰器命名相当于一个注释，在不改变原有代码情况下，对类和类属性原来功能进行扩充不能修饰函数\n\nVue.jsNode.jsNode.js 是一个开源与跨平台的 JavaScript 运行时环境事件驱动、非阻塞和异步输入输出模型\n算法\n前端diff算法 深度优先算法 时间复杂度:O(n) 最小量更新patch 比较虚拟DOM根节点是否同一类型，不同直接替换|patchVnode 进一步比较两个虚拟节点 有无text和children|updateChildren 都有子节点的情况下比较更新真实节点 四个指针，指向oldVnode子节点列表中的第一个节点和最后一个节点以及指向newVnode子节点列表中的第一个节点和最后一个节点，节点比较过，前的指针++，后的指针—\noldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)\noldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)，相同的话移动真实节点OE之后\noldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)，相同的话移动真实节点OS之前\noldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)\n如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置\nold先处理完，新增newS和newE之间的节点\nnew先处理完，删除oldS和oldE之间的节点key的设置 判断两个虚拟节点是否为相同节点不建议用index作为循环项的key，因为操作过程中index会改变，一些相同节点index变了会被当成新的节点，用id的话每个节点key都不同，便于更新时复用节点\n\n\n排序\n数据结构数组栈队列链表树图堆散列表  \n经典算法\n\n网络协议\nHTTPC/S模式 可以传输任意类型数据对象  明文传输，无身份验证 不安全默认端口80无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间无状态：HTTP协议无法根据之前的状态进行本次的请求处理  \nHTTPS加密传输  让HTTP运行安全的SSL/TLS协议(TCP/IP 协议与应用层协议之间)上默认端口443  因为加密和多次握手，性能相对较差通信过程:\n\n首先客户端通过URL访问服务器建立SSL连接\n服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端\n客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级\n客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站\n服务器利用自己的私钥解密出会话密钥\n服务器利用会话密钥加密与客户端之间的通信\n\n\nSSL\n\n对称加密：加密和解密使用的秘钥是同一个，秘钥发送的过程中容易被窃取\n非对称加密：有公钥和私钥，公钥加密后只能用私钥解密，私钥加密后也只能用公钥解密  \n混合加密：发送者用会话密钥加密消息（对称），用公钥加密的会话密钥（非对称），两个一起发送消息接收者用自己的私钥解密出会话密钥，用会话密钥解密消息  \n摘要算法：会话密钥 对称的 明文和摘要一起加密验证信息的完整性  散列函数、哈希函数把消息数据转化成一个特殊字符串，接收者比对接收到的明文计算出的消息摘要和接收到的信息摘要  \n数字签名：公私钥 非对称  身份验证摘要私钥加密成数字签名，公钥解开后再比对原文验证  \nCA验证机构:  \n\n服务器有一套公钥和私钥，把公钥发给CA机构\nCA机构用机构私钥给服务器公钥署数字签名，颁发公钥证书(服务器公钥+数字签名)\n浏览器中预设了机构公钥，客户端拿到服务器的公钥证书，可以自行解密数字签名，得到服务器公钥，跟公钥证书比对\n客户端用服务器公钥加密报文，服务器用服务器私钥解密\n\n\n\n\nUDP\n\nTCP\n\n\nGit\necharts可视化最重要的就是id问题，不能重复\n\nprovide inject导入echarts对象\n获取后端数据\nonMounted里初始化渲染，因为要获取dom元素\n看文档setOption，notMerge: true\n自适应大小window.onresize = function () {myChart1.resize();}\n放echarts的容器要预先设置大小才会渲染\n\nexpressMongoDB","categories":["技术学习"],"tags":["前端","面试"]},{"title":"动画效果合集","url":"/2024/03/27/%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%E5%90%88%E9%9B%86/","content":"\n\n\n\n\n\n123\n"},{"title":"堂吉诃德的科幻之旅","url":"/2023/04/09/%E5%AE%87%E5%AE%99%E6%8E%A2%E7%B4%A2%E7%BC%96%E8%BE%91%E9%83%A8/","content":"首发知乎\n在愚人节这一天，把去年愚人节影评搬上来，哈哈哈\n&nbsp;在看宇宙探索编辑部之前我看了很多关于这部电影的安利与差评，但最后还是决定看一看，事实证明这个选择是正确的。\n首先谈谈这部片的类别，与其说是科幻片，其实更像是一部文艺片。电影没有像很多科幻作品一样的硬核大场面，讨论的甚至都不是软科幻而更像是民科（里面主角之一的孙一通直接让我联想到一款中式恐怖游戏《三伏》）。但事实上，这部片却比很多所谓科幻片更科幻，它更接近科幻的本质问题：人类在宇宙中存在的意义是什么。我很喜欢电影以一种荒诞的黑色幽默探讨科幻的本质与人类的意义。\n然后这部片被诟病最多的是伪纪录片的拍摄方式。我看片的时候一直在思考记录者是谁，直到电影中间孙一通让所有人闭眼并用手捂上镜头，我才意识到这是打破了第四堵墙，每一个观众都是记录者。但是也是为了这种形式电影全程采用手持镜头拍摄，全程画面抖动很厉害，我坐在最后一排看久了都有很强的眩晕感，想要呕吐，最后看完大脑和小脑都是晕的。\n我很喜欢电影中埋下的很多隐喻。这部片的英文名journey to the west(西游记)，暗示着主角团五人深入西南寻找外星人之旅正对应着西游记唐僧一行人西天取经。唐僧求取的是真经天道，而唐志军追寻的是宇宙终极奥义。同时唐志军又很像堂吉诃德，偏执地追寻着虚无缥缈的外星人，哪怕在现实世界里屡屡碰壁也是种坚持理想。他的所作所为明明更像是一个民科，却比任何人都讲求严谨科学；他看似精神偏离常人，却更清醒地寻找着人类的意义。影片后半部分有一段老唐骑着毛驴，笑着淌过小溪，有着强烈的荒诞感，却又让观众意识到老唐追寻的过程远比答案重要。\n石狮子嘴里含的球是一个贯穿全片也很有意思的点。本以为唐志军一行人是踏上向外星人取球的路，结果最后孙一通揭露真相他是来送球的。取球和送球身份的转换刚好对应唐志军内心对于终极问题理解上的转换。唐志军本希望通过外星人来解答关于人类存在意义的问题，孙一通却反问外星人可能也不知道，甚至外星人来地球也是为了获得这个答案。这就跟西天取经取到的是无字天书一样，生命的本质就是无意义。所谓意义其实是每个人在一天天的生活中不断创造赋予的，我们要将无意义的生命过成有意义的人生。回归现实生活，直面荒诞人生，才是这个终极问题的答案。这一点跟加缪的观点很像，除了没用的肉体自杀和精神逃避,第三种自杀的态度是坚持奋斗,对抗人生的荒谬。老唐最终领悟了，不像女儿一样自杀，也不像之前一样精神逃避，他选择重新回归生活，创造自己人生存在的意义。\n影片最后是一段超长镜头，展示从人类到地球到太阳系到银河系到宇宙，最后整个宇宙扭曲形成了人类双螺旋的DNA，起点亦是终点，人类苦苦追寻的意义不过是人类本身。\n电影我估计以后都不会再看了，看一次头真的很晕，但影片带给我的思考会持续很久。\n","categories":["影评"],"tags":["影评"]},{"title":"2024春招冲刺算法百题","url":"/2024/04/15/%E6%98%A5%E6%8B%9B%E5%86%B2%E5%88%BA%E7%99%BE%E9%A2%98/","content":"前言算法刷题之旅继续！！！\n现在刷的题库「2024春招冲刺百题计划」\n语言javascript，会按照题型分类刷，只记录中等及以上的题目解法，偶尔会记录一些特殊规律做法\n矩阵/模拟54.螺旋矩阵题目给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n解析一层一层的回旋记录\n/** * @param {number[][]} matrix * @return {number[]} */var spiralOrder = function(matrix) {    let res=[];    if(matrix.length==0){        return res;    }    let t=0,b=matrix.length-1,l=0,r=matrix[0].length-1;    while(true){        for(let i=l;i&lt;=r;i++){            res.push(matrix[t][i]);        }        if(++t&gt;b)break;        for(let i=t;i&lt;=b;i++){            res.push(matrix[i][r]);        }        if(--r&lt;l)break;        for(let i=r;i&gt;=l;i--){            res.push(matrix[b][i]);        }        if(--b&lt;t)break;        for(let i=b;i&gt;=t;i--){            res.push(matrix[i][l]);        }        if(++l&gt;r)break;    }    return res;};\n59.螺旋矩阵Ⅱ题目给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n解析是前面一道题的逆过程\n/** * @param {number} n * @return {number[][]} */var generateMatrix = function(n) {    let matrix=new Array(n).fill(0).map(()=&gt;new Array(n).fill(0));    let t=0,b=n-1,l=0,r=n-1;    let e=1;    while(e&lt;=n*n){        for(let i=l;i&lt;=r;i++){            matrix[t][i]=e++;        }        ++t;        for(let i=t;i&lt;=b;i++){            matrix[i][r]=e++;        }        --r;        for(let i=r;i&gt;=l;i--){            matrix[b][i]=e++;        }        --b;        for(let i=b;i&gt;=t;i--){            matrix[i][l]=e++;        }        ++l;    }    return matrix;};\n栈二叉树中序遍历(非递归)题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历\n\n解析递归很简单，这里用迭代和莫里斯\n//迭代var inorderTraversal = function(root) {    const res = [];    const stk = [];    while (root || stk.length) {        //先找到最左节点，依次入栈        while (root) {            stk.push(root);            root = root.left;        }        //挨个出栈，按照左中右的顺序push进res        root = stk.pop();        res.push(root.val);        root = root.right;    }    return res;};\n//莫里斯//优势在于没有额外的空间复杂度//就是把树状结构转换成链表//把根节点和右子树挂到左子树的右子节点上var inorderTraversal = function(root) {    const res = [];    let predecessor = null;    while (root) {        if (root.left) {            // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止            predecessor = root.left;            while (predecessor.right &amp;&amp; predecessor.right !== root) {                predecessor = predecessor.right;            }            // 让 predecessor 的右指针指向 root，继续遍历左子树            if (!predecessor.right) {                predecessor.right = root;                root = root.left;            }            // 说明左子树已经访问完了，我们需要断开链接            else {                res.push(root.val);                predecessor.right = null;                root = root.right;            }        }        // 如果没有左孩子，则直接访问右孩子        else {            res.push(root.val);            root = root.right;        }    }    return res;};\n队列堆双指针88.合并两个有序数组(不用额外空间)题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n解析创建一个额外空间数组很简单，但是不使用额外空间的思路挺有意思，是逆向双指针，从后往前比较，放到nums1的尾部，这样就不会出现从前往后的覆盖问题\n/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) {    let p1=m-1,p2=n-1;    let cur=m+n-1;    while(p1&gt;=0||p2&gt;=0){        if(p1==-1){            cur=nums2[p2--];        }else if(p2==-1){            cur=nums1[p1--];        }else if(nums1[p1]&gt;nums2[p2]){            cur=nums1[p1--];        }else {            cur=nums2[p2--];        }        nums1[p1+p2+2]=cur;    }};\n滑动窗口链表树高级数据结构图递归搜索贪心二分查找436.寻找右区间题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n解析\n/** * @param {number[][]} intervals * @return {number[]} */var findRightInterval = function(intervals) {    const len=intervals.length;    const startIntervals=new Array(len).fill(0).map(()=&gt;new Array(2).fill(0));    for(let i=0;i&lt;len;i++){        startIntervals[i][0]=intervals[i][0];        startIntervals[i][1]=i;    }    startIntervals.sort((a,b)=&gt;a[0]-b[0]);    const res=new Array(len).fill(0);    for(let i=0;i&lt;len;i++){        let left=0;        let right=len-1;        let target = -1;        while(left&lt;=right){            const mid=left+((right-left)&gt;&gt;1);            if(startIntervals[mid][0]&gt;=intervals[i][1]){                target = startIntervals[mid][1];                right=mid-1;            }else{                left=mid+1;            }        }        res[i]=target;    }    return res;};\n动态规划403.青蛙过河题目一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。\n给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n\n解析\n数论","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（一）","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言最近在准备面试，投递岗位主要是前端，但是本人也有点想转后端，所以算法题必刷不可。本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java数据结构部分回顾直接看我大二上的数据结构复习笔记，感觉网上查到的没有总结的特别好和全面的(如果我还有精力，会考虑把之前专业课的笔记也放上来。以前的笔记都是OneNote里写的，不是Markdown语法，还都是全英的，整理起来有点复杂)目前先看了一下算法基础，可以参考以下文章的介绍，基本上js扫盲没问题，然后开始力扣刷题https://juejin.cn/post/7087134135193436197\n力扣目前是先把LeetCode75刷完，同时也做每日一题，进行算法扫盲  \n唉，没想到上一次刷力扣都是一年前了，这一次争取刷题量大一点，坚持的久一点，会持续更新的  \n算法笔记（一）已经记录了二十道题，后续每二十道题会新开笔记，刷完后会对题型类别进行再整理\n\n\n题库LeetCode75本笔记涉及到的知识点一览\n\n[ ] 数组 / 字符串 334 151 1071 605 2789\n[ ] 双指针\n[ ] 滑动窗口 1493 1004 1793\n[ ] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈 735\n[ ] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[ ] 二叉搜索树\n[ ] 图 - 深度优先搜索 1261 841\n[ ] 图 - 广度优先搜索 2684 310\n[ ] 堆 / 优先队列 215\n[ ] 二分查找 875\n[ ] 回溯\n[ ] 动态规划 - 一维 1137\n[ ] 动态规划 - 多维 72 2312 62\n[ ] 位运算\n[ ] 前缀树\n[ ] 区间集合\n[x] 单调栈 739 901\n\n\n334.递增的三元子序列题目：\n给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。\n\n解析：\n\n双向遍历 其实本质上就是找到数组中的一个元素，左边有值比它小，右边有值比它大。那么新创建两个长度为n的MIN和MAX数组，即MIN[i]表示nums[0]到nums[i]中的最小值，MAX[i]表示nums[0]到nums[i]中的最大值，然后遍历nums数组找到MIN[i-1]&lt;nums[i]&lt;MAX[i+1]的返回true  \n 整个逻辑需要遍历数组三遍，额外创建两个数组\n\n贪心算法 简单说就是寻找局部最优解，再把每次迭代后的最优解叠加\n 本题目怎么联想到贪心呢，因为看完题目后三元组中的第一个肯定是越小越容易满足递增的情况，所以就是要找到最小的做first，第二小的做second，这样遍历只用找到比second大就返回true  \n 那么迭代思路就是先令nums[0]为first，second为正无穷，开始遍历。遇到nums[i]&gt;second的返回true;遇到first","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（二）","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（一），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \n题库LeetCode75本题库涉及到的知识点一览\n\n[x] 数组 / 字符串 443\n[ ] 双指针\n[ ] 滑动窗口\n[x] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈\n[x] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[x] 二叉搜索树\n[ ] 图 - 深度优先搜索\n[ ] 图 - 广度优先搜索\n[ ] 堆 / 优先队列\n[ ] 二分查找\n[ ] 回溯\n[ ] 动态规划 - 一维\n[ ] 动态规划 - 多维\n[ ] 位运算 338\n[ ] 前缀树\n[x] 区间集合\n[x] 单调栈\n\n\n238.除自身以外数组的乘积题目：\n给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n\n解析：\n经典的前缀和和后缀和，不做多解释了，不过可以稍微优化一下，毕竟维护两个数组内存消耗太大了\n/** * @param {number[]} nums * @return {number[]} */var productExceptSelf = function(nums) {    const len=nums.length;    let ans=new Array(len).fill(1);    let L=1;    for(let i=0;i&lt;len;i++){        ans[i]*=L;        L*=nums[i];    }    let R=1;    for(let i=len-1;i&gt;=0;i--){        ans[i]*=R;        R*=nums[i];    }    return ans;};\n206.反转链表进阶题目：\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。使用递归完成\n\n解析：\n简单解法就是迭代，双指针，保存当前和之前节点，然后遍历修改指向对象\n比较复杂的是递归，需要理解想让指向，可以通过，然后要注意的下一个节点要指向null\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function(head) {    if(head==null||head.next==null){        return head    }    //靠这一步一直递归到列表的最后一个节点    const newHead=reverseList(head.next);    /*    第一轮出栈，head为5，head.next为空，返回5    第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，        把当前节点的子节点的子节点指向当前节点        此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null        此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5        返回节点5    第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，        此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null        此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5        返回节点5    第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，        此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null        此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5        返回节点5    出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1     */    head.next.next=head;    head.next=null;    return newHead};s\n1969.数组元素的最小非零乘积题目：\n给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：从 nums 中选择两个元素 x 和 y  。选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。注意：答案应为取余 之前 的最小值。\n\n解析：​贪心：为了使整体的乘积最小，缩小时优先缩小最小的元素，增加时优先增加最大的元素\n证明：假设a &lt; b &lt; c。选择a缩小1时，此时三者乘积为 (a−1)bc，整体较 abc 缩小了 bc，缩小的幅度最大；当选择b增加1时，此时三者乘积为(a−1)(b+1)c，整体较(a−1)bc 增加了 (a−1)c，增加的幅度最小，得证。\n两个数在进行相同的位交换时，本质即将一个元素缩小 ，另外一个元素增加，为了让这两个数乘积最小，应该尽量把小的那个数换成1。\n根据上述分析，进行相同位交换时，优先缩小数组中最小的元素，再增加数组中最大的元素。\n可以以p为分界线，小于p的为一组，大于p的为一组，大小组的每一个元素(除了)外，遵循最大配最小，第二大配第二小的原则，两两配对(每组两个数之和为)，交换后的必然为和1，乘积是。\n最后，最小乘积为\n由于幂次很大，计算时需要用到快速幂，之前有题目用到了快速幂(指路算法笔记（一）1137.第N个泰波那契数https://ella1019.site/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/#1137-%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)\n/** * @param {number} p * @return {number} */const MOD = 1_000_000_007n;function pow(x, p) {    let res = 1n;    while (p--) {        res = res * x % MOD;        x = x * x % MOD;    }    return res;}var minNonZeroProduct = function(p) {    const k = (1n &lt;&lt; BigInt(p)) - 1n;    return k * pow(k - 1n, p - 1) % MOD;};\n338.比特位计数题目：\n给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。\n\n解析：\n借由本题学习一下位运算相关的知识\n\nBrian Kernighan 算法 对于任意整数x，令 ，该运算将x的二进制表示的最后一个1变成 0，以及后面的0都变成1，而1前面的数不会变。进行&amp;操作之后原本最后一个1以及后面所有的0都会变成0，这样成功实现了减少一个1的目的，可以用这个方法来计数所有的1的个数\n 总的时间复杂度为O(nlogn)\n /** * @param {number} n * @return {number[]} */var countBits = function (n) {    const bits = new Array(n + 1).fill(0);    const countOnes = (x) =&gt; {        let ones = 0;        while (x &gt; 0) {            x &amp;= (x - 1);            ones++;        }        return ones;    }    for (let i = 0; i &lt; n + 1; i++) {        bits[i] = countOnes(i);    }    return bits;};\n\n动态规划(最高有效位) 主要是利用2的整数幂(  )对应的二进制表示都是最高位是1，其余位都是0，这里尝试抽象出状态变化 \n 举一个例子，13的二进制表达为1101，它的最高位是1000，即为8(  )，减去最高位后5的二进制表达式为101，1的个数比13要少1\n 那么只需要遍历然后判断2的整数幂即可\n var countBits = function(n) {    const bits = new Array(n + 1).fill(0);    let highBit = 0;    for (let i = 1; i &lt;= n; i++) {        if ((i &amp; (i - 1)) == 0) {            highBit = i;        }        bits[i] = bits[i - highBit] + 1;    }    return bits;};\n\n动态规划(最低有效位) 同样的，也可以从最低位入手，将二进制表示x右移一位，等价于。\n 如果x是偶数，则 \n 如果x是奇数，则\n 上述两种情况可以进一步简化。由于可以通过 x&gt;&gt;1得到，x除以2的余数可以通过得到，因此有：\n var countBits = function(n) {const bits = new Array(n + 1).fill(0);for (let i = 1; i &lt;= n; i++) {    bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);}return bits;};\n\n动态规划(最低设置位) 就是整合前面的规律，得到 \n var countBits = function(n) {    const bits = new Array(n + 1).fill(0);    for (let i = 1; i &lt;= n; i++) {        bits[i] = bits[i &amp; (i - 1)] + 1;    }    return bits;};\n\n\n322.零钱兑换题目：\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。\n\n解析：\n\n动态规划\n 这里的状态转移方程应该是 ，F(i)为组成金额i所需最少的硬币数量，表示第j枚硬币的面值，这里枚举所有的硬币面值，选数量最少的。\n 时间复杂度为O(amount*coins.length)，空间复杂度为O(amount)\n var coinChange = function(coins, amount) {    let num=new Array(amount+1).fill(amount+1);    num[0]=0;    for(let i=1;i&lt;amount+1;i++){        for(const coin of coins){            if(coin&lt;=i){                num[i]=Math.min(num[i],num[i-coin]+1);            }        }    }    return num[amount] &gt; amount ? -1 : num[amount];};\n\n贪心\n 本题我的第一反应就是贪心，优先大面值，余数小面值，不行的话就大面值回滚一个再小面值，但是会超时？而且有些奇葩用例最先找到的并不是数量最少的，还是得全部遍历(例如amount=14，coins[1,7,10]，贪心会选择[10,1,1,1,1]，但正确答案应该是[7,7])？算下来还不如直接dp\n\n\n518.零钱兑换Ⅱ题目：\n给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。题目数据保证结果符合 32 位带符号整数。\n\n解析：\n老动态规划了，\n/** * @param {number} amount * @param {number[]} coins * @return {number} */var change = function (amount, coins) {    let num = new Array(amount + 1).fill(0);    num[0] = 1;    for (const coin of coins) {        for (let i = coin; i &lt; amount + 1; i++) {            num[i] += num[i - coin];        }    }    return num[amount];};\n443.压缩字符串题目：\n给你一个字符数组 chars ，请使用下述算法压缩：从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：如果这一组长度为 1 ，则将字符追加到 s 中。否则，需要向 s 追加字符，后跟这一组的长度。压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。请在 修改完输入数组后 ，返回该数组的新长度。你必须设计并实现一个只使用常量额外空间的算法来解决此问题。\n\n解析：\n没有特别需要说明的，就是正常遍历，用两个指针记录子串长度\n/** * @param {character[]} chars * @return {number} */var compress = function (chars) {    let r = 0, w = 0;    const len = chars.length;    while (r &lt; len) {        let index = r;        while (chars[index] == chars[r] &amp;&amp; index &lt; len) {            index++;        }        let cnt = index - r;        chars[w++] = chars[r];        if (cnt &gt; 1) {            let str = cnt.toString();            for (let i = 0; i &lt; str.length; i++) {                chars[w++] = str[i];            }        }        r = index;    }    return w;};\n11.盛最多水的容器题目：\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。\n\n解析：\n经典的双指针问题，面积实际上等于两个指针中较小的那一个值乘以两个指针间的距离\n这里先从数组边界开始，每一次都移动较小的边界指针(因为只有最短的会影响到整体)，最后遍历返回最大的\n/** * @param {number[]} height * @return {number} */var maxArea = function (height) {    let l = 0, r = height.length - 1, max = 0;    while (l &lt; r) {        max = Math.max(max, (r - l) * Math.min(height[l], height[r]));        if (height[l] &lt;= height[r]) {            ++l;        } else {            --r;        }    }    return max;};\n17.电话号码的字母组合题目：\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n解析：\n回溯：本质上就是穷举，把所有的情况以n叉树的形式表示出来，可以用伪代码表示递归逻辑\nvoid backtracking(递归深度，即树的高度) {    //终止条件    if (树是否递归完) {        保存结果;        return;    }    for (当前节点的子节点数量) {        处理当前子节点;        backtracking(下一层节点); // 递归        回溯，撤销当前子节点;    }}\n本题关键在于树的宽度是由每个数字对应的字母决定，树的深度由数字的数量决定\n/** * @param {string} digits * @return {string[]} */var letterCombinations = function (digits) {    if (digits.length == 0) return [];    let res = [], path = [];    const map = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];    if (digits.length === 1) return map[digits].split(\"\");    const backtracking = (digits, length, index) =&gt; {        if (path.length == length) {            res.push(path.join(\"\"));            return;        }        for (const s of map[digits[index]]) {            path.push(s);            backtracking(digits, length, index + 1);            path.pop(s);        }    }    backtracking(digits, digits.length, 0)    return res;};\n2580.统计将重叠区间合并成组的方案数题目：\n给你一个二维整数数组 ranges ，其中 ranges[i] = [starti, endi] 表示 starti 到 endi 之间（包括二者）的所有整数都包含在第 i 个区间中。你需要将 ranges 分成 两个 组（可以为空），满足：每个区间只属于一个组。两个有 交集 的区间必须在 同一个 组内。如果两个区间有至少 一个 公共整数，那么这两个区间是 有交集 的。比方说，区间 [1, 3] 和 [2, 5] 有交集，因为 2 和 3 在两个区间中都被包含。请你返回将 ranges 划分成两个组的 总方案数 。由于答案可能很大，将它对 109 + 7 取余 后返回。\n\n解析：\n合并区间的思路，一般是先把区间按照左边界排序，然后遍历区间，维护当前合并区间的最大右边界maxR。如果当前区间左边界l &gt; maxR，则没有重叠，更新maxR为当前区间右边界r；反之则右重叠区域，把当前区间合并，再更新maxR\n/** * @param {number[][]} ranges * @return {number} */var countWays = function(ranges) {    ranges.sort((a,b)=&gt;a[0]-b[0]);    let res=1,maxR=-1;    for(const [l,r] of ranges){        if(l&gt;maxR){            res=res*2%1_000_000_007;        }        maxR=Math.max(r,maxR);    }    return res;};\n435.无重叠区域题目：\n给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。\n\n解析：\n\n动态规划(超时)\n\n总结一下动态规划的逻辑一般是倒推，先假定一种情况，然后再逆推要达到这种情况的条件，找到规律以后遍历即可\n本题逻辑就是用fi表示以i区间为集合最后一个区间，不重叠的最大区间数。那么逆推条件，这个最大区间数应该是倒数第二个区间+1得到的，因为这里要求不重叠，所以倒数第二个区间不一定和最后一个区间相邻，应该寻找满足同时fj最大的。因此状态方程为 \n这里的时间复杂度达到了，所以必须优化\n\n贪心\n\n官方题解没太看懂，但是看评论区大佬解释理解了，可以代入情景今天有好几个活动，每个活动都可以用区间 [start,end]表示开始和结束的时间，请问你今天最多能参加几个活动呢？\n正确逻辑就是照结束时间从早到晚排序，优先选择参加那些结束时间早的，因为这样可以留下更多的时间参加其余的活动。如果有多个结束时间相同的，我们选择开始时间晚的，因为这样也有助于参加更多的活动。然后再从前往后遍历一遍，把后面重叠的删去，这样保证了最后得到的一定是最大不重叠区间\nvar eraseOverlapIntervals = function(intervals) {    if (!intervals.length) {        return 0;    }    intervals.sort((a, b) =&gt; a[1] - b[1]);    const n = intervals.length;    let right = intervals[0][1];    let ans = 1;    for (let i = 1; i &lt; n; ++i) {        if (intervals[i][0] &gt;= right) {            ++ans;            right = intervals[i][1];        }    }    return n - ans;};\n452.用最少数量的箭引爆气球题目：\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数\n\n解析：\n再来一道重叠区间！逻辑是一样的气球尾的位置升序排列，然后以第一个气球尾作为右边界，依次遍历，只要遇到第一个气球头超过了当前右边界，那么说明后续要么都没跟第一个气球重叠，要么哪怕有重叠后面的箭也会引爆，这样只用一次遍历即可\n/** * @param {number[][]} points * @return {number} */var findMinArrowShots = function(points) {    if (!points.length ) {        return 0;    }    points.sort((a, b) =&gt; a[1] - b[1]);    let pos = points[0][1]    let ans = 1;    for (let balloon of points) {        if (balloon[0] &gt; pos) {            pos = balloon[1];            ans++;        }    }    return ans;};\n1997.访问完所有房间的第一天题目：\n你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：假设某一天，你访问 i 号房间。如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 &lt;= nextVisit[i] &lt;= i 。如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果\n\n解析：\n动态规划，题目的意思是如果首次到达房间i，那么一定会回退到前面的房间nextVisit[i]，如果想到下一个房间只能是第二次访问，所以可以推测出到达i房间，[0,i)的房间已经被访问过偶数次\n这题麻烦在提取哪一个量作为状态量，这里定义dp[i]是从房间0到第一次到达房间i所花费的天数，这个转换逻辑是\n\n从0第一次到i-1    dp[i−1]  (隐藏条件[0,i-1)访问次数都是偶数)\n从i-1跳到nextVisit[i-1]    走1天\n从nextVisit[i-1]到i-1    dp[i-1]−dp[nextVisit[i]] ((nextVisit[i],i-1)访问次数都是偶数，所以这个区间的跳转情况跟第一次访问是一样的)\ni-1到i    走1天\n\n得到状态方程dp[i]=2*dp[i−1]−dp[nextVisit[i-1]]+2\n/** * @param {number[]} nextVisit * @return {number} */var firstDayBeenInAllRooms = function(nextVisit) {    const mod =1e9+7;    const len=nextVisit.length;    const dp=new Array(len).fill(0);    for(let i=1;i&lt;len;i++){        //注意这里为了避免负数要+mod        dp[i]=(2*dp[i-1]-dp[nextVisit[i-1]]+2+ mod)%mod;    }    return dp[len-1];};\n208.实现 Trie (前缀树)题目：\nTrie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类：Trie() 初始化前缀树对象。void insert(String word) 向前缀树中插入字符串 word 。boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n\n解析：\n简单解释前缀树就是多叉树，类似于把字符串纵向排列，每层子节点为26个，表示26字母，每个子节点又会对应下一层26个子节点，直到字符串所有字符遍历完，通常不会初始化所有的26个子节点，按照需求初始化\nvar Trie = function() {    this.children={};};/**  * @param {string} word * @return {void} */Trie.prototype.insert = function(word) {    let node = this.children;    for(const ch of word){        if(!node[ch]){            node[ch]={};        }        node=node[ch];    }    node.isEnd=true;};/**  * @param {string} word * @return {boolean} */Trie.prototype.search = function(word) {    let node = this.children;    for(const ch of word){        if(!node[ch]){            return false;        }        node=node[ch];    }    return node!==undefined&amp;&amp;node.isEnd!==undefined;};/**  * @param {string} prefix * @return {boolean} */Trie.prototype.startsWith = function(prefix) {    let node = this.children;    for(const ch of prefix){        if(!node[ch]){            return false;        }        node=node[ch];    }    return node!==undefined;};/** * Your Trie object will be instantiated and called as such: * var obj = new Trie() * obj.insert(word) * var param_2 = obj.search(word) * var param_3 = obj.startsWith(prefix) */\n649.Dota2参议院题目：\nDota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。\n\n解析：\n贪心加循环队列，维护两个阵营记录了各自参议员顺序的队列，按照顺序，当前参议院一定会淘汰掉下一个对方参议员，那么被淘汰掉的踢出队列，没被淘汰的进入队列尾部准备下一轮循环，最后看哪个队列不为空，即为获胜方\n这里注意获取字符串的每个字符序列可以用Array.from(string).entries()，from是转化为array，entries可以获取每一个元素和对应的索引，可以用for (const [index, element] of array.entries())获取\n一个小坑，在JavaScript中循环退出数组用while (array.length)，而不用array！=null，因为会超时[]!=null\n/** * @param {string} senate * @return {string} */var predictPartyVictory = function(senate) {    let radient=[],dire=[];    const n = senate.length;    for(const [index,ch] of Array.from(senate).entries()){        if(ch==\"R\"){            radient.push(index);        }else{            dire.push(index);        }    }    while(radient.length&amp;&amp;dire.length){        if(radient[0]&lt;dire[0]){            radient.push(radient[0]+n);        }else{            dire.push(dire[0]+n);        }        radient.shift();        dire.shift();    }    return radient.length ? \"Radiant\" : \"Dire\";};\n2095.删除链表的中间节点题目：\n给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。\n\n解析：\n设置一个head前的哨兵指针，然后设置快慢指针，快的一次走两个，慢的走一个，快的走到头，慢的所指就是中间节点\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution {    public ListNode deleteMiddle(ListNode head) {        ListNode pre = new ListNode(0, head);        ListNode fp = pre.next;        ListNode sp = pre;        while (fp != null &amp;&amp; fp.next != null) {            fp = fp.next.next;            sp = sp.next;        }        sp.next = sp.next.next;        return pre.next;    }}\n450.删除二叉搜索树中的节点题目：\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。\n\n解析：\n二叉搜索树构建增删改算法没啥好说的，数据结构基本常识了，做一下纯当练手了\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */var deleteNode = function(root, key) {    if(!root){        return null;    }    if (root.val &gt; key) {        root.left = deleteNode(root.left, key);        return root;    }    if (root.val &lt; key) {        root.right = deleteNode(root.right, key);        return root;    }    if(root.val==key){        if (!root.left &amp;&amp; !root.right) {            return null;        }        if (!root.right) {            return root.left;        }        if (!root.left ) {            return root.right;        }        let node=root.right;        while(node.left){            node=node.left;        }        root.right=deleteNode(root.right, node.val)        node.right=root.right;        node.left=root.left;        return node;    }};\n199.二叉树的右视图题目：\n给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n解析：\n\nbfs 广度优先，层序遍历，每次返回最右边的那一个\n     /** * Definition for a binary tree node.* public class TreeNode {*     int val;*     TreeNode left;*     TreeNode right;*     TreeNode() {}*     TreeNode(int val) { this.val = val; }*     TreeNode(int val, TreeNode left, TreeNode right) {*         this.val = val;*         this.left = left;*         this.right = right;*     }* }*/class Solution {    public List&lt;Integer&gt; rightSideView(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null) return ans;        Queue&lt;TreeNode&gt; q=new LinkedList&lt;&gt;();        q.offer(root);        int count;        while(!q.isEmpty()){            count=q.size();            for(int i=0;i&lt;count;i++){                TreeNode node=q.poll();                if(node.left!=null)q.offer(node.left);                if(node.right!=null)q.offer(node.right);                if(i==count-1)ans.add(node.val);            }        }        return ans;    }}\n\ndfs 深度优先，ans数组会获取到二叉树汇总最长路径，因为后访问右子树，如果有的话每层最右边节点会覆盖ans原先位置节点，最终可以得到右视图\n class Solution {    public List&lt;Integer&gt; rightSideView(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        dfs(root,0,ans);        return ans;            }    private void dfs(TreeNode node,int depth,List&lt;Integer&gt; ans){        if(node==null)return;        if(ans.size()&lt;=depth){            ans.add(node.val);        }else{            ans.set(depth, node.val);        }        dfs(node.left, depth + 1,ans);        dfs(node.right, depth + 1,ans);                }}\n\n\n2952.需要添加的硬币的最小数量题目：\n给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 可取得的金额 。返回需要添加到数组中的 任意面值 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。数组的 子序列 是通过删除原始数组的一些（可能不删除）元素而形成的新的 非空 数组，删除过程不会改变剩余元素的相对位置。\n\n解析：\n贪心假设现在得到了区间 [0,x−1] 中的所有整数，如果此时遍历到整数 coins[i]，那么把 [0,x−1]中的每个整数都增加 coins[i]，我们就得到了区间 [coins[i],coins[i]+x−1]中的所有整数。\n如果 coins[i]&lt;=x，那么合并 [0,x−1] 和 [coins[i],coins[i]+x−1] 这两个区间，我们可以得到 [0,coins[i]+x−1] 中的所有整数。如果 coins[i]&gt;x，或者遍历完了 coins数组，这意味着我们无法得到 x，那么就一定要把 x加到数组中（加一个比 x还小的数字就没法得到更大的数，不够贪），这样就可以得到了 [x,2x−1]中的所有整数，再与 [0,x−1]合并，可以得到 [0,2x−1]中的所有整数。然后再考虑 coins[i] 和 2x 的大小关系，继续分类讨论。\n/** * @param {number[]} coins * @param {number} target * @return {number} */var minimumAddedCoins = function(coins, target) {    coins.sort((x,y)=&gt;x-y);    let ans=0,x=1,i=0;    while(x&lt;=target){        if(i&lt;coins.length&amp;&amp;coins[i]&lt;=x){            x+=coins[i++];        }else{            ans++;            x*=2;        }    }    return ans;};\n331.验证二叉树的前序序列化题目：\n序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n\n解析：\n回忆一下前序中序后序遍历，前中后指的是根节点的位置\n本题用栈来模拟遍历，判断是否是叶子节点就是看该节点是否有两个#子节点\n因为是递归，判断当前是否递归完叶子结点就是通过查找到连续x,#,#，然后把这三个全部出栈，用#代替，这样父节点也可以模拟叶子结点，只要最后栈里只剩下#，那么就成功遍历完\n参考他人画的动画理解\n(好像消消乐)\n/** * @param {string} preorder * @return {boolean} */var isValidSerialization = function(preorder) {    let stack=[];    const arr=preorder.split(\",\")    for(const ch of arr){        stack.push(ch);        while(stack.length&gt;=3&amp;&amp;stack[stack.length-1] =='#'&amp;&amp; stack[stack.length-2] == '#' &amp;&amp; stack[stack.length-3] != '#'){            stack.pop();            stack.pop();            stack.pop();            stack.push(\"#\");        }    }    return stack.length==1&amp;&amp;stack.pop()==\"#\";};\n\n接算法笔记（三）~","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（三）","url":"/2024/04/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（二），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \n题库LeetCode75本题库涉及到的知识点一览\n\n[x] 数组 / 字符串\n[ ] 双指针\n[ ] 滑动窗口\n[x] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈\n[x] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[x] 二叉搜索树\n[ ] 图 - 深度优先搜索\n[ ] 图 - 广度优先搜索\n[ ] 堆 / 优先队列\n[ ] 二分查找\n[ ] 回溯\n[ ] 动态规划 - 一维\n[ ] 动态规划 - 多维\n[x] 位运算\n[ ] 前缀树\n[x] 区间集合\n[x] 单调栈\n\n\n136.只出现一次的数字题目：\n给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n解析：\n虽然是简单题，但是没做过类似的位运算真的会被卡，不用位运算应该有三种，集合去重，哈希计数，集合去重*2减去原本数组元素，但是空间复杂度都会超，这里只有异或不用额外空间\n复习一下异或的特性\n任何数和 0 做异或运算，结果仍然是原来的数，即  。任何数和其自身做异或运算，结果是 0，即 。异或运算满足交换律和结合律，即 。\nvar singleNumber = function(nums) {    let res=0;    for(const num of nums){        res^=num;    }    return res;};\n1318.或运算的最小翻转次数题目：\n给你三个正整数 a、b 和 c。你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b == c  成立的最小翻转次数。「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。\n\n解析：\n异或秒了\n分类讨论就是遍历每一位，当a和b都为0，而c为1，只用翻转一次；当a和b都为1，而c为0，要翻转两次。\n如果直接ab或再与c异或会少翻转次数，通过ab与得到两个为1再与非c与，就可以补上少的一部分翻转次数\n使用异或来数二进制数的1的个数\nvar minFlips = function(a, b, c) {    const countOne=(x)=&gt;{        let ones=0;        while(x&gt;0){            x&amp;=(x-1);            ones++;        }        return ones;    }    return countOne((a|b)^c)+countOne((a&amp;b)&amp;(~c));};\n894.所有可能的真二叉树题目：\n给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val == 0 。答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。\n\n解析：\n通过题目意思可以推测处真二叉树是指每个节点的子节点为0或者2的树。因为二叉树一定有一个根节点，所以真二叉树的节点个数一定是奇数。\n\n从叶子的角度(dp)\n\n一棵有 n 个节点的真二叉树恰好有个叶子。示例中返回列表的顺序是一层一层的返回，如果某个节点在上一层就是叶子结点了，那么在下一层对应的位置会返回两个null，因此可以考虑n与2n-1或者n与来表示当前节点和其对应的叶子结点。\n定义 f[i] 为有 i 个叶子的所有真二叉树的列表。枚举左子树有 j=1,2,⋯ ,i−1 个叶子，那么右子树有 i−j 个叶子。\n左子树的所有真二叉树列表为 f[j]，右子树的所有真二叉树列表为 f[i−j]。从这两个列表中各选一棵真二叉树，作为根节点的左右子树，从而得到有 i 个叶子的真二叉树，这些真二叉树组成了 f[i]。\n初始值：f[1] 为只包含一个节点的二叉树列表。\nconst f = Array.from({length: 11}, () =&gt; []);f[1].push(new TreeNode());for (let i = 2; i &lt; f.length; i++) { // 计算 f[i]    for (let j = 1; j &lt; i; j++) { // 枚举左子树叶子数        for (const left of f[j]) { // 枚举左子树            for (const right of f[i - j]) { // 枚举右子树                f[i].push(new TreeNode(0, left, right));            }        }    }}var allPossibleFBT = function(n) {    return f[n % 2 ? (n + 1) / 2 : 0];};\n\n从节点角度\n\n当 n 是奇数时，n 个结点的真二叉树满足左子树和右子树的结点数都是奇数，此时左子树和右子树的结点数之和是 n−1，假设左子树的数目为 i，则左子树的节点数目则为 n−1−i，则可以推出左子树与右子树的节点数目序列为：[(1,n−2),(3,n−4),(5,n−6),⋯ ,(n−2,1)]\n自底向上进行动态规划:n=1的子树，就是根节点；[(1,1)]的子树序列，可以构成n=3的真二叉树；[(1,3),(3,1)]的子树序列，可以构成n=5的真二叉树；[(1,5),(3,3),(5,1)]的子树序列，可以构成n=7的真二叉树；\nvar allPossibleFBT = function (n) {    if (n % 2 === 0) {        return [];    }    const dp = Array(n + 1).fill().map(() =&gt; []);    dp[1] = [new TreeNode(0)];    for (let i = 3; i &lt;= n; i += 2) {        for (let j = 1; j &lt; i; j += 2) {            for (let leftSubtree of dp[j]) {                for (let rightSubtree of dp[i - 1 - j]) {                    const root = new TreeNode(0, leftSubtree, rightSubtree);                    dp[i].push(root);                }            }        }    }    return dp[n];};\n1600.王位继承顺序题目：\n一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。Successor(x, curOrder):    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：        如果 x 是国王，那么返回 null        否则，返回 Successor(x 的父亲, curOrder)    否则，返回 x 不在 curOrder 中最年长的孩子通过以上的函数，我们总是能得到一个唯一的继承顺序。请你实现 ThroneInheritance 类：ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n\n解析：\n本题其实类似于多叉树的前序遍历，存储这棵树的方法可以是哈希映射，(父，子列表)的形式存储\n本题逻辑不难，但是有个时间性能的点要注意，如果我的dead使用array来存储，最后会超时，但是用set来存储不会。数组里面的搜索是基于索引的都是 O(N) ，而set是基于键值对的O(1)，数组的indexOf()和includes()方法查找比较慢，而set的has()会快很多\n/** * @param {string} kingName */var ThroneInheritance = function(kingName) {    this.king=kingName;    this.edges=new Map();    this.dead=new Set();};/**  * @param {string} parentName  * @param {string} childName * @return {void} */ThroneInheritance.prototype.birth = function(parentName, childName) {    if(!this.edges.has(parentName)){        this.edges.set(parentName,[]);    }    this.edges.get(parentName).push(childName);    };/**  * @param {string} name * @return {void} */ThroneInheritance.prototype.death = function(name) {    this.dead.add(name);};/** * @return {string[]} */ThroneInheritance.prototype.getInheritanceOrder = function() {    const res=[];    const preorder=(name)=&gt;{        if(!this.dead.has(name)){            res.push(name);        }        if(this.edges.has(name)){            for(const child of this.edges.get(name)){                preorder(child);            }        }            }    preorder(this.king);    return res;};/** * Your ThroneInheritance object will be instantiated and called as such: * var obj = new ThroneInheritance(kingName) * obj.birth(parentName,childName) * obj.death(name) * var param_3 = obj.getInheritanceOrder() */\n2192.有向无环图的祖先题目：\n给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。\n\n解析：\n第一反应可以逆向+dfs注意这里用js创建邻接表用Array.from()方法\n/** * @param {number} n * @param {number[][]} edges * @return {number[][]} */var getAncestors = function(n, edges) {    //创建[[],[],[],[]]    const adj=Array.from({length:n},()=&gt;[]);    //反向建图    for(const [x,y] of edges){        adj[y].push(x);    }    const dfs=(x,adj,vis)=&gt;{        vis[x]=true;        for(const y of adj[x]){            if(!vis[y]){                dfs(y,adj,vis);            }        }    }    const res=Array.from({length:n},()=&gt;[]);    const vis=Array(n);    for(let i=0;i&lt;n;i++){        vis.fill(false);        dfs(i,adj,vis);        vis[i]=false;        for(let j=0;j&lt;n;j++){            if(vis[j]){                res[i].push(j);            }        }    }    return res;};\n1026.节点与其祖先之间的最大差值题目：\n给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n\n解析：\ndfs+记录前面节点的最大值和最小值即可\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number} */var maxAncestorDiff = function(root) {    const dfs=(root,min,max)=&gt;{        if(root==null){            return 0;        }        let res=Math.max(Math.abs(root.val-min),Math.abs(root.val-max));        min=Math.min(min,root.val);        max=Math.max(max,root.val);        res=Math.max(dfs(root.left,min,max),res);        res=Math.max(dfs(root.right,min,max),res);        return res;    }    return dfs(root,root.val,root.val);};\n1483.树节点的第k个祖先题目：\n给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。实现 TreeAncestor 类：TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。getKthAncestor(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。\n\n解析：\n暴力向上递归查找父节点会超时，学一下倍增的方法\n官方题解又没太看懂，先通过例子来理解一下ST表和倍增的思路\n假如有链表A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G，从任意节点跳k步可以到下一个节点，比如A跳两步到C，B跳两步到D\n那么设 f[step][begin] 表示从 begin 开始跳 step 步到达的位置，f[0][begin] = begin，f[1][begin] = f[0][begin]-&gt;next ，f[2][begin] =f[1][begin]-&gt;next，那么f[4]可以表示为跳四步跳两步再跳两步，即f[4][begin] = f[2][f[2][begin]]。\n至此跳任意k步都可以化为二进制的形式求和，而二进制的步长完全可以由前一步递推得到，这就是倍增思想，是st表的指导思想. 一般地有\n当 step1+step2 == step时f[step][begin] = f[step2][f[step1][begin]]\n选取2作为一般步长保留计算结果取log(step) 节约空间 f[i][begin] 表示从 begin 位置起跳，跳 1&lt;&lt;i 步到达的点，利用 dp 可求得 f[i][j]\n回到本题定义 ancestors[i][j] 表示节点 i 的第 个祖先。状态转移方程是 ancestors[i][j]=ancestors[ancestors[i][j−1]][j−1]，即当前节点的第 个祖先，是他的第 个祖先的第 个祖先。当第 个祖先不存在时，记为 −1。\ngetKthAncestor需要找到 k 的二进制表示中的所有 1（相当于把 k 分解为若干 ），然后对K进行移位，k的每个1位都表示跳数\n/** * @param {number} n * @param {number[]} parent */const LOG = 16;var TreeAncestor = function(n, parent) {    ancestors = new Array(n).fill(0).map(() =&gt; new Array(LOG).fill(-1));    for (let i = 0; i &lt; n; i++) {        ancestors[i][0] = parent[i];    }    for (let j = 1; j &lt; LOG; j++) {        for (let i = 0; i &lt; n; i++) {            if (ancestors[i][j - 1] !== -1) {                ancestors[i][j] = ancestors[ancestors[i][j - 1]][j - 1];            }        }    }    };/**  * @param {number} node  * @param {number} k * @return {number} */TreeAncestor.prototype.getKthAncestor = function(node, k) {    for (let j = 0; j &lt; LOG; j++) {        if (((k &gt;&gt; j) &amp; 1) !== 0) {            node = ancestors[node][j];            if (node === -1) {                return -1;            }        }    }    return node;};/** * Your TreeAncestor object will be instantiated and called as such: * var obj = new TreeAncestor(n, parent) * var param_1 = obj.getKthAncestor(node,k) */\n42.接雨水题目：\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n解析：\n经典题目\n1.dp从左至右最高的扫过去，可以得到以左边边界为最大值的雨水；从右至左最高的扫过去，可以得到以右边边界为最大值的雨水。两者重叠部分就是能接到的雨水，可以理解为某一下标处能接到的雨水等于左右两边的最大值较小的那一个减去当前下标\n\nleftMax[i] 表示下标 i及其左边的位置中，height的最大高度，rightMax[i]表示下标 i 及其右边的位置中，height的最大高度，正向和反向各遍历一次即可\nvar trap = function(height) {    const len = height.length;    if(len==0){        return 0;    }    const leftMax=new Array(len).fill(0);    const rightMax=new Array(len).fill(0);    leftMax[0]=height[0];    rightMax[len-1]=height[len-1];    for(let i=1;i&lt;len;i++){        leftMax[i]=Math.max(leftMax[i-1],height[i]);    }    for(let i=len-2;i&gt;=0;i--){        rightMax[i]=Math.max(rightMax[i+1],height[i]);    }    let res=0;    for(let i=0;i&lt;len;i++){        res+=Math.min(rightMax[i],leftMax[i])-height[i];    }    return res;};\n代码可以进一步优化，不用两个数组，两个指针就行\nvar trap = function(height) {    const len = height.length;    if(len==0){        return 0;    }    const rightMax=new Array(len).fill(0);    let leftMax=0;    rightMax[len-1]=height[len-1];    for(let i=len-2;i&gt;=0;i--){        rightMax[i]=Math.max(rightMax[i+1],height[i]);    }    let res=0;    for(let i=0;i&lt;len;i++){        leftMax=Math.max(leftMax,height[i]);        res+=Math.min(rightMax[i],leftMax)-height[i];    }    return res;};\n\n单调栈\n\n创建一个栈来存储height的索引，依次遍历数组入栈，保证栈里的高度是递减的，当遇到比当前的栈顶元素的高度高时，栈顶元素出栈，栈顶元素索引左右两边的元素高度取最小值，减去栈顶元素的高度，再乘以两个元素索引之间的间距，一直循环直到栈里为空，再进入下一个索引比较\n这样是可以保证当元素高度递减的时候，不停入栈，但是当出现一个更高的，就会停下来循环出栈，直到高度差被磨平(凹槽被填满)，再继续入栈\n/** * @param {number[]} height * @return {number} */var trap = function(height) {    let res=0;    //栈里压入的是索引序号，要通过height获取高度值    const stack=[];    const len=height.length;    for(let i=0;i&lt;len;i++){        while(stack.length&amp;&amp;height[i]&gt;height[stack[stack.length-1]]){            const top=stack.pop();            if(!stack.length){                break;            }            res+=(Math.min(height[i],height[stack[stack.length-1]])-height[top])*(i-stack[stack.length-1]-1);        }        stack.push(i);    }    return res;};\n1268.搜索推荐系统题目：\n给你一个产品数组 products 和一个字符串 searchWord ，products  数组中每个产品都是一个字符串。请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。\n\n解析：\n题目的意思是每键入一个字母，就全局比较一次前缀。最简单的方法应该是字典树，把product数组里的每一个字符串都存入字典树里，然后searchWord字符串键入就是进入下一层搜索\n题目中需要先对product进行字典序排序，然后依次插入字典树，每个节点都维护一个数组记录一下当前插入的字符所属原字符串在product数组中的顺序，这个表只记录前3个就可\n由于字典树构建空间消耗很大，当products数组已经排序后可以考虑二分\n/** * @param {string[]} products * @param {string} searchWord * @return {string[][]} */var suggestedProducts = function(products, searchWord) {    products.sort();    const len=products.length;    const res=[];    for(let i=0;i&lt;searchWord.length;i++){        const cur=searchWord.substring(0,i+1);        let l=0,r=len-1;        while(l&lt;r){            //可以用位运算来/2            const mid=(l+r)&gt;&gt;1;            if(products[mid].localeCompare(cur) &gt;= 0){                r=mid;            }else{                l=mid+1;            }        }        const list=[];        //localeCompare方法如果引用字符串（referenceStr）存在于比较字符串（compareString）之前则为负数；如果引用字符串存在于比较字符串之后则为正数；相等的时候返回 0        if(products[r].localeCompare(cur)&gt;=0){            for(let j=r;j&lt;=Math.min(len-1,r+2);j++){                if(products[j].length&lt;cur.length||!products[j].startsWith(cur)){                    break;                }                list.push(products[j]);            }        }        res.push(list);    }    return res;};\n77.组合题目：\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。\n\n解析：\n经典回溯，树的宽度是可选的范围大小，深度是选择次数，在本题里就是宽度是n，深度是k\n还需要额外维护一个保存结果的二维数组和记录了遍历路径的数组\n/** * @param {number} n * @param {number} k * @return {number[][]} */var combine = function(n, k) {    let res=[];    let path=[];    const backtracking=(n,k,next)=&gt;{        if(path.length==k){            //// 将 path的副本推入 res，而不是直接推入 path，否则后面pop和push操作都会影响path            res.push([...path]);            return;        }        //这里如果剪枝的话，应该改成i&lt;=n - (k - path.length) + 1        //就是保证当后面还要选取的对象都包含在path里时，当前遍历可以停止了        //例：n = 4, k = 3        //path.size() = 0 时还需要3个数构成组合，最后3个数为{2, 3, 4}，故此时至多应遍历到2，即4-3+1=2        //path.size() = 1 时还需要2个数构成组合，最后2个数为{3, 4}，故此时至多应遍历到3，即4-2+1=3        //path.size() = 2 时还需要1个数构成组合，最后1个数为{4}，故此时至多应遍历到4，即4-1+1=4        for(let i=next;i&lt;=n;i++){            path.push(i);            backtracking(n,k,i+1);            path.pop();        }    }    backtracking(n,k,1);    return res;};\n216.组合总和III题目：\n找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：只使用数字1到9每个数字 最多使用一次返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n\n解析：\n还是回溯，只不过多了一个条件就是求和，可以用n在每次查找过程中减去当前选择的元素，回溯的时候加上，最后n为0且path.length=k的path就是答案\n/** * @param {number} k * @param {number} n * @return {number[][]} */var combinationSum3 = function(k, n) {    let res=[],path=[];    const backtracking=(k,n,next)=&gt;{        if (n &lt; 0) {            return;        }        if(path.length==k){            if(n==0){                res.push([...path]);            }            return;        }        for(let i=next;i&lt;=9 - (k - path.length) + 1;i++){            n-=i;            path.push(i);            backtracking(k,n,i+1);            path.pop();            n+=i;        }    }    backtracking(k,n,1);    return res;};\n394.字符串解码题目：\n给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n解析：\n/** * @param {string} s * @return {string} */var decodeString = function (s) {    let res = \"\";    let num = 0;    let stack = [];    let stack_num = [];    for (const ch of s) {        if (ch == '[') {            stack_num.push(num);            stack.push(res);            num = 0;            res = \"\";        } else if (ch == ']') {            const tmp_num = stack_num.pop();            res = stack.pop() + res.repeat(tmp_num);;        } else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {            num = num * 10 + parseInt(ch);        } else {            res+=ch;        }    }    return res;};\n1702.修改后的最大二进制字符串题目：\n给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：操作 1 ：如果二进制串包含子字符串 “00” ，你可以用 “10” 将其替换。比方说， “00010” -&gt; “10010”操作 2 ：如果二进制串包含子字符串 “10” ，你可以用 “01” 将其替换。比方说， “00010” -&gt; “00001”请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。\n\n解析：\n思路就是二进制前面00越多越好，00可以由操作2构造出来，例如01110，可以用操作2把后面的0冒泡式往前推，变成00111，然后替换成10111\n/** * @param {string} binary * @return {string} */var maximumBinaryString = function (binary) {    let res = binary.split(\"\");    for (let i = 0,j=0; i &lt; res.length; i++) {        if (res[i] == \"0\") {            //找到当前0之后第一次出现0的位置            //然后可以冒泡式把0往前推            while(j&lt;=i||(j&lt;res.length&amp;&amp;res[j]==\"1\")){                j++;            }            if(j&lt;res.length){                res[j]=\"1\";                res[i]=\"1\";                res[i+1]=\"0\";            }        }    }    return res.join(\"\");};\n进一步思考，最后的结果应该最多只有1个0，有两个0或以上就可以变成10的模式减少0，所以只需要知道第一次出现0的位置就可以构造答案\n/** * @param {string} binary * @return {string} */var maximumBinaryString = function (binary) {    const n = binary.length;    const i = binary.indexOf('0');    if (i &lt; 0) {        return binary;    }    //有多少个0，结果0就要往后移几-1位    const zeros = binary.split('0').length - 1;    const res = Array(n).fill('1');    res[i + zeros - 1] = '0';    return res.join('');};\n1657.确定两个字符串是否接近题目：\n如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：操作 1：交换任意两个 现有 字符。例如，abcde -&gt; aecdb操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）你可以根据需要对任意一个字符串多次使用这两种操作。给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。\n\n解析：\n题目的意思是只要两个字符串出现过的字母相同，出现过的次数相同，就是接近\n/** * @param {string} word1 * @param {string} word2 * @return {boolean} */var closeStrings = function (word1, word2) {    if (word1.length != word2.length) {        return false;    }    const set1=new Array(26).fill(0);    const set2=new Array(26).fill(0);    for(let i=0;i&lt;word1.length;i++){        set1[word1.charCodeAt(i)-'a'.charCodeAt()]++;        set2[word2.charCodeAt(i)-'a'.charCodeAt()]++;    }    for(let i=0;i&lt;26;i++){        if((set1[i]===0)!==(set2[i]===0)){            return false;        }    }    set1.sort((a, b) =&gt; a - b);    set2.sort((a, b) =&gt; a - b);    //这里被坑了一下不能用==或者===来判断，因为判断的是引用而不是数组内容    return set1.toString()==set2.toString();};\n2352.相等行列对题目：\n给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。\n\n解析：\n哈希表，就是把每一行转成string都存进哈希表里，然后遍历列对应查找\n/** * @param {number[][]} grid * @return {number} */var equalPairs = function(grid) {    const len=grid.length;    const hash={};    for(const row of grid){        const rowStr=row.toString();        hash[rowStr]=(hash[rowStr]||0)+1;    }    let res=0;    for(let i=0;i&lt;len;i++){        let col=[];        for(let j=0;j&lt;len;j++){            col.push(grid[j][i]);        }        if(hash[col.toString()]){            res+=hash[col.toString()];        }    }    return res;};\n1161.最大层内元素和题目：\n给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。\n\n解析：\n\ndfs\n\n带层号进行深度遍历\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number} */var maxLevelSum = function(root) {    const sum=[];    const dfs=(node,level)=&gt;{        if(level==sum.length){            sum.push(node.val);        }else{            sum[level]+=node.val;        }        if(node.left){            dfs(node.left,level+1);        }        if(node.right){            dfs(node.right,level+1);        }    }    dfs(root,0);    let idx=0;    for(let i=0;i&lt;sum.length;i++){        if(sum[i]&gt;sum[idx]){            idx=i;        }    }    return idx+1;};\n\nbfs\n\n记录一下每层的和\nvar maxLevelSum = function (root) {    let maxsum=root.val;    let q = [];    q.push(root);    let maxlevel=1,level=1;    while (q.length) {        let sum=0,len=q.length;        for (let i = 0; i &lt; len; i++) {            const node = q.shift();            sum += node.val;            if (node.left) {                q.push(node.left);            }            if (node.right) {                q.push(node.right);            }        }        if(sum&gt;maxsum){            maxlevel=level;            maxsum=sum;        }        level++;    }    return maxlevel;};\n328.奇偶链表题目：\n给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。\n\n解析：\n链表的题主要是要画图，这里额外使用奇偶两个指针，遍历一次把奇偶节点分开，然后再拼接\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var oddEvenList = function(head) {    if(head==null||head.next==null){        return head;    }    let evenhead=head.next;    let odd=head,even=head.next;    while(even!=null&amp;&amp;even.next!=null){        odd.next=even.next;        odd=odd.next;        even.next=odd.next;        even=even.next;    }    odd.next=evenhead;    return head;};\n2130.链表最大孪生和题目：\n在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;= i &lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。孪生和 定义为一个节点和它孪生节点两者值之和。给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。\n\n解析：\n快慢指针先找到后一半的起始节点，然后翻转前一半的节点\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {number} */var pairSum = function(head) {    let s=head,f=head.next;    while(f.next!=null){        s=s.next;        f=f.next.next;    }    let head1 =s.next;    s.next=null;    const reverseList = function(head) {    let prev = null;    let curr = head;    while (curr) {        const next = curr.next;        curr.next = prev;        prev = curr;        curr = next;    }    return prev;    };    let head2=reverseList(head);    let max=0;    while(head1!=null){        max=Math.max(head1.val+head2.val,max);        head1=head1.next;        head2=head2.next;    }    return max;};\n547.省份数量题目：\n有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量。\n\n解析：\n\ndfs其实就是查找图里有多少连通的集合\n\n/** * @param {number[][]} isConnected * @return {number} */var findCircleNum = function (isConnected) {    let provinces = 0;    let vis = new Set();    let cities = isConnected.length;    const dfs = (isConnected, vis, cities, i) =&gt; {        for (let j = 0; j &lt; cities; j++) {            if (isConnected[i][j] == 1 &amp;&amp; !vis.has(j)) {                vis.add(j);                dfs(isConnected, vis, cities, j);            }        }    }    for (let i = 0; i &lt; cities; i++) {        if (!vis.has(i)) {            dfs(isConnected, vis, cities, i);            provinces++;        }    }        return provinces;};\n\nbfs\n\n/** * @param {number[][]} isConnected * @return {number} */var findCircleNum = function (isConnected) {    let provinces = 0;    let vis = new Set();    let cities = isConnected.length;    let queue=[];    for (let i = 0; i &lt; cities; i++) {        if (!vis.has(i)) {            queue.push(i);            //这里只有一个while的原因是没有同一时刻的要求，只要联通就可以算作一个省            while(queue.length){                const city=queue.shift();                vis.add(city);                for(let j=0;j&lt;cities;j++){                    if(isConnected[city][j]==1&amp;&amp;!vis.has(j)){                        queue.push(j);                    }                }            }            provinces++;        }    }        return provinces;};\n1926.迷宫中离入口最近的出口题目：\n给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 ‘.’ 表示）和墙（用 ‘+’ 表示）。同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。\n\n解析：\n应该是广度优先，遍历到边界就证明有出口，这里可以注意一下写法，把行列变化量作为数组，不然容易太多数组加减\n/** * @param {character[][]} maze * @param {number[]} entrance * @return {number} */var nearestExit = function (maze, entrance) {    let queue = [];    let move = [[0, -1], [-1, 0], [0, 1], [1, 0]];    let rows = maze.length, cols = maze[0].length;    maze[entrance[0]][entrance[1]] = \"+\";    queue.push([...entrance,0]);    while (queue.length) {        let [i, j,step] = queue.shift();        for (let m of move) {            let curi = m[0] + i, curj = m[1] + j;            if (curi &gt;= 0 &amp;&amp; curi &lt; rows &amp;&amp; curj &gt;= 0 &amp;&amp; curj &lt; cols &amp;&amp; maze[curi][curj] == \".\") {                if (curi == 0 || curi == rows - 1 || curj == 0 || curj == cols - 1) {                    return step + 1;                }                maze[curi][curj] = \"+\";                queue.push([curi, curj,step+1]);            }        }    }    return -1;};\n/** * @param {character[][]} maze * @param {number[]} entrance * @return {number} */var nearestExit = function (maze, entrance) {    let queue = [];    let move = [[0, -1], [-1, 0], [0, 1], [1, 0]];    let rows = maze.length, cols = maze[0].length;    let step = 0;    queue.push(entrance);    while (queue.length) {        let len = queue.length;        //这里要有另外一个while的主要原因是不同路径是同一时刻延伸的，所以每一分钟都必须清空queue里所有值，再进入下一分钟        while (len--) {            let [i, j] = queue.shift();            maze[i][j] = \"+\";            for (let m of move) {                let curi = m[0] + i, curj = m[1] + j;                if (curi &gt;= 0 &amp;&amp; curi &lt; rows &amp;&amp; curj &gt;= 0 &amp;&amp; curj &lt; cols &amp;&amp; maze[curi][curj] == \".\") {                    if (curi == 0 || curi == rows - 1 || curj == 0 || curj == cols - 1) {                        return step + 1;                    }                    maze[curi][curj] = \"+\";                    queue.push([curi, curj]);                }            }        }        step++;    }    return -1;};\n\n接算法笔记（四）~","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"计算机网络","url":"/2024/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"","categories":["技术学习","八股文"],"tags":["计算机网络"]},{"title":"算法学习笔记（四）","url":"/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（三），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \nLeetCode75完结！\n题库LeetCode75本题库涉及到的知识点一览\n\n[x] 数组 / 字符串\n[x] 双指针\n[x] 滑动窗口\n[x] 前缀和\n[x] 哈希表 / 哈希集合\n[x] 栈\n[x] 队列\n[x] 链表\n[x] 二叉树 - 深度优先搜索\n[x] 二叉树 - 广度优先搜索\n[x] 二叉搜索树\n[x] 图 - 深度优先搜索\n[x] 图 - 广度优先搜索\n[x] 堆 / 优先队列\n[x] 二分查找\n[x] 回溯\n[x] 动态规划 - 一维\n[x] 动态规划 - 多维\n[x] 位运算\n[x] 前缀树\n[x] 区间集合\n[x] 单调栈\n\n\n198.打家劫舍题目：\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n解析：\n经典dp，状态方程dp[i]=max(dp[i-2]+nums[i],dp[i-1])\n//copy灵神极致简洁代码var rob = function (nums) {    let f0 = 0, f1 = 0;    for (const x of nums) {        [f0, f1] = [f1, Math.max(f1, f0 + x)]    }    return f1;};\n431.路径求和Ⅲ题目：\n给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n解析：\n我的想法是先用dfs遍历，然后每个节点记录一下当前位置到根节点的路径上所有节点和，就是前缀和，但是没想好怎么用数据结构存储前缀和以及怎么确定节点是某一个节点的祖先。看了官解，用的是Map，记录的不是节点，而是某一个前缀和出现的次数，每次遍历了一个节点的路径会恢复状态查询其他路径\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @param {number} targetSum * @return {number} */var pathSum = function(root, targetSum) {    let presum=new Map();    presum.set(0,1);    const dfs=(root,presum,targetSum,cur)=&gt;{        if(root==null){            return 0;        }        let res=0;        cur+=root.val;        //查找是否有符合的前缀和        res=presum.get(cur-targetSum)||0;        presum.set(cur,(presum.get(cur)||0)+1);        res+=dfs(root.left,presum,targetSum,cur)+dfs(root.right,presum,targetSum,cur);        //这里是把下面所有节点遍历后，恢复原来状态，搜索其他路径        presum.set(cur,presum.get(cur)-1);        return res;    }    return dfs(root,presum,targetSum,0);};\n236.二叉树的最近公共祖先题目：\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n解析：\n本题在于递归的思路若 root 是 p,q的 最近公共祖先 ，那么只有三种情况p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；p=root ，且 q 在 root的左或右子树中；q=root ，且 p 在 root 的左或右子树中；\n先自顶向下遍历，遇到节点p或者q返回，然后自底向上回溯，第一个符合的root就是最近公共祖先\nvar lowestCommonAncestor = function (root, p, q) {    if (root == null || root == p || root == q) {        return root;    }    const left = lowestCommonAncestor(root.left, p, q);    const right = lowestCommonAncestor(root.right, p, q);    //p 和 q 都不在 root 的子树中，继续向上回溯    if(left==null&amp;&amp;right==null){        return null;    }    //左子树为空，那么p和q肯定在右子树里(一个在或者都在)    if(left==null){        return right;    }    //右子树为空，那么p和q肯定在左子树里(一个在或者都在)    if(right==null){        return left;    }    //p 和 q 在 root 的子树中    return root; };\n994.腐烂的橘子题目：\n在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n\n解析：\nbfs，和1926的迷宫很像，但是要注意这两个题都是同一时刻多点进行bfs，不一定是一条路径上或者联通的，所以要有两个while，第二个while是用于清空每一时刻queue里的值，这些是同时发生的\n/** * @param {number[][]} grid * @return {number} */var orangesRotting = function (grid) {    const direction = [[0, -1], [-1, 0], [0, 1], [1, 0]];    let queue = [];    let fresh = 0;    let rows = grid.length, cols = grid[0].length;    for (let i = 0; i &lt; rows; i++) {        for (let j = 0; j &lt; cols; j++) {            if (grid[i][j] == 1) {                fresh++;            }            if (grid[i][j] == 2) {                queue.push([i, j]);            }        }    }    let minutes = 0;    while (queue.length != 0 &amp;&amp; fresh) {        let len = queue.length;        //这里一定要注意把queue当前的长度抽取出来，这是把同一分钟的腐烂橘子都一起向四周污染，如果不单独while的话会漏掉同一时间的腐烂橘子        while (len--) {            let cur = queue.shift();            for (dir of direction) {                let curi = dir[0] + cur[0], curj = dir[1] + cur[1];                if (curi &gt;= 0 &amp;&amp; curi &lt; rows &amp;&amp; curj &gt;= 0 &amp;&amp; curj &lt; cols &amp;&amp; grid[curi][curj] == 1) {                    grid[curi][curj] = 2;                    queue.push([curi, curj]);                    fresh--;                }            }        }        minutes++;    }    return fresh == 0 ? minutes : -1;};\n2009.使数组连续的最少操作数题目：\n给你一个整数数组 nums 。每一次操作中，你可以将 nums 中 任意 一个元素替换成 任意 整数。如果 nums 满足以下条件，那么它是 连续的 ：nums 中所有元素都是 互不相同 的。nums 中 最大 元素与 最小 元素的差等于 nums.length - 1 。比方说，nums = [4, 2, 5, 3] 是 连续的 ，但是 nums = [1, 2, 3, 5, 6] 不是连续的 。请你返回使 nums 连续 的 最少 操作次数。\n\n解析：\n滑动窗口问题，先排序，再每个数字都作为最小值试一下最少的操作数\nvar minOperations = function(nums) {    const n = nums.length;    const sortedUniqueNums = [...new Set(nums)];    sortedUniqueNums.sort((a, b) =&gt; a - b);    let res = n;    let j = 0;    for (let i = 0; i &lt; sortedUniqueNums.length; i++) {        const left = sortedUniqueNums[i];        const right = left + n - 1;        while (j &lt; sortedUniqueNums.length &amp;&amp; sortedUniqueNums[j] &lt;= right) {            res = Math.min(res, n - (j - i + 1));            j++;        }    }    return res;};\n1766.互质树题目：\n给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。\n\n解析：\ndfs，先暴力得到1-50内所有互质的元素集合gcds，然后后面对节点dfs，比较当前值gcds数组元素是否已经在前面的祖先节点出现过，然后再把当前的值对应位置存入tmp中\nvar getCoprimes = function(nums, edges) {    const n = nums.length;    const gcds = Array.from({ length: 51 }, () =&gt; []);    const tmp = Array.from({ length: 51 }, () =&gt; []);    const ans = Array(n).fill(-1);    const dep = Array(n).fill(-1);    const g = Array.from({ length: n }, () =&gt; []);    function gcd(a, b) {        while (b !== 0) {            [a, b] = [b, a % b];        }        return a;    }    function dfs(x, depth) {        dep[x] = depth;        for (const val of gcds[nums[x]]) {            if (tmp[val].length === 0) continue;            const las = tmp[val][tmp[val].length - 1];            if (ans[x] === -1 || dep[las] &gt; dep[ans[x]]) {                ans[x] = las;            }        }        //遍历过就把当前值对应的位置存进tmp，后面找互质就直接找的等于该值的最后一个位置，也就是最近祖先        tmp[nums[x]].push(x);        for (const val of g[x]) {            if (dep[val] === -1) { // 被访问过的点dep不为-1                dfs(val, depth + 1);            }        }        //边没有指明方向，所以回溯的时候要把当前的弹出来        tmp[nums[x]].pop();    }    // 初始化    for (let i = 1; i &lt;= 50; i++) {        for (let j = 1; j &lt;= 50; j++) {            if (gcd(i, j) === 1) {                gcds[i].push(j);            }        }    }    //这里是因为不知道边的方向，要等到遍历的时候才知道    for (const [x, y] of edges) {        g[x].push(y);        g[y].push(x);    }    dfs(0, 1);    return ans;};\n1372.二叉树中的最长交错路径题目：\n给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：选择二叉树中 任意 节点和一个方向（左或者右）。如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。改变前进方向：左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。请你返回给定树中最长 交错路径 的长度。\n\n解析：\n难得纯自己写了一次超越100%，思路蛮简单的，就是dfs，每个节点判断一下是向左还是向右，记录长度最大值即可\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number} */var longestZigZag = function(root) {    let max=0;    const dfs=(root,len,dir)=&gt;{        max=Math.max(max,len);        if(dir==\"left\"&amp;&amp;root.left!=null){            dfs(root.left,len+1,\"right\");        }        if(dir==\"right\"&amp;&amp;root.right!=null){            dfs(root.right,len+1,\"left\");        }        if(dir==\"left\"&amp;&amp;root.right!=null){            dfs(root.right,1,\"left\");        }        if(dir==\"right\"&amp;&amp;root.left!=null){            dfs(root.left,1,\"right\");        }    }    dfs(root,0,\"left\");    dfs(root,0,\"right\");    return max;};\n1466.重新规划路线题目：\nn 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。路线用 connections 表示，其中 connections[i] = [a, b] 表示从城市 a 到 b 的一条有向路线。今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。\n\n解析：\n这个题目就是把有向图变成以城市0为根的树，每个节点遍历能不能到城市0不好做，改成反向城市0能不能遍历到所有节点，能遍历过去的边代表实际中要反向，累加一下返回即可\n/** * @param {number} n * @param {number[][]} connections * @return {number} */var minReorder = function(n, connections) {    const graph=new Array(n).fill(0).map(()=&gt;new Array());    for(const edge of connections){        //这里按照一个点能到达所有点来构造邻接表        //正向到达被记为1，反向为0(后面要累积正向的)        graph[edge[0]].push([edge[1],1]);        graph[edge[1]].push([edge[0],0]);    }    const dfs=(cur,parent)=&gt;{        let res=0;        //对于当前节点遍历以其为起点的所有边        for(const edge of graph[cur]){            //如果当前边的终点是当前节点的父节点，证明已访问过，跳过，进入下一循环            if(edge[0]==parent){                continue;            }            //正向到达的实际上需要反向，所以累计加            //递归访问当前边的终点节点            res+=edge[1]+dfs(edge[0],cur);        }        return res;    }    return dfs(0,-1);};\n399.除法求值题目：\n给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。\n\n解析：\n这道题像是hard的medium\n\n建表把所有的点建模成一张图，边代表两个变量的比值\n\nvar calcEquation = function(equations, values, queries) {    let nvars = 0;    const variables = new Map();    //这一步是把字母先映射成数字    const n = equations.length;    for (let i = 0; i &lt; n; i++) {        if (!variables.has(equations[i][0])) {            variables.set(equations[i][0], nvars++);        }        if (!variables.has(equations[i][1])) {            variables.set(equations[i][1], nvars++);        }    }    // 对于每个点，存储其直接连接到的所有点及对应的权值    const edges = new Array(nvars).fill(0);    for (let i = 0; i &lt; nvars; i++) {        edges[i] = [];    }    for (let i = 0; i &lt; n; i++) {        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);        edges[va].push([vb, values[i]]);        edges[vb].push([va, 1.0 / values[i]]);    }    const queriesCount = queries.length;    const ret = [];    for (let i = 0; i &lt; queriesCount; i++) {        const query = queries[i];        let result = -1.0;        if (variables.has(query[0]) &amp;&amp; variables.has(query[1])) {            const ia = variables.get(query[0]), ib = variables.get(query[1]);            if (ia === ib) {                result = 1.0;            } else {                const points = [];                points.push(ia);                const ratios = new Array(nvars).fill(-1.0);                ratios[ia] = 1.0;                while (points.length &amp;&amp; ratios[ib] &lt; 0) {                    const x = points.pop();                    for (const [y, val] of edges[x]) {                        if (ratios[y] &lt; 0) {                            ratios[y] = ratios[x] * val;                            points.push(y);                        }                    }                }                result = ratios[ib];            }        }        ret[i] = result;    }    return ret;};\n\nFloyd算法优化查询次数\n\nvar calcEquation = function(equations, values, queries) {    let nvars = 0;    const variables = new Map();    const n = equations.length;    for (let i = 0; i &lt; n; i++) {        if (!variables.has(equations[i][0])) {            variables.set(equations[i][0], nvars++);        }        if (!variables.has(equations[i][1])) {            variables.set(equations[i][1], nvars++);        }    }    const graph = new Array(nvars).fill(0).map(() =&gt; new Array(nvars).fill(-1.0));    for (let i = 0; i &lt; n; i++) {        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);        graph[va][vb] = values[i];        graph[vb][va] = 1.0 / values[i];    }    for (let k = 0; k &lt; nvars; k++) {        for (let i = 0; i &lt; nvars; i++) {            for (let j = 0; j &lt; nvars; j++) {                if (graph[i][k] &gt; 0 &amp;&amp; graph[k][j] &gt; 0) {                    graph[i][j] = graph[i][k] * graph[k][j];                }            }        }    }    const queriesCount = queries.length;    const ret = new Array(queriesCount).fill(0);    for (let i = 0; i &lt; queriesCount; i++) {        const query = queries[i];        let result = -1.0;        if (variables.has(query[0]) &amp;&amp; variables.has(query[1])) {            const ia = variables.get(query[0]), ib = variables.get(query[1]);            if (graph[ia][ib] &gt; 0) {                result = graph[ia][ib];            }        }        ret[i] = result;    }    return ret;};\n2923.找到冠军题目：\n一场比赛中共有 n 支队伍，按从 0 到  n - 1 编号。给你一个下标从 0 开始、大小为 n * n 的二维布尔矩阵 grid 。对于满足 0 &lt;= i, j &lt;= n - 1 且 i != j 的所有 i, j ：如果 grid[i][j] == 1，那么 i 队比 j 队 强 ；否则，j 队比 i 队 强 。在这场比赛中，如果不存在某支强于 a 队的队伍，则认为 a 队将会是 冠军 。返回这场比赛中将会成为冠军的队伍。\n\n解析：\n本来只是个简单题，但是我觉得打擂台的思路很巧妙，记录一下。不用打擂台的话，有两种解法，i行的行和为n-1，代表i是冠军；j列中没有1，代表j是冠军\n打擂台：假设冠军是 champ=0，我们从 i=1 开始遍历，寻找可以击败 cham的队伍，也就是 grid[i][champ]=1。\n如果没有出现 grid[i][champ]=1，那么答案就是 champ，否则冠军可能是 i，更新 champ=i。然后从 i+1 继续向后遍历，因为 [1,i−1]中没有比 0 强的队，更别说比 i 强了。重复上述过程，最后返回 champ。\n/** * @param {number[][]} grid * @return {number} */var findChampion = function(grid) {    let champ=0;    for(let i=1;i&lt;grid.length;i++){        if(grid[i][champ]){            champ=i;        }    }    return champ;};\n162.寻找峰值题目：\n峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。你可以假设 nums[-1] = nums[n] = -∞ 。你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n\n解析：\n时间复杂度为 O(log n)一出，肯定是二分法，学一下爬坡法\n在 [0,n) 的范围内随机一个初始位置 i，随后根据 nums[i−1],nums[i],nums[i+1]三者的关系决定向哪个方向走：\n如果 nums[i−1]nums[i+1]，那么位置 i 就是峰值位置，可以直接返回 i 作为答案；\n如果 nums[i−1]&lt;nums[i]&lt;nums[i+1]，那么位置 i 处于上坡，需要往右走，即 i←i+1；\n如果 nums[i−1]&gt;nums[i]&gt;nums[i+1]，那么位置 i 处于下坡，需要往左走，即 i←i−1；\n如果 nums[i−1]&gt;nums[i]&lt;nums[i+1]，那么位置 i 位于山谷，两侧都是上坡，可以朝任意方向走。\n爬坡法为什么一定能找到山峰呢，一种通俗的理解是中点所在地方，可能是某座山的山峰，山的下坡处，山的上坡处，如果是山峰，最后会二分终止也会找到，关键是二分方向，并不知道山峰在我们左边还是右边，如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界。但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰，总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有。\n二分法最要注意的是区间问题，l和r带不带等号，mid+1还是-1，建议现场画图\n/** * @param {number[]} nums * @return {number} */var findPeakElement = function(nums) {    let l=0,r=nums.length-1;    while(l&lt;r){        let mid=Math.floor((l+r)/2);        if(nums[mid]&gt;nums[mid+1]){            r=mid;        }else{            l=mid+1;        }    }    return r;};\n2300.咒语和药水的成功对数题目：\n峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。你可以假设 nums[-1] = nums[n] = -∞ 。你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n\n解析：\n注意一下二分的开闭区间问题\n这里整理一下二分区间常见写法\n\n[left, right]\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] &gt; target) {                right = middle - 1; // target 在左区间，所以[left, middle - 1]            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }\n\n[left, right)\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            int middle = left + ((right - left) &gt;&gt; 1);            if (nums[middle] &gt; target) {                right = middle; // target 在左区间，在[left, middle)中            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }\n/** * @param {number[]} spells * @param {number[]} potions * @param {number} success * @return {number[]} */var successfulPairs = function(spells, potions, success){    potions.sort((a,b)=&gt;a-b);    const binarySearch=(l,r,nums,target)=&gt;{        let res=r+1;        while(l&lt;=r){            const mid=Math.floor((l+r)/2);            if(nums[mid]&gt;target){                res=mid;                r=mid-1;            }else{                l=mid+1;            }        }        return res;    }    return spells.map((item) =&gt; {        return potions.length - binarySearch( 0, potions.length - 1, potions,(success - 1) / item)    })};\n790.多米诺和托米诺平铺题目：\n有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。\n\n解析：\n\ndp这个方法得配图解释在第 i 列前面的正方形都被瓷砖覆盖，在第 i 列后面的正方形都没有被瓷砖覆盖（i 从 1 开始计数）。那么第 i 列的正方形有四种被覆盖的情况：\n\n一个正方形都没有被覆盖，记为状态 0；\n只有上方的正方形被覆盖，记为状态 1；\n只有下方的正方形被覆盖，记为状态 2；\n上下两个正方形都被覆盖，记为状态 3。\n使用 dp[i][s] 表示平铺到第 i 列时，各个状态 s 对应的平铺方法数量。考虑第 i−1列和第 i 列正方形，它们之间的状态转移如下图（红色条表示新铺的瓷砖）：\n\nvar numTilings = function(n) {    const mod = 1e9 + 7;    const dp = new Array(n + 1).fill(0).map(() =&gt; new Array(4).fill(0));    dp[0][3] = 1;    for (let i = 1; i &lt;= n; i++) {        dp[i][0] = dp[i - 1][3];        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % mod;        dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % mod;    }    return dp[n][3];};\n\n规律\n\n\n/** * @param {number} n * @return {number} */var numTilings = function(n) {    const mod = 1e9 + 7;    if (n == 1) return 1;        let f = new Array(n + 1);        f[0] = f[1] = 1;        f[2] = 2;        for (let i = 3; i &lt;= n; ++i)            f[i] = (f[i - 1] * 2 + f[i - 3]) % mod;        return f[n];};\n1143.最长公共子序列题目：\n给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n\n解析：\n经典dp\ndp[i][j] 表示 text1[0:i]和 text2[0:j]的最长公共子序列的长度\n状态转移方程：\n\n/** * @param {string} text1 * @param {string} text2 * @return {number} */var longestCommonSubsequence = function(text1, text2) {    let dp=new Array(text1.length+1).fill(0).map(()=&gt;new Array(text2.length+1).fill(0));    for(let i=1;i&lt;=text1.length;i++){        const ch=text1[i-1];        for(let j=1;j&lt;=text2.length;j++){            if(ch==text2[j-1]){                dp[i][j]=dp[i-1][j-1]+1;            }else{                dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);            }        }    }    return dp[text1.length][text2.length];};\n714.买卖股票的最佳时机含手续费题目：\n给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n解析：\n\ndp\n\n定义状态 dp[i][0]表示第 iii 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。\ndp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]−fee}dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}\n/** * @param {number[]} prices * @param {number} fee * @return {number} */var maxProfit = function (prices, fee) {    let dp = new Array(prices.length).fill(0).map(() =&gt; new Array(2).fill(0));    dp[0][0] = 0;    dp[0][1] = -prices[0];    for (let i = 1; i &lt; prices.length; i++) {        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    }    return dp[prices.length - 1][0];};//优化一下空间var maxProfit = function (prices, fee) {    [sell,buy]= [0, -prices[0]];    for (let i = 1; i &lt; prices.length; i++) {        [sell,buy] = [Math.max(sell, buy + prices[i] - fee),Math.max(buy, sell - prices[i])];    }    return sell;};\n\n贪心\n\n不关心买卖的具体时间，只讲求每天的净利润最大\nvar maxProfit = function(prices, fee) {    const n = prices.length;    // 记录买入最低价格（加了手续费）    let buy = prices[0] + fee;    let profit = 0;    for (let i = 1; i &lt; n; i++) {        //当前价格比之前买入时低，所以现在再买        if (prices[i] + fee &lt; buy) {            buy = prices[i] + fee;        } //当前价格比买入高，先假装卖掉        else if (prices[i] &gt; buy) {            profit += prices[i] - buy;            buy = prices[i];        }        //其余情况不动    }    return profit;};\n2542.最大子序列的分数题目：\n给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两者长度都是 n ，再给你一个正整数 k 。你必须从 nums1 中选一个长度为 k 的 子序列 对应的下标。对于选择的下标 i_0 ，i_1 ，…， i_{k - 1} ，你的 分数 定义如下：nums1 中下标对应元素求和，乘以 nums2 中下标对应元素的 最小值 。用公式表示： 。请你返回 最大 可能的分数。一个数组的 子序列 下标是集合 {0, 1, …, n-1} 中删除若干元素得到的剩余集合，也可以不删除任何元素。\n\n解析：\n这题关键在怎么遍历两个数组可以保证遍历次数最少，这里先把要算最小值的nums2降序排列，保证nums2是从大到小一个一个遍历的，然后对nums1使用最小堆，保证每一次遍历sum一定会比之前的sum更大\n/** * @param {number[]} nums1 * @param {number[]} nums2 * @param {number} k * @return {number} */var maxScore = function(nums1, nums2, k) {    const n = nums1.length;    const ids = [...Array(n).keys()];    // 对下标排序，不影响原数组的顺序    //这里先把nums2从大到小排序，选取前k个，这时的nums2[ids[k-1]]就是前k个中最小的    ids.sort((i, j) =&gt; nums2[j] - nums2[i]);    const pq = new MinPriorityQueue();    let sum = 0;    //这里按照nums2的下标计算nums1对应的和，并把nums1对应下标的每个元素入最小堆    for (let i = 0; i &lt; k; i++) {        sum += nums1[ids[i]];        pq.enqueue(nums1[ids[i]]);    }    //对下标数组k之后进行遍历，如果后面下标对应的nums1的值大于当前和的最小堆的最小值，就替换最小值，比较更改后的乘积是否会更大    let ans = sum * nums2[ids[k - 1]];    for (let i = k; i &lt; n; i++) {        const x = nums1[ids[i]];        if (x &gt; pq.front().element) {            sum += x - pq.dequeue().element;            pq.enqueue(x);            ans = Math.max(ans, sum * nums2[ids[i]]);        }    }    return ans;};\n2462.雇佣k位工人的总代价题目：\n给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。比方说，costs = [3,2,7,7,1,2] 且 candidates = 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。一位工人只能被选择一次。返回雇佣恰好 k 位工人的总代价。\n\n解析：\n注意一下这个candidates是指从前数candidates个元素和从后数candidates个元素找这两个里面的最小值，所以用两个最小堆\n/** * @param {number[]} costs * @param {number} k * @param {number} candidates * @return {number} */var totalCost = function(costs, k, candidates) {    let left = new MinPriorityQueue();    let right = new MinPriorityQueue();    let i = 0;    let j = costs.length - 1;    let ans = 0;    while (k--) {        while (i &lt;= j &amp;&amp; left.size() &lt; candidates) {            left.enqueue(costs[i++]);        }        while (i &lt;= j &amp;&amp; right.size() &lt; candidates) {            right.enqueue(costs[j--]);        }        let min1 = left.size() &gt; 0 ? left.front().element : Infinity;        let min2 = right.size() &gt; 0 ? right.front().element : Infinity;        if (min1 &lt;= min2) {            ans += left.dequeue().element;        } else {            ans += right.dequeue().element;        }    }    return ans;};\n\n力扣75堂堂完结","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"李白，与大众想象相差不止三万里","url":"/2023/07/11/%E9%95%BF%E5%AE%89%E4%B8%89%E4%B8%87%E9%87%8C/","content":"首发知乎\n也是搬运的去年的影评，哈哈哈，今年还没遇到值得写的长影评\n因为这部电影李白的形象很有争议，我在这里补充说明一下我的看法。我一直主张作品和人需要分开，不能因为一个人的作品足够优秀就认为其人也如作品一样优秀。这个世上有很多天才，但很少有全才。李白的诗歌成就让他名垂青史，但也必须承认除去诗歌才华的他只是一个普通人，也会有世俗的行为和坎坷的经历。\n你可以只爱李白的诗歌，或者能够接受真实李白不完美的一面而爱李白这个人，但不要只读了部分作品就来神化李白的一切行为，这样和某些饭圈粉丝的极端追星行为有什么区别。\n&nbsp;\n\n&nbsp;\n看完长安三万里，火速来影评。\n这部电影并不是传统的商业片，而更像是一部浓缩唐史的纪录片。我之前一直觉得追光只重视画面视效，而不重视剧本。这一次直接选择改编历史，算是弥补了一直以来的剧本缺陷。在视效方面将不少经典诗词用瑰丽的画面呈现了出来，当那些历史中的人物一个一个走出书本，心中还是很感慨。我看完的后想到了一句话你年少读过的诗词，在未来才会产生共鸣。追光这次的建模也更贴近现实中的普通人以及史书画像的形象，没有像杨戬那样精致帅气的模型，大概是想表达希望观众更注重剧情本身，多增加一些历史感（不过这样会少一大批冲着颜值看电影的观众）。\n首先谈谈关键人物李白。我中学时非常喜欢李白的诗词，在我心中他一直是丰神俊逸、放浪形骸、自信豁达的形象，但是在我真的去了解历史上的李白之后，他的形象瞬间崩塌，从云游四海浪漫随性的谪仙人落到了恃才傲物却无政治才能的失意之人。你会发现李白两次婚姻都是入赘，风流韵事颇多，用现代思维来看不仅吃软饭还是渣男；他虽然多次在诗歌中抒发政治理想，但更多只是空有辞藻而无实用；他留下过“安能摧眉折腰事权贵”的豪言壮语，但也给杨贵妃写过极尽谄媚的清平调……说到底真实的他入世仕途不顺，出世也得道未果。但是这些让李白从一个虚幻飘渺的诗仙具象化成了更真实更鲜活的人，离我们这些普通人更近。当了解了真实的李白，再看他的诗词反而让我能走进李白的内心，读诗时也不再只停留在浪漫的意境和瑰丽的想象，能够窥见背后的深意，读懂那个“痛饮狂歌空度日，飞扬跋扈为谁雄”的李白。&nbsp;\n长安三万里给我的感觉也类似如此，他从高适的视角出发，塑造了一个既洒脱不羁才华横溢又失意落魄的形象，矛盾但却很立体丰满。我知道这部电影肯定会打破很多人心中李白的形象，但我想说一方面真实的李白确实如此，一方面电影中是描绘相对平庸但勤奋刻苦的高适心中的李白形象，高适内心对李白的部分个性和行为其实不太认可，在他的回忆中自然会对李白一些行为呈现出否定态度，这也会间接影响到观众对于李白的看法。然后历史上的高适一直因为没有救好友李白遭人诟病，电影中结尾有借他人之口试图为高适解释，不过高适也没回应，这一点改编见仁见智。\n在电影中，导演有意将李白作为大唐的一个化身，在李白身上浓缩了一部由盛转衰的厚重唐史。青年和中年李白身负才气恣意欢愉，正如盛唐，但当繁华转瞬而逝，安史之乱让大厦一夜倾塌，老年李白也意气不再令人惋惜。我个人认为这部分拍的还不错，能够让观众身临其境体会历史风云变幻。&nbsp;\n不论这部电影是还原历史也好，亦或是改编人物也罢，后世的评价都不会影响李白半分。李白无需洗白，亦不会为人抹黑，他有自己鲜活跌宕的人生和纵横后世的才华，这是属于他的万里长安。\n虽然电影会偏历史纪录片向，但其实多数诗句都是义务教育阶段都接触过的，当银幕上出现一首首诗篇时，被牵动的不仅是中学阶段语文课的回忆，更是每个华夏儿女骨子里文化传承的底蕴，非常推荐大家去看看。\n最后，关于李白最好的形象概括，我想起了在中学期间就很喜欢的余光中的诗《寻李白》，我至今都认为是对李白形象最好的描述。\n&nbsp;\n寻李白\n——痛饮狂歌空度日 飞扬跋扈为谁雄\n余光中\n那一双傲慢的靴子至今还落在\n高力士羞愤的手里，人却不见了\n把满地的难民和伤兵\n把胡马和羌笛交践的节奏\n留给杜二去细细的苦吟\n自从那年贺知章眼花了\n认你做谪仙，便更加佯狂\n用一只中了魔咒的小酒壶\n把自己藏起来，连太太也寻不到你\n怨长安城小而壶中天长\n在所有的诗里你都预言\n会突然水遁，或许就在明天\n只扁舟破浪，乱发当风\n——而今，果然你失了踪\n树敌如林，世人皆欲杀\n肝硬化怎杀得死你\n酒入豪肠，七分酿成了月光\n余下的三分啸成剑气\n绣口一吐，就半个盛唐\n从开元到天宝，从洛阳到咸阳\n冠盖满途车骑的嚣闹\n不及千年后你的一首\n水晶绝句轻叩我额头\n当地一弹挑起的回音\n一贬世上已经够落魄\n再放夜郎毋乃太难堪\n至今成谜是你的籍贯\n陇西或山东，青莲乡或碎叶城\n不如归去归哪个故乡\n凡你醉处，你说过，皆非他乡\n失踪，是天才唯一的下场\n身后事，究竟你遁向何处\n猿啼不住，杜二也苦劝你不住\n一回头囚窗下竟已白头\n七仙、五友，都救不了你了\n匡山给雾锁了，无路可入\n仍炉火未纯青，就半粒丹砂\n怎追蹑葛洪袖里的流霞\n樽中月影，或许那才是你故乡\n常得你一生痴痴地仰望\n而无论出门向东哭，向西哭\n长安却早已陷落\n这二十四万里的归程\n也不必惊动大鹏了，也无须招鹤\n只消把酒杯向半空一扔\n便旋成一只霍霍的飞碟\n诡绿的闪光愈转愈快\n接你回传说里去\n","categories":["影评"],"tags":["影评"]},{"title":"生活不能没有音乐","url":"/2024/03/22/%E9%9F%B3%E4%B9%90/","content":"3月3月专辑\n\n3月古风单曲\n\n\n3月R&amp;B单曲\n\n\n3月日语单曲\n\n4月4月专辑很喜欢DT和Ashlee的三张蓝色专辑，纯正的神仙R&amp;B三部曲\n\n\n\n\n\n","categories":["音乐"],"tags":["音乐"]}]