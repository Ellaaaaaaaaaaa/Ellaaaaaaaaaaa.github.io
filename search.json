[{"title":"LearningNotes","url":"/2024/03/08/LearningNotes/","content":"数据结构数据结构笔记\n","categories":["大学笔记"],"tags":["学习"]},{"title":"二战腾讯面经","url":"/2024/03/07/%E4%BA%8C%E6%88%98%E8%85%BE%E8%AE%AF/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e605826219ca03ec7a232d33371b59f5a33eb0185a109abf0b933d9eea08fba01a1768937410ac4115234896675b8ed452e6e0c3b3d8879d3ebef46b0d798aa0375faf3b1fb5b89c4c82a7ba00ddc5acca93ab47e3a08e26d270fd666777ba6e097b779651c81eeb58bdaeb13cd78d6ab60844ee6ecc336e37a64d13ff42f21271eb2f2d1f813d9bc49ca58c2cdd52b44ac4b82a2e7910e234306fc34b5c224b5846b94119540d8515e457a0956f44352c32b9a6b1257b8e33875bcaec3eed7f80d1eabaaab1e8125c68aa01becc0b9749c06e1c1e40f786b1899fc9c43fc4b8a6fd89e5ceee5e3763ad03d562db9dffada4b7968ea3a6cac9303b85dd0b794ddab6adfef6a7ddde080d581d0f97eb5d672e46a937e0f50fc0c55ef50abd980c1b6c08d71e9ada54d29b3dc0bda84bf2d7c261ed2e509acc90b99cd4700e71413e1b017e107e27fe5598e9f27a37552fdf8a5cf1c2c8dd8784c5aaba1cb68a4131b7b9c631894a7c2a198953ae6fe8c3eafd3ce96f381ea9ca0c50363ebd6966929bd658b247f3557aa08d46982f2ff16adaad73fa23ef10fc068f4459101fa1c39e841914bf4de22665c875f8816bf4323abc812fc6022404bb2aada583f2400dca9ec9adbaadc21ff926de38eb1725cdf27d0ddd7d87978171fdd743dc5e02dfdecbfdaabd597168dd4e39e3ef206aad2f16217d932c67bceeb6a63a1bb3a389fd13c5f7b5948c4448c018ae63cb12aa6ff80fb699a05ad10c8cbeee231996787bbebfc46a1271a9ff6eaae1071d0a825f4f746ad21a2c8f8f0393d8776a3fdf014bec2c8d87788d3ce6214f43ecf23d9bcb80dc403f21b58adfb04a123d107c9d7eb31db10a5eb7461ea043774006c98bc44163d5777234805050187ff3887d3b5e92b0bf6f933217ce1b0e434df226100fbfe2f1c3994171966ea42e655473b5a75592f7bedf930ed4f5485a2be9b67f0dc788164409a58acdbc9b91a4a954641ec1b23cadb374b13110c52fd0c5822f77de8079758f4cf0cba73c0b358f79aee145d973dc5f82e624e9be29b0adfe03ad70012467e584f65dfd2a43004aae0cb444aec5b228c5ef0cc224cd1420dffca43f36f687f82671b864b4865fb6fc197595aff417d52f4c88e39859f18208c805e4bd888e7ad80f538cca5f869008a948c30d3b0b35ca93321233a439fc8ac49b0fe473f5d688df61c14533ec7aa7f0a57a9088a6e747c01670030a244f0f3aa871a3c994551ae4bd8422378b555fb626510a3c38273798f2540c558aa9277ed7930ccd27efe1975a623aecc8917ba17e9e8dd30479b1fbaa85a2ae1adc976a1bbb30c9c2c1dd441f217a596bdf293db08473185bb59eede4690bcee155a45a94cb66bb0563ed85f931fd780242ffd0c48e05958ad1c68f865d289ed099441e72f5eb4fb287d041ba993d9cb69c543fa8cf7d5abc12247eb134d22e8bce73cc4d1ab8a47ff81160b27d10e63335d05036fcce2589e880a63ba26c68de0f74048171a37fc75bf5d9ceee2e09183300ffcb028f52672b3c210c81bff526d466a5a1ef99310a5d8a268fcd648004486f12e85051845cfa87ed33284b34176721eb42c350474b971b024f3855ae6ad738efd65b4039dc3f59da35be9e2cd1ecf790fde21f2f82db7bbb17bbf28bd2a19c673177afc8f31f660c3ec5a775cc1551618e79fc50eb16e236fd2f4915bffc0059f734342183023f63cc95dfe3a83d049681c4a15a12195af647a3cfaee8d76d4bb5fb66b1282e533d1587f80f7a998fd317395ddb89c578c19f41639c7675aeb89d3e0119e0eb68b74531f1e23031e5760eb738313d6771d0c61a67ca93ace9d79856c1a4c308c4fbbffbae1cb6f3ffef93a53ed632c3cae75f592c5c936608029cf484d53734ee89554bee26a3639311ef0e7da4af142b902d75c7053afc81295989ff6b5c7466bc52514bbc1c5725cc24fbb3e7f80512b8119e9a0a81539a6009d0ae03f5831465d937b3f3ebaf461cd9f3e0e2f1ab6f55200df712353874021f9c45da64b0a72c71ce45bffc492567a433ec9bde3c7b3653e5f5bf3c5b8a82f9666828027ad3ba893c17b207e073c809d8353b8cd37ff9a91a14dd449293e196767446e6dca9d46b8ec9b376d01bc34a800af798605ae2371c49d0018f51f1672776e7c99bf2d15e7004702b6e75aeec8fbb8b25af4eda5c2eab78c47d0b9fb0287709995f2b6cec9d9bcdd3c0351e8500a92583ea1d16518c98147254fc6aebad2ce647f8763dba621ae1d3a4ec30fa278a6a33ef99adfa3970baab5610b8fd5765a262f5e0a68d335d0665788fae84e819e03c8d43ec72eac3977e4cd82034ec26310484e4fda64368a33ed0b871a8b5ae5900865a41f25c7c7d90f351769436ccab82a6b0254d843ad106decf66ea67fecea9d221c101c842f585e005d5f702531403b29056d45007d34a65fc9b748ee90ab3e4a0e0b30f96cb66b62f6f004c9252d893023373a9f50a475dd88d7b1845da18cb16eb6700c8b5b4d304844952b28619118149927f6afbcf83812788ba791ad3faee0121044c860789bfdf0bc82e1d54c85d40e767f999d724a1aa1bbe0217c150ab963d5a550483545210597e46ba6a81393c8b2d421bdd7f930b11b2bc49f879ea355e5dabaab4fe0eaef5227c57833cc7926e8904b3b1456c7aa83dab83bf3a556477a33711ea6ceb6c83f971fa4b36b2ea0f7609ffcadf8f2335af6afab96f491b941f1f7a20188653f16f3cd2a8f4166826e4f7063103632cc9b09a400e0a626aead31738847d3d4255bd888e68aa8ac2af192f80b08a44e82c0bc9873b942228b3606db1ebcec920a6c3a7a4d371f7490c1c86caf9542a7f8752b6484f1ec267b7375badaca05bc120055d7e5b26bb8238f9a2298d8043519bfbb74bc5a831d70a230ab65d2b4c636cff76d1f1fc6eabc83b92a45273421eb20bd9eda0383041d6384b7b4458812978e007d0ce3092ed42a2677b0b16934f82ceebf2ddd806b686eef8fadde562e6cee519d1c9e131e87d8873eb509378c4e0deb6f7ca441a3af5f952abbd398596e13887ce905698bb91e60716a2187e09658af18846f3ddc251236ec76821f02bcbeacc56b01d913ce0f811f456c2374ff70f7b4accb567a82d27d49281a8084dfefb1f20efc520bb48103cf6fe8a0cc155b1f090e020ee4f64ea076f0982916a39e95d9cbb94741f1264e534c4c9a0193f6df9a7518690839a7f10e5f9d8d21d0f696986c5d1e8c0567d7fe045c539e63498e6155791e283d6be5e858d81fa392f1b5549ba94eb3818fec53809d44e67dc1e2912a783eb02ae26b86dd7dc7ff14d4faefbb5ececee718a96bb914572f16b709a0529c93471580084409311cc4549702281ca1edc1e9e3f436c2aa4c39a6641cbbbc6264bf1b3b2bff15666a16baf4da45b83d188959efaebe5d9ef314da633a491e0d22ee37768ef67d8d5364510f62df6119ab463fb05b10810a328c9227fba7b7529f0da22fbdbf931bd49b5bdd142e10fd0c2cc8c702f3d84d5c401afebd283c24342f606e66fc37f789f0bd6553e091b6b32345fe6775c4fceac3a9ba291c3a0c2ddf319ccacac861d37b8077d199c9d85741cc62caa6cb52b9aeb9a4493fc2816502d093c118881b3511137e37a9fb2a87beaa2a0c512df909f6ddb97f101ea0424bf1ab00337ea8cb508fda151554ec535ba4729419838ecc5b2157d873ec68b2c5ada6b056fafd89b389e9af611c8f443d6825db61d05b6359581b49fe6d79afe0ac8e11125601a750a14186866bd719619e88b70b773d902a4661d769ff34199ed2de41540243e0428761193b63e59ecaa17106d44a0c1bde933c2bc5d3bd602ab5969818aed79c7801899b586abaf5193b3133fe0992efc139cfcdb8beaaa75533a70d38d7fb417e91fc1b8f765ee0e7182ced54ce00d76163af946b3461eb14c0301542a43ca7ac81d59bd45bf8cc7e5bc99d90a2c381ca9b7afd4a6e8ff4c2af63660dbfdcc1e9a15f0a1dfcae792d7448ec76d29c30b070e3faa55f8ab40ca02084f12943c7f40ec9160f90ece18970c17d8b34fb39497b1ab60df3a8f3c6d7a086f337e9f30c148ef5aaa103cdf7d591727b2374ddd74fed1267dc46b8576d350aec4c05f390bc007efe79435d794304a669f950351fb1d82bb41e61a6e2b72325486d974453588bdf4eb4311cb5ec885ad9a92861925cfccd5f868b6692b799d72da0e65ba32b2f05fcec928056c5e1fcfac7381378dc2e2b53a613b4de42a3a1efa2bb7b3235e3604ad074b34394c4ec969d6f303bb07690574180823fbb7bcd23edde7543424a90a4122c953d2fea8ea9836b6f67df4f853a7de6822fbc39774d73c3224dac298ab75b69ad89c50952c6d097789fdf3b1e8e7a85214398156f37e6b2b9aa3c051491a4ace463f3f1d38d83a8c7949e4b1a29e78816b10160f25b7aec39e03baf0d13fd5a84b95eeb2559484458368be570c75634b38dea27e30ffdb252ac62117ab86a18d74f39164c6e2217e46010e7ea1c2d4da3461604e256d9ef5a67ac0995f585e9812fb8281815033e2c350987f6144af395343ad0fe18b828a3631a99f26e37133c61ccef25e9678de418853a752854ee3f6e7f5ea24d256f18fc3387e266b367c69b83db54dcac07aaa98ab18a7623f8818c935aed12c4cc1b1bb2d84157a3be62296a57063bf87e646864677c1e2bf2aab3ac93d446030009575a09b84c9042df3810d737fc3699a7d1ac7ce8689ad501708a9d09b12b75ac15b90ba1ca08a480e1b682fac075539a6a2f4be29f0a1a8f139736336375b5099c28ba62f57cac9e245bea46435baf61110f4cb16a250fc841f881321e9434ac23a3c959d1a97f97edd76c5d8f9e7328c128247c08ad067bec1780e8c885eb0a58344a2d393b480a1e27a7da56d2550e8a9d5242a1e19e40445ff5ae38e6217ecad6d1fc861855ed46fa2e8f87105c595343c0bcc893a244cd9a9044c5254b50e04ec463281361e7c56a94da1bd06f9c8b56872ae0d3a63f94092356f3f49583b07cd4be503f1eebff7b9d14cb9808ed2d30b07f39bceb9dec0dcf3fe3149869384b8594ad5bac008115abc0a6dfb55bdf8811636ceb70aca943390a56b52e9e2f207c033ab35c1d9782bca8f0e29287ca2ba652d7dd45bac7e3ed13e8dc1063a650fb7559e468e65fbe863745e48208b22a0cce87db371b7d46f2dd9bdd201e66471934082eef93883fe6152cdda239c0de779d07991ceff4c1cdde46401e92d7aa7f768fdc3b68633ba9fd5faa1d73932c58ac96698d01b7feb31079502c735869720e74f307bce7e955e185f92bf375051de7f451d8adad547e1b7be03bc9df1ae92b03da3709f53734f49d96262c1f74a4b3d81ce199f9a04adfd9ea00d057fd33f64828a3f86c52e6b062a52eca648b1779c3ae9107300c5319667d57f36c47635305417ff291154bdc24a3b992e68bf5deb44d722e373aade5e275e48ec1f618d22818445def94a3a8c3e2ab3fb9166dcf43e55b775dcbd026960820eb74eeb6b908d7b3fa0eda36e6303b0d04fed3a06663ae402ecdf6453439cef550f15b875eb1e5a061c8294e7c8fbc7669ae980b98f9d6c10945ca5f98b9a81735d87db7b4ee685343ab7adf62add5be826c95c98abb170506828c5947dca79353cef6fd45365c49252ffd39bd425ab30818b203eb373f6f0374098f5fe33414317a5bc2d8124cf656b127d8f7755ec6e2753f3fc3ae268a8615ea3e4258340cf9aa1d46e52cb8720df6cc1195d0c7ac29583c7631709b0d97f4e987f7eee589c64191d719027f76d2123d4404b1411c235d7269839a221a1038354c4b286236fcbf6777f948e2b5991d80515c92dc09020d82ed291bff6ac24506a70491c3140d170baa4dc51cb8393e958f8e559b0d907b302a2274562903f5f1c821e1934de174cc9d538310cd3ecc7873de355174722f0b5b92f0856ff55db413845996f72dcba275922cb95ee31fffa048fa3572595c52a406385bb89fe09e6fcfcb3f531825d55d73abef556ae3d70a5876977a80957e41c969fcc32cf561bdc97b6281677b36b97e2b4010c35097fe9d2208bf49307963a36582139e7b0194084d56486ab76a28f333788b0a0943df4f93b1b575ca9196e105065abea96b167d67fd1e18ef37050f990428a6f3188fbfa00484e4f45b4143fce73d56d5dca57e34d3263691655d3589681d4ddfb03153584be05efc6fb7f6c0ee6739b18f72f9354cb80b3e030799563c2f3f1095b99a72b920323d9e61f68d46ab2c293b5f32712033524128be03224f7e67240b85307ab79515cc66167c3ceefa453d9e7bf6dcc392896f22e6722f722ec06e8bfeba4010ce771ecd996af987796cfa35fa790a1ef1f69320a51326a102b2b3d60029f576a2f675e6adab3ca7faa59cd174932b6ba35c685619d2be81a7ae1d565d1318e733990bdfdc2d9a343b0beebad46b77935b887026162fffb09a6da02442354e6973811059d4d52911b34ff64c6d5cc73187522de69dd23854562a90b0c583afa357f915a47d6f480e06d9d6202a3903dedf60eaaa34213cc4780c366f7c7c66cbeb9b970dd4e5e2788400b4d5317cda7d4998a664039310b10d660bbf71398b99400c0310c143702be1d95097f3bdcab092d21f90f74179222cf2f43632aba70825cf33e8243f67b61b07d036a6af15ed117b832152c233b1d3bd91de13f29214523d3a6fefc5d67fd48b367966918ce6be2f5b0d2af6edb06a5566ccf705406780e33feab90b205650631458b9cae780c222d4de28c58bf3caa0e3a91530cce903448e7f512e135a6bf46ddb27b3d98e012e394dd976bc5aaf6f284389b47e4bfb9530dd9dd47eed4367249e34cb2a962f6e6208024cd1c0f6c184d9073987420cc6896c554a848629fd580580bf98e6aefd2fd4067381e6c2467a6342c1907d53338a756f010e197c4299b984195230a5e933517cd75562c0de07faa61e4f73c8146ea0c2529abd4e157a27a51cf3d87085f6b346e4e4cebc245a68d8bae24a6f4e3a1036ad2e00ffb016d104be2f1569cc079ffde4eaea0a63ba6a8cdf5152d8c8dbc7dac2fd3719f94a71ae4eb0e8b3856bd2b7c421faccc6bdcbff1526c3bca858877567501856afb1b458617ac8a9aafa88df76277d1df6d72e90733982d88961bafc12fda7ddb28ed0777cdc18e823ca38a75d41975e8aa0e97c5f440da1b8d28f016ca5807d563051022ee363fb3fe5ad4e4a224341d61a63e00a56f5a7bdddb909776542116e920d4f1543b815165285de6ab8e59e161a74c90f2ad3211817836a2147f32248dab93df3d5107aa6d81309277c308ac213e62b07ff4796f5a5ecb62d320d1a9dd95ef449316597ce5300906c18d3469d109e026c2e374f8a45a95f96d3678e06f4f13189e6bf8db25b4dc514e30606e3cae77d84727871130ac23694e5d49d4ff88e8a83c89bf44d364480b0dca1775683f0c51eb96bcc893227be7c9f9c404164187eda5aa46dd181c4516eceb9a21d2c433a715558b8f01596559182346778fdbce85863774290e81fb1f1ea266fa8e8bfd6d2371c3205fbcd3ff902a6d77c4c72054c5fbc8c7487ed11ce0dcb1055637e0cbfd0ed2382fca5f15faa51995228e3e03110dfea9b6568ec5b03e97f2714fa17aa873423769bf7eeef5bd1c198c3dea332162595617c1468bb4a9afdd1661d24228c7748d21cddbd1a371e2931c91a8874d33d28c5620a2253c0b448220229189ce7871aeef7f4c352c0ab34698767630f3b58b359f4e2c3a00f038cd6960481988c48daa6d69cd255ec1c66a3e016735a2fdc59be6073abc1b30d7fe2a13f2430af2c4b3f6825cd7db5aded9ddf64b2790a548c70595a49c0eae2d7aed62138353f9178ceb336a6a308670127ecd599d92962a617acdd4a306eac3b8da363cdf3f327848c886b88e5b2358e2880a596255f9ad61e0be0dc2d201d1a6dd32513fb8b538a271e25eb623ab1e5e0a1007d97a93dbd9815997f251c56b89ffd67e64b754bfdeed1684fa3f04d7682b508203861478158d08c49789c0e4d8a7887174fce32c38a6fd1e575aab2f210cf98487ca7b72caa526e9d3028ba88c8fae09ac78573abd0001961119b17ab89d7211c845260e9db7a5bedb9befaa9cbbffad8bb9102197a1ba4b541543c77f3bbae068651417134cbe4cf63a6152b1272cc873c36198ce8f728b99024bcd4b2937890fae9be972abb2ccbf3cea85bddee2afecbe708511acaafed4f8319e200ff86daebac6f57736d6a017d924414fecd360ef1cd7ee0454365230aea8e2e0c6d6c9b5e0ce58c2fe382098ea65efdc6ffbc3bf0fa79189d1993f4b4eafeaeea6ff463d6446a7bbaa317df2a070711ff5eb9e860b5fd815dbbed67b0c75ffafb29f8bffbf747367d741cf1f35ea11e7a1a511da3e143dab4576a54604ec7ba1f91db6f56cc237be1a99eb7217c1e0da09ff957ee48f2e50a5ccbc6e5c403cdeff7bbf0df9cd102200f203d0a331fc86f7dc43187678afc7ee548cdd4412c6537f074e6f90b169c37bc0597636cdd6482343f665244b4db5974b2b2a38de3f3246ea6afb4d3cd28b5f9377174d431710b794239f4beebd1cd27740c05b8a9f311558858420e6eafbacb31c291e0ae6cfb46bcee2814baba2ca06db122d0154a2353b12902fb23ec7e9d2b3ea87297c56324b9a9ccd337479cbbe9654fc24f14e52cb2a0549103272a7853f6e1fbaf28c8a854de2d1dcb015a8b3a4ca27fbd62461f44cc049c4f830b3cf1a9eccd5d04aa075b67a8c4704143a1b6e08635df56d25b86a9c8e5ed412d0720c234594f2b3399f16ab46f9f7285f2cff0a4f9e3d7af0f643d6f8a86874b90cc9ee7e3a425243346e8b1ddd38edf2aeb88d4584a1e627f50377a5eed22aac53e1390e5a0b2ec6b3e554d9892b2f4630de7f2b5484a05d4bfc093e1b1075afb9079796dec6b454aabe68b50e231dd655876455eb3ab800d7044d6044432919d2f33c2d69ff1196718fb00c8e33cea959dd8a4546d4d652bdb4ce3ccb64ed128f355fe2abeafed2919ca414177396795931d7b6590dc35abb6d32418369efaa99bac76e1a6e451c2bcf6987241ee7ea80e1617aaf564c31b139aec1820be47381f0856e937ab379f2f82b5a273e52bfab0bd9bbc1b5af5225449a2c80efad607d2f763cece2120c0f6156cf8f3fc46736c4c19b76493f30412740d4be913aab06b89e1db1c557d1f03d356451ed910e3d8d3224989cef7cd2a23d9c24a575be9ee03ec59aa4a64dbc3e2ede8e87cfe9bea27733ac434d27d388f71a204291db6cef49ed2b5aca2b200ceb663452b8dc6932ea5b273341ffbc844b55391c736b385065d3ac6559f2fae80c3576b29b8e87f0c82ae2cb30d537f690570db5916c13cebecbf65babd050ccae071f7ac852046092edafb2b099e343132914fe6169577dd9b36a21e273a01ea380a9478893caacfdb8163ff75670e67444d2be8c799dd02450b9bb193d95a8bac708792f8e5c24c35bf16d4ceba1a8c9ff0fe913f0a4f4af9c4b0a31e3e5d88c5fec0017aa6abb1bd9be0dbf01c0a707d092de59d3ffd1b740c2e689d761833a1ce6853735191e53a916facbf5335eaaa89cc1d2dde91a0bc909bf14e2892a1da0cb26138d91ada458c0f852073cdd418fb3f59045d96f20f0d917a347c9ef9bc06dbdbc45514adbb36d89c1a26d068f6213855367e5059e396a6f82e463042edccd954a19520380bfaeaa51734e773b637ec0404da8633799273cd2d863362fbd27d501d99d23d3048d6c3208d856cce3000ecc84f86353c3de3bb83f56330216ae4bce190537b1ebcfbc9fc2188a4af7cbf21f72c9061bd42d5f89642f6d127ed81c1f0586b6e52145957f61fb9836e47434c2d06d6d5b3558bdea2b8584232cf34e5719f1222d24af763897353175eee69315ce4f4b6fbb909383cec04ee8e3ff20a0fb78d6fc7e42309ba6831ba6979b096595bcabbb5d5c849fc6dec892e21a1325e4af6e47242a78a7d64de7897d2cc19acb1e8c778ec4402fce4154f79496b9205187fc28941145702c01cb2bccb393c32d9bbbbbd4c39dc787b673488ef5deead81b7b02194fe522448de45c4c9f35076f512c5124a0b009d778c2419d86e0b6836dc0bcc5a5b883e2313fb404553e4c3b1fcafa1c7837c91848981712dcd56969c1461271ba97fc9850d358e238d060c29d26ea6b548a251886c9929908288556eb2803fb13a8f9c5bacab1171d9cff034424455f16af7e1cc5b87530863f1e8f2d8918a9228b36c5a785d5ca54f6a1f52c60630acddf48e445ae3988c8e2130f888f8b9a1c836a206ea6143c1f1e70778d735d94f4960a0f8919c7e8469d46a18304484c3864614fd7cf6b3abdca1c9a2bfe932853e4703fd1e50686271d7420cbd4b13a8910137caa4637ccc62b157509944f8d23c47673d93eaed7415cb17a472c989453c51ac92e7247fb253321cc8498eca803f934bdddabfbcddd5b22c353a3fb20d7d44b19a817bac88f92e373b8fb05cbd62c1495734ad286aa87e89aaf9732996effcbf5e9e76eebeec8fb004b6831ce65b48749720b17f1c9bb9064348b135d42555e927716d6ca78646a8d05627d56506411bf0d45f7fe77bc4d7e7dcfa822519d16c62ea19996df06d395b167269397c280bade6ff493c7add05d9d875afcb110e2a7188f020556d0fac5980a16eb2b6e0b1a31c89e7e48846b9f704524aa8989105e19564a2f10a3ef436ce3bd9fa51ed5507f96a4d2329ac4b6235a597a297e66cf89cfcd1989a20844c75558238a9a2ecb441530f5703452d6ae379615939194db2e36c19ae55a82b86c4f82e9e8ac3689b206847c213d67393e459122f73302bc2f7c0916b243b69c7ed10ce406211b4d29a8e14e1cdaa2fcf4b0f52bb39408a80dc7fa4057ab641bce4c6640f5feae644a9acff86207f27e3d448a84bfb965dc19e37c2bb88382adca45a59484f74e613e60414021b78eae02516da909a2fd8e9c561bbca1affb27a46818f4b162a62a2e970feb5e88eba0b764814ef58b68771c5b72f944379f43c55e580956b3a278117bce7a8c68d9d6d77fa61d5d272f3e7adb8d2e50dd9ad580b3702009b0e71822a71c6c445022e977a25cd2\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"一战腾讯面经","url":"/2024/03/06/%E4%B8%80%E6%88%98%E8%85%BE%E8%AE%AF/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e605826219ca03ec7a232d33371b59f5a33eb0185a109abf0b933d9eea08fba01a1768937410ac4115234896675b8ed452e6e0c3b3d8879d3ebef46b0d798aa0375faf3b1fb5b89c4c82a7ba00ddc5acca93ab47e3a08e26d270fd666777ba6e097b779651c81eeb58bdaeb13cd78d6ab60844ee6ecc336e37a64d13ff42f21271eb2f2d1f813d9bc49ca58c2cdd52b44ac4b82a2e7910e234306fc34b5c224b5846b94119540d8515e457a0956f44352c32b9a6b1257b8e33875bcaec3eed7f80d1eabaaab1e8125c68aa01becc0b9749c06e1c1e40f786b1899fc9c43fc4b8a6fd89e5ce073d27ba4750438a2f286b020977e0634f3943379600960f244114f306094796f35c2b0075932226796073233fb5bf25764c9ae57d4d7e52cc668d6c0bbf4fa6074da7fb2f34590a456b4c3069fb8495e3487a1784ec4c9c9d4c18879ca7b8dfcf481cc82550384a24325c2b2177582ee48912dd02f3b0c22eee7857a3198e8adcf89847e273fd9cce4b2c921b165c26b0d1a9315b2a5eed8a791047873d7ba9fae14a4e469e53444669047913fc1ea766e88e06ad2275decc565dd976981b6b02439ca7c3b5c6848c2a578305128be6e97193da8b97e417ffb09dbf1756d40de8a92cc52b5e05667dec2a2eda3db5683c6385d1f2ba254efb424a3d557d8ccb2a48b7630808023032cd3b2effe452369c475638b66fd1c9d69b59933494458544a7182999545fe3b29838fe91ae84788b3db3e67b511e9aeeb35ecb65fb650bd7c5ea2d1719a3fb2fb927dec4060a345344663da2fc60aebc96ca0c1cf214baa93ae36e49470bf835cac3e854fa0738f8f0053f20b92200636fb0ff7637e82070d5dffda905499155b897bb4d270d746f5d19689d3575996ad60e675ff92d29fca2bd3d35dc953258387d780e917f487981e2f4c2d37cc3e134e208851b7bea395f8d0f34fdb80f0e543b389ead141886514a957446635f6efb4eb17cf803cb2f9596d8199f386df2f00c00b011829a6f092d25da2478e8da9e4332e1c12ace51a49186fbc02abb1cca7a64b5a0f32d4a585c80d265f31777f3f61e98f4f0996d397dbe3779b808f4d0e0d285ac5ff129c74d7baa7c26756bbba0e306401745ed155cdfa37fc1b68c8d824a93c6d82d4da8a3a17fa745c23d4927a0edf29b08d57eb3db1d21262d3d12cb4dca898af4da056dfe0cc84efa075e3ea2fc453a7a71add9afcb14adea69ca0574ab96d9522b54303f79616b833338b0af62afbb997ba66795719dd5c9ba483c9141fcf39d4ebc0194c0aeea4e92d1d4564f0adf83723a24dbbb3f78482cacb62867495f0e5b47218f9fd66576d12232d50e83363ff9ea39deced697ebf5bb8f798225367b4171ca96e17acbaed6bd6660552d216b4bd74937e4f15b8f5a3086f166ca7410fe13d704fb03e5d0df923b163e983c594a6f2e66058b5884d6d1c71389965f74c3c4fc0f9bfe916166515bde37c12dbca4af486a9ef936542742d008f8c6f56c907408bd05e52335d9b7b6b1faca82f33cb982f7319b0857f2b8e63336d86a5d671ca510cbc3ff440e6b90a1b044871aca1be51f1b62bdebdc7712f41f96981b7127de222de0514a49808409e600cbc1f9aa6bd3001fac71d5694e01c6baccf52860da20b1f7c9c87de1d25286a5506ee2e668872a88f12e848e3b03dac9219ec2c14e73ebe2cb2f93148cfb73e6071e986d530857bd8552a5d6cd3313cb5281ceb4aa246204e91051c0c062d57dd658d01764bd95d3d2d3e7a1057bf44c4ba7ec9faa181c45c1d33ca89e55c835a3c22655f5a98a62e2aed1d7fabc476624542fa7d014cd74074dc8049e0b521d845b84fe53e9c27f0a4a237667b03c7da30009f1ceeb2e6eeb5c2a6d753c5ab8ecff32f6585f436d85677c6efe7593b7fe5a038096d476ab12123a5b72075da691bb3fd10b797fb6af67831122bfd400487f76873274f94758373382788453d46dc4ae033a75d473c81079e29d84913ff503f09577bb17cbff80653f8fa095dec8bf6b37f082d892cadf73ddb2ee59f1cd87bbbda18fbaee9a51cd2e9e07197add7a19335478615c52433b2485fdb0624d4f2cfff5ad3d1e965d9558ac5b5937b0b781bb67b010bb89e4fb164bfcbd6688364695c9c4da12a8e39b3a5e5865aa848a97039c2c7d41e6981d1faa515cd682107c040d6461eb279014b0b15031beed9b68d16c74898ae2685e3f67a05e0a57f7a070c2f2b35fdd5e8c9eafa336e90081e804f49ff67c59174d584b8882a7bf3060383faec1d9fd429c3ffb81734537a2eae1661fff6ab3dbf3b5b53be453750284da08b43f00def01bad289fdb942c433238529488c55e00d856100f623e4ce0e946cf5e687315653655c2cae876189fa0ad02cfbbd000021a8778384fd27b7935a9e63f4e2c7b19b097d46f654b8eabd6fd685197fb193a185083a72ffc7d24c7a9833e5e1f6213c10848f90e84b027bf9b7f325951ec00ed990c331463fbcc8b7dcad59e1f07d6367656b082db8c33fa1edffa6e55f51f99d3a0d2139f4f1af1eaa570c49dcf99305e65f3f24c20e2f240d85c1585525d2527cb8da233a99d91cd4715bea886d83223fcaaae1a60a26a9826d68380aa4ec6b55fdbdce05390278c6b03014b19af6d4657ebb4e0dab7ccc8449584558eacad43d4b928b480ef5495a0e2f48fd9fb2353430d246d828506104cdc11be81b29253bf90ce7415bcf4e794ac6504f06ea0b4480f09040c8f6bbb4421abe5a7211e7f0bc0fa9caee13c51db448536d902f654c5fa5c403c83bac0287e0f5a0fc12d9cd9dd26f117cfa5ee01895d57d37cd8199447709d6a1ab5d6d16cf6690671852a99587f0da10631826b573a43912ab626be32c727a779cde5cabaeb497e81c98ecb78049a3c18d6a65758741e1f661632aae9d4b09f76051c41afb7bc554a0ae0538ab4e07383bfdc9355aa578562984395b3c23cdea9f04a4854ea7bd913664c0bd556ff5579d56557caa3bf5db68c530205e09d73a8fd9bb5a0978a5fee4f7317ce960f1ff6f4071fa76604f11d9424f3835109d9deb430cce40a7a05fd6ee1113cd5fb2db1d9b7afd6766416a3adb409d1f72e5571cf32293af7bb5cb83057efac0aa40369c23d62b3891453dd3ba7edb486f14fb8ec63431e18ec9785ce86cf08b48df10e9124807ad50c7c459098b85a1b93fd9ecce57a85d61ecf168f168474ee1636b783af3ce09bff74ff933cb8ca0b7f1db68e57fd4ec1b4fee00a5f4c38b134d1de3f50952903f6453cd7b85fa468a2ad5653c9fe615918859bbb0fd2e74312c1c087cadd7a12b815d3574d0bb0c0beadec754ea7cef5e7560a40378cfa69447299e05b4e22f273cc274f6e7e5c48847b50b6f57414af8655836056176243e9ccc980d4484dd074fd58dd33ff34cd8ca37b76cb43625bdd47d47fe92dbbaaa3adfb259151f72878c4baed5c5d594ba0ff2312f311bafd979ed2e3f0b9d961533afea0d537697659602f22dcba82370fbbb0a0c2aea75c680263f5cf044ea08ec7274245e810ae0e588375273e8f20e384c0f1039e9e711ed28de2f89f0cbb0a1af8919fbe47dfdd3782c7866d52960b207dd9b4d78a60594bf390475592281431d3dc465d6f1e27d8a7ff67644977ba9595d9ad5e4ea7eece894ccc248849cd751d63db7e427943fcbd16bc2db9ef2168d531e4947205d0cde3a851965f7c4fba691a536830b59493f2862e99f74b69d120d31971f38a37bd4a725d8f597c07faa0b70854b9c4f218bb2b68636e305e751618e98985fb19e1a5b6d493e4528070254830efaa7135402bd9ae8ba82d04da40bf40c54ac955a78f3b83954e660068bfda75ac2466ca0c913278f02534c43ea748d2b16efe080c3cc32c3a2a80f1108fa50087b1f2d928db3f41d14903328cd4799ac3c603fd076ae04e78fb03679cb628a4c48b5cc29754b1999980bd1582468c328a947f0451a00252fdcacb55603d1efd9bf2b7d0aa659bd90c2b29a5e3115df46f2d034535c8059e4203778e44d713b15abac6f5a50af3c7ae02b49de9fcc135d26ae72bd34cc1d6da28923ca7ae1f05197d549d47a6aa1fb7b589a0b6ac45fcf037ec0f160bcfe0d2e5ca2f92c0b974a83db981354a867862fe6c413a6e83425112492ad99d83141d028d9469322c86e7b34ff3c8b5fb8a76ffe5475735e1622797f461baebbe8629a265b1f2baed0913ec037a0d2ceb7f3668da4758b944ff1e5d601e3dce72454ff0c24d9c2774c7a08ebc9c270229537988ff64d2e818de2195aa913f35b276d0bfe5cf6c1afc35ac9f8f0a95ba4fb1d6b7a3badfe2e913971e66ce4025825ffeaaa673c15ef3cf89477d6552cf00c5c621831d25a70217b125699b3568f9eb60ae7368c2cb6f6acd4f158baa87d04d7bb7b6ac3acf9ce193228e35d9b0909670f21c03d75e85bea0ece1a357c6987517a95cf4aca5d87742830bed93aa4564ad485ed028623440cc34617b5e513345ac3db8a805bf9367fda3eaf71803d8c01bb4f5262498d5f57ab359aa961d557a9f24ecb81f5df5cfdf3a3b94be8a5a13c0dd7e56472dd9da17d81178d48ed2842dc16e10a73020b9445e906b6f7bd717fb651fa83175f4f081d441021c36dde80895ac452d1c1be5f1f803b74c29b91397adb0117028c58ab2521e6f36bc2cf1a85efb84b5f6a01209050478ea0de11dd6e9688f6ceb2b220cab6384adc1e677af72b75570660f8bf26edd1893b9ee49518e3017c9ef32f9c7ee6f8bbcaac49e774bdd834c456f2b07cd87696414806d5211c45fb19dde5d54200f92cec4a0bb213c8fafceb2641c8d2434c8618ac7e614bcab323c057324351386bd268f7a0da88d53e56002f7e4c4ea062105e13ea70937318758c06fac646b2a2e539ba3a4acaf574b0f8533d6bdc2c9708491ee2cb931bc92b9996e47838447fc9ba9d40a9707dcc29f969742e9290d8408a68989651369f4936d5c8d6262e0ad21e687aaddfd765821176d5b12c4e4dcda9e25dddcc5df1b7b5d56b614c4bcb3bce09f2fdf831d0f413e3b51444e62629936e9260dc49619d5a9f70b28b0d0aa66ba0a4260c3bbcdb54b390839fd938bd3ea3162f36a1abe8d14df503428e0062c31e6413e4aa5230bdf762946acf278a210d0767b3ebbf6c31355db6e9567f71db6f4394e91bbb1fec1bff3dbcbdfcfe67f6d9b28fac8b35cce3f332f04861e2aee1dfae688c3dd2f63a2aef6aa4818e5cbcffcf053895e15274ba80f60ec697a4d4184984da2a263e12afba10a02254b5db5e31b30b51494947c7e64e76a6f7a588b992e8b4eca38c53be2b4f242ee23382f2afbe902c0bcf72bc1fb574ffb72280021585ddff93f85594587f01ed26b3d14cb3b994c6ab599d39fa5d809dfb34864ede212bfff16c94bd0b09c2072ee9412ef0b89fb54c45bcd27ad3cf0bade4d9f345d6838c5482c66144f4c026212f4341e19f8d9362f143e6e3c283387b5cdaf6f2861aa9214f8c3234beecb48e9f3d1df52ea814fc9792ed54d2d3948ebed49d6645daea039ee7f427cc9066073dd293ef0a8f56f637f944023eccda525a39188c95eaacba8f25dab503fed1260bf746dda972d0e6cafe126a4cd946238d8f0197cda201fc2fa5f875a9985530325afa25be12d5d2fb228ac10aa744c8ce65030aac34c5d2520c28a877952cad262e6693a939c6101278f5688b0ae96d82b75212f1a2852c237c3a9ad8e91bd3aee8beaf871a35180dc1114eb544bf6434e245197f4ce65b14e27923ef4108bf6d4d75fa35fcf0883b3b4196a2f33362069d13329cd90343f6358210d993a67314e88f6adb9c6ece37178eb01e28c2f6282d3aeff62318a6c719660f540c9fe0c81eb070683c76e7560b8939b1228effbfcc1d461bf519d236e1321b51d11e7b34aa99956c7824318ab82f668e2a6f3ea040e219263a7b45b1f264ed72b884cb89e1642a298eb843d708655705c6d2bd1ca35c51b436d87640845f604758301e0ea7914faeea0c4723b010efba48b56a77c4ccc025d1076de4851e496689141f29d637ba48dada7f1b2b975b60e521327f790b1415498fb26c7759d3659bac7f18ff2de9a20b4eea6f0680c6268883527aae51a574d59e1d90070851574a06211b65894c7c5eaa0ae655483862d6b355ec273016085d4438d44f7b4981ad464f26baeeb247522fcad037250c5b14b19a3d304bcae12876bf9144c0d193c2bd0db2fc5f236125562959ae116fdfb73761a953bb3e4fe29fee41e6ed8e5b5c8f9af5c5aa9974bc1ffd360174950229d5a078ae7f59ae8731e7ddd4644137182fdaa16f84c5c08d9745684db2b956393533e9fc2fa5f121b8e37b3358a3a5dcefc9bc0c77001adbed02b247d7889c0be063030bea7298e35c1f26d69c2b04e04191a4efe49e32f5030a81a0bc94960aeacb0f240551ffef66ecbd7\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"三战腾讯面经","url":"/2024/04/03/%E4%B8%89%E6%88%98%E8%85%BE%E8%AE%AF/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e605826219ca03ec7a232d33371b59f5a33eb0185a109abf0b933d9eea08fba01a1768937410ac4115234896675b8ed452e6e0c3b3d8879d3ebef46b0d798aa0375faf3b1fb5b89c4c82a7ba00ddc5acca93ab47e3a08e26d270fd666777ba6e097b779651c81eeb58bdaeb13cd78d6ab60844ee6ecc336e37a64d13ff42f21271eb2f2d1f813d9bc49ca58c2cdd52b44ac4b82a2e7910e234306fc34b5c224b5846b94119540d8515e457a0956f44352c32b9a6b1257b8e33875bcaec3eed7f80d1eabaaab1e8125c68aa01becc0b9749c06e1c1e40f786b1899fc9c43fc4b8a6fd89e5ce2bc68235ac7a4cbec7052efa8cbee1f375751f6dd079ddd9efd430478be3a480845e39c33a6375d13e5e89ca9fc2459dcdd0a83dc57fc210cfd09add0564b311ace348fe5d014363407bdc51db2fdd39484a5313d1de85b905b8b838605a48134120728bce4ed312fb514611f50c608435d15fb52803fd5b3710c4254930a928ae0e35a88fff28a300af1d6b6fff98be62191c9f3b2b075778b566b4ba331e5aff01e5083b4d36e66b24e6f95d6d4b97aa713ca5e7f56c9e15f321292527a902ef265440fb4fe58ea6cf793f1a55c5f95e0e1270c807f8083a41a71c6804c63e951372dc8d53c2744758307a426b481191d5c25eba8758e970b98d31bb78a08a4893085e42c4994718b13f2287c77645425cf47baae9d0f142f0051a91ba504ab144328294875dc5aed46bbcecc52de10a4a236cf2fee7a3cc01d022bdb6031b254ccc0ff4e900e0f3b3d0615c5a4b7c223ae1fee33dab4217625e65a7794ac220930e03458d256859b9b58dc1079ea364325b4266c8767fd0495aa651b3c1c20174cdf4b8b77b33360db6aa90e7f127322006f2e93052708d4aed256203286ac9d7dd847b99fb1da5dcc4899968ef0a0bd81621d35ac90c222347f603517211c765f770a5e855941a74db1f1f2f90c3f11a83926e37ac6fd5280cbabb2a7ea1b3115af522d02f5d67450b116ae761a3c69e02b4f75f58208e7afdeac556132643c5c9f88879315256eac4c6cccca8a8101ec04c88af5ea6db2d0987964670bfd1bc38d8ceee516d278b5128a1739efefe5c723c91102e3c1f86da9e1a885a85931787ccd0957ac4cfb3cc39db6c013e92a5616e212ade097d7ef592eba2a3c3e4bc63347763212a6c4bad70495ed33519fc7297fa1a872323c794780df7fd99dd680b12c67873ae8da636179eacc4258079258b099e7f26157d02b9d8999c4c9547e980c21aa08d9deec76a7de35e2165a99e3851fb7f6ef9c839213e69fe49795d8e75c3c5ce56da206b4b33397a6e3b520866de0cd34b06351f0639cec4cd11cd4f2fae05e6ef45ae2f29872954dbf72d5e2092ed4d38f0f1a3230762d6ade96f8931be3b38e579fda12db1e57bd9c3f578c09825bd777190c5887d3cd15de051950a657e44e6931a69b2652f2023401cd238d4abdcb211ed7549d25ca31833770d2ea5ec01517f336f815dfce8a80dcd454eed0be718cc14cf31a5409557b6a8c81b0b3a8a69703190ebfd180fda44d65cb27741cceaa002212fd54f4cd88917aae1f97c647ee16d307f562dbb8fd160f9a6bbee3c09d50c0c444a37eb51a25de21d996d67f87df8c59a5007a742023c5889049618172e10cedc8bcdb2a41ff815eb973a5cb0be9e78073673c6e212fa037a62a02a72b5509538f4a8b6d031d1598d6cdd32942ffda7cdb0cfc94c96caa56e453fc4613823bd5c901154889ab6319d58c51d37e1088090254a13415ec7d3461013dd63c408860cf9b05e6f6d78e0c0966ef6af24b838d789df60e06071ea537cc0546b5f4b1e389902447bee602311f58e69839787017097d23ab408f85fcc6307f741ef6eccd866d43ca321e940ef9151ea860c878e7ce875da89dc38dc855a886cd6a1b350afd9abe2f1b2c714c5a53cc656f4c15090302da4f706d459abbca89c370b18052411b5edb43be73cc9ed25916394d67a24b49a127c6a1078cc06be10227ef33251cf66e59da9ef57fb637a9c1601d37abd9c5dda6d793740eadca9632ebfa32d50b99170e2f7e9855bb3228a09d9500926d470beab10bc18898c1a951929b68ec973ef4638e19ed5ca27d4d97ecd5a00c07affee32e8418a819ed98f48458d0d2a2ac312d895ebb80a85dd11de2ae84f1a2fd0ed2d1d581a9a30bf2e9c14eaab570d576c7e9a283317652b5dc66b910b7a7628bef85d59df35e4305c04ec0eae3c64145dd9f2b25835a57181eb4b2a6e8af54d3021011a71001e95a6cbbe52654e92db8d7836d60c7857e89887b840818e919eab3266612c0daa3a03d8670cd7283374b5afb18ba3fcc9f129e5031a1dc642c036c82131794e9147978d4da2e9f814a1f303405a3b171ba800f6f6c1725a6c078f53dc686dc281dea05507a6879f29fe4f82b40d257525aab45286f50d6fc6a774a73565a7c5aaadff81822688a89f01c0e26a02ccdbdeea7b8ae89515ba1d38a40c5579056157e145018ac5cad330ad6ddaca8d6e0e49e1cb02de39bfceec946963e3de35dee2e4866b4e650ecfa0d80e9fcddf9ae2f06224a2cc88261e39fafbbb2778a37692e15b87a0aea4a4c8298c02359fcce649a0707a653b7bdf8da49f80e2f36fa5f7bbb1a8781711896216da1494b4693104a9a250cf516d5c6c314ddeb1dce83ef33b27d1d2e5e1b6ca3a1da40107e03de1f29d4e9054c63c387b44c4f972212ac2c724e5908e357076ff90c89eecd74b461f4811c1519e939272a319e9dfa94ff5b77b7d01fb0362a2c8f36cbd75bef6ca729fdef748d7b7e511bd0176c2d41797830e0895f35d98804a204dc72ce7ef15a0643f6b14a7012d6550ed30082cdafe61cf8a33644c18dcd919e54b4ee8dbbe2ef1ea0f8141bfef60511a1bf42b1efe9e34876cadbf5875293075f653790cc1ae115acfaacf8fdfd23d75adbd2aa2127f515d88d99f0999831294770a0d579019579293096c9a8dfc965fe547d0c499cc74cd4886c45a3771c8d4ec8ddff80488726ae84cd6d142f61871c52e8e058300c5c23f87f0059a2387cccd6b3973268e60d4ffb96eaefdc9c3d50da623db2ded58b4bd9230736291529f4bc6c995d2267f80a6c57441dfb525b0db3ff9ec4b5ac39aeb1690588af28bd5f2a8e1625282e5759ed3987e07080e9cbbb75b9dca8c953876218c73ea5837ab4e1d76020c61f6d451d8690794b82e8f2060ee699e4e2562ac551b411c463009292def90490c3ffbcf176eb72c97643a055fefaf5c19eeb89bcb6771dae3de2cc09337e574a6e9e993283b9bd8dfb62cd05e5f71d0cf9c6ca3261a8ff3fff88fa0d7bf45c5d0572224361313214d47b56777feda1e1297691f78c21c4098a75d26826da159cb3e65085335b37bbf8320d61cfa6ce60c3fd58ae53b6188f2570ba5cfe99aa83c7bf1d75591ee8a3f74fe6394163610920005f586a02adfcb3538ebef12b7211b6771b043230dfbdc2867212cfb4ad6828cd0e85f34b5a4eb010e27bcb585b559a651ac97f516268207b499825fe2ca7c062e4c733f75980b0850fc69b352c2f572dfccc1d06a1ebab81f2323bf0a5564f2766721ee5ec721fe0460609b304686c05de8d14c31c6d9e6a19064e53eb9e6ff617ac2062d743e6546\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"动画效果合集","url":"/2024/03/27/%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88%E5%90%88%E9%9B%86/","content":"\n\n\n\n\n\n123\n"},{"title":"华为机考","url":"/2024/04/17/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e60582621976402c123a86c8b8920fbcfd0e552e9857267c16c3ad8a88ec3da0d5371d8701f8c1daab3d4a97d5406ccb923e8ffe6c9224451977a33ad2cb1e3fde1d315ae535cfe28f83df1490bae67fcd91a039843522963d3fe374694e05364b926e5a3cd34da15f64284cfddeea164f6ec898df4aece71b44ef51e17d67f251ac231fae0981d8230eada98aa11aadfd154bce8fba2b0a2e4a6cac5bffd8cb6e935de02a78f369706b119ac3eed09c99c999b328b2aa4b43b54ef566dae3b1ca6b11d67e6f2bdcfb0c54a71d9c66b538e5acfd10788d48936b94869723ed0b42764718618312d949e7eaac8ea6c7d7cd1158166955065acb4499a270f67ea33ef9d8a543ec9f1139f0bbec1cd2bcb50c816584858eac618e7fd925f210d3e525b9d4dd88ff692c2b55c54ff7ab236f5aa8f400a3e3eae00368459a095645079b48baa9aa195584821d2ed9a4982c36fb02801c09fc1e57727ac33d864e2b91c11d4e9dc98e88afda2cc2a11900130dc3389f3134a20d88635c93ca416561b0940f9e543c003d4f2e96943d73c2b603bd7048e6d6ae5a1f43f72dfb0408f93c939fa89617dabf39450b54230e942ac48061a1f18299ac8e61adf7aa2a5357cfb675937c27f2fe919509236aee748afeafafbb5bd5a0525a8c9db5abc5ec5d8955253c8ae63b65455dd3e5f689000906c6f829ff57f74158808f4718d2704ca360ab32663c96ec41d3ec13bc4803868f243df7da0fae2d1c464efed9eeca117b36b1d540c55c08e03703e4c4c701de98fcbe4d396044fed35f22e6b1257672345905d587b3a83169e42ff47549e8487d54c10bc54c8eea0c6b17d775323e85696f32e677ac02c258bc72834c3dec4e133745f9be3d55dc20fdd80887d8b4091a13edef40f53f7e511816f588624219ce5ba29636d9a28099250b99cd05e813520c77e6403c711eddf4dd8afeb11b74928cf2ec6848e57f7345efa06ef9b7d06710f50dd6131e581b52d3d37da8ce9455653588818c20cdc3dd8dcc3b0577a2f1aa2f97b7e6f394ed0e0f30e7f6c82ea51e78c5e18aba96ef77f2cbc35b16fa83a0a76214cfff46e1942b0ab2575344386548569359b8640b91944120d136fbd5208e2e6049e94b54dfaa8c4fe140a25f56cdb27641c2089780b4c9587c64612f7fb4a1212838a4a13fc762cf28e5354f65ac9bdbbd67e835fdc8e618e7e2d0c5d514d8ada6b5cd821a9df4a2b639d76ef1a360d0315e009ce5c438a2252dbd355db489aa82a2aa958678d61db5c84ad57c9fae57454a22e48abc1551ec0f52d8919a23cfb310d66efecb3af3b92d2cfbabbff271dbc21f71def0f6dab6f839b9d452e36d051dc8a402a32c7607e6af867ba7f22b863d7169bfd66ec47d3d6f2d61d422358ecc97a91352430786bd45b247f87fc95d5d86aabad4523683d5f61cccd6f2208e69764ca471b62b44cb4afae8aa1f122f7cef6ed1a295014e83c4549b86a04237a3fbcf56068642910b8badcd038eef7705ecf8c410428da8a9e8d785e0df46961411f9e00e279a3192a6fd0e6c31cb644e98314052f3876dc143da1f19bfe45d27e0fbf0762d89b9d8ab07179f047f36ae913b916d55ef7dd16bf6fa69afe01dbc9ed86baf1336762da16b771dfa467f450229ab71adc406134c60f4cc8f319e7e9d2b1e7dd2122b2eacb7e483f3cf55b757383a63b952f2fdf7f87614c9cfab47ceffa187f7df4c3856cba26bee6108fb439d3a2b47b493a67d9724e7863349d54cdd672e45fb107ff6efcb2eea11e90d3075e14ec48b516a494986076684690c3bd1a36ba7f2c4cb4d029a3da6337c63355a615420c83c6e70c44262ba19659b6b86e766e1e7f7200288d00202684401065b0583af17d53bf54b4f43f04718f910d7947f44abf5879e596048a65a822f70a9a0012f2bf92c3a45bca877d0756d74da8b76e6844502a24c9b28f5086ed1e4959d673a9820194e40004e3c789d3d18bca8c9e40a6bd4523406e4b5e0be8bd0ef3f9fa6e143871ef47f87f3710529c57db8dd68d4f78ac6abeb79b356eef798ecca4251862c70595247e167359d9f27cf551e52fa1f0a08e2dbffddeac9175f56f4348407b205255585f44c0bb88cb9c3168e58ea47d47e2131c4d151083340819d6868c74a8c0a0ef8d38f845f6b92cb48945c62a8d9c00c151f3b3fb79fb5a98987fec03bd4a4a6c4a7874bfafed597c0ccf1eb7d63e41fb753f9088849c8858637f17c0daf2b21e0a640dd2b58c9bfb552b52312552e78435db3da22656a0bb42bce08ad18f9ea7c7ad7de76156d85bfc6694fc6f20f20a3459451681cd0f436eccb1dec3b98ce1724a3be3abc2fe0bd0425da4bd3afbfe7cbad0cfa981408aec0636fbe51420e5940e525d47c2887ddae2d91c19aa7747976c560a236dfb6dea769996d0ffee7222f120e70a5796466ab83a324e86e567f62195984bbd7ca6514242681690899720874a6328f34a3057e97ee405d3c8688f9b88ca17e94c398f3c0679a513983cc18dd29c965d9b2d72ae5ecd6e6be25f5c6575ac4d45acd0b30a39202e0658b2434d2f5479ecde3c4b2244c1d3117ab5fb3199517\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["机考","华为"]},{"title":"堂吉诃德的科幻之旅","url":"/2023/04/09/%E5%AE%87%E5%AE%99%E6%8E%A2%E7%B4%A2%E7%BC%96%E8%BE%91%E9%83%A8/","content":"首发知乎\n在愚人节这一天，把去年愚人节影评搬上来，哈哈哈\n&nbsp;在看宇宙探索编辑部之前我看了很多关于这部电影的安利与差评，但最后还是决定看一看，事实证明这个选择是正确的。\n首先谈谈这部片的类别，与其说是科幻片，其实更像是一部文艺片。电影没有像很多科幻作品一样的硬核大场面，讨论的甚至都不是软科幻而更像是民科（里面主角之一的孙一通直接让我联想到一款中式恐怖游戏《三伏》）。但事实上，这部片却比很多所谓科幻片更科幻，它更接近科幻的本质问题：人类在宇宙中存在的意义是什么。我很喜欢电影以一种荒诞的黑色幽默探讨科幻的本质与人类的意义。\n然后这部片被诟病最多的是伪纪录片的拍摄方式。我看片的时候一直在思考记录者是谁，直到电影中间孙一通让所有人闭眼并用手捂上镜头，我才意识到这是打破了第四堵墙，每一个观众都是记录者。但是也是为了这种形式电影全程采用手持镜头拍摄，全程画面抖动很厉害，我坐在最后一排看久了都有很强的眩晕感，想要呕吐，最后看完大脑和小脑都是晕的。\n我很喜欢电影中埋下的很多隐喻。这部片的英文名journey to the west(西游记)，暗示着主角团五人深入西南寻找外星人之旅正对应着西游记唐僧一行人西天取经。唐僧求取的是真经天道，而唐志军追寻的是宇宙终极奥义。同时唐志军又很像堂吉诃德，偏执地追寻着虚无缥缈的外星人，哪怕在现实世界里屡屡碰壁也是种坚持理想。他的所作所为明明更像是一个民科，却比任何人都讲求严谨科学；他看似精神偏离常人，却更清醒地寻找着人类的意义。影片后半部分有一段老唐骑着毛驴，笑着淌过小溪，有着强烈的荒诞感，却又让观众意识到老唐追寻的过程远比答案重要。\n石狮子嘴里含的球是一个贯穿全片也很有意思的点。本以为唐志军一行人是踏上向外星人取球的路，结果最后孙一通揭露真相他是来送球的。取球和送球身份的转换刚好对应唐志军内心对于终极问题理解上的转换。唐志军本希望通过外星人来解答关于人类存在意义的问题，孙一通却反问外星人可能也不知道，甚至外星人来地球也是为了获得这个答案。这就跟西天取经取到的是无字天书一样，生命的本质就是无意义。所谓意义其实是每个人在一天天的生活中不断创造赋予的，我们要将无意义的生命过成有意义的人生。回归现实生活，直面荒诞人生，才是这个终极问题的答案。这一点跟加缪的观点很像，除了没用的肉体自杀和精神逃避,第三种自杀的态度是坚持奋斗,对抗人生的荒谬。老唐最终领悟了，不像女儿一样自杀，也不像之前一样精神逃避，他选择重新回归生活，创造自己人生存在的意义。\n影片最后是一段超长镜头，展示从人类到地球到太阳系到银河系到宇宙，最后整个宇宙扭曲形成了人类双螺旋的DNA，起点亦是终点，人类苦苦追寻的意义不过是人类本身。\n电影我估计以后都不会再看了，看一次头真的很晕，但影片带给我的思考会持续很久。\n","categories":["影评"],"tags":["影评"]},{"title":"2024春招冲刺算法百题","url":"/2024/04/15/%E6%98%A5%E6%8B%9B%E5%86%B2%E5%88%BA%E7%99%BE%E9%A2%98/","content":"前言算法刷题之旅继续！！！\n其实是被机考考得太差打击到了，不得不继续刷题\n现在刷的题库「2024春招冲刺百题计划」以及会有一些每日一题和补充相应类别比较特殊重要的题目\n语言是javascript，会按照题型分类刷，只记录中等及以上的题目解法，简单题一般只会记录一些特殊规律做法\n真实水平是不看题解，只能做出简答题\n目前还未刷完，持续更新~\n\n模拟54.螺旋矩阵题目给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n解析一层一层的回旋记录\n/** * @param {number[][]} matrix * @return {number[]} */var spiralOrder = function(matrix) {    let res=[];    if(matrix.length==0){        return res;    }    let t=0,b=matrix.length-1,l=0,r=matrix[0].length-1;    while(true){        for(let i=l;i&lt;=r;i++){            res.push(matrix[t][i]);        }        if(++t&gt;b)break;        for(let i=t;i&lt;=b;i++){            res.push(matrix[i][r]);        }        if(--r&lt;l)break;        for(let i=r;i&gt;=l;i--){            res.push(matrix[b][i]);        }        if(--b&lt;t)break;        for(let i=b;i&gt;=t;i--){            res.push(matrix[i][l]);        }        if(++l&gt;r)break;    }    return res;};\n59.螺旋矩阵Ⅱ题目给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n解析是前面一道题的逆过程\n/** * @param {number} n * @return {number[][]} */var generateMatrix = function(n) {    let matrix=new Array(n).fill(0).map(()=&gt;new Array(n).fill(0));    let t=0,b=n-1,l=0,r=n-1;    let e=1;    while(e&lt;=n*n){        for(let i=l;i&lt;=r;i++){            matrix[t][i]=e++;        }        ++t;        for(let i=t;i&lt;=b;i++){            matrix[i][r]=e++;        }        --r;        for(let i=r;i&gt;=l;i--){            matrix[b][i]=e++;        }        --b;        for(let i=b;i&gt;=t;i--){            matrix[i][l]=e++;        }        ++l;    }    return matrix;};\n289.生命游戏题目给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；如果死细胞周围正好有三个活细胞，则该位置死细胞复活；下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。\n\n解析这里有坑，如果直接在原数组上更新，会导致出错，因为每一次更新是所有节点同时更新，依赖的是上一轮的状态，如果挨个挨个更新，会导致前面更新后的状态影响后续节点更新。如果把原数组复制一遍，额外使用的空间过多\n减少空间使用的方法是用额外的状态来标识节点情况\n本题可以简化成四种判断条件，用二进制位来表示，1代表活，0代表死，最后一位是更新前的状态，倒数第二位是更新后的状态，后面变化状态只需要右移一位\n\n原来是活的，最后是活的 11\n原来是活的，最后是死的 01\n原来是死的，最后是活的 10\n原来是死的，最后是死的 00\n\n我的状态belike：原来是死的，最后是死的\n/** * @param {number[][]} board * @return {void} Do not return anything, modify board in-place instead. */var gameOfLife = function(board) {    const neighbors=[0,-1,1];    let rows=board.length,cols=board[0].length;    for(let i=0;i&lt;rows;i++){        for(let j=0;j&lt;cols;j++){            let live=0;            for(let m=0;m&lt;3;m++){                for(let n=0;n&lt;3;n++){                    if(!(neighbors[n]==0&amp;&amp;neighbors[m]==0)){                        let r=i+neighbors[n];                        let c=j+neighbors[m];                        if(r&lt;rows&amp;&amp;r&gt;=0&amp;&amp;c&lt;cols&amp;&amp;c&gt;=0){                            live+=1&amp;board[r][c];                        }                    }                }            }            if(board[i][j]==1){                board[i][j]+=(live==2||live==3)?2:0;            }else{                board[i][j]+=(live==3)?2:0;            }        }    }    for(let i=0;i&lt;rows;i++){        for(let j=0;j&lt;cols;j++){            board[i][j]&gt;&gt;=1;        }}};\n48.旋转图像题目给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n\n解析\n先上下翻转，再对角线翻转\n/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */var rotate = function(matrix) {    const n = matrix.length;    // 水平翻转    for (let i = 0; i &lt; Math.floor(n / 2); i++) {        for (let j = 0; j &lt; n; j++) {            [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];        }    }    // 主对角线翻转    for (let i = 0; i &lt; n; i++) {        for (let j = 0; j &lt; i; j++) {            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];        }    }};\n1515.换水问题题目\n超市正在促销，你可以用 numExchange 个空水瓶从超市兑换一瓶水。最开始，你一共购入了 numBottles 瓶水。\n如果喝掉了水瓶中的水，那么水瓶就会变成空的。\n给你两个整数 numBottles 和 numExchange ，返回你 最多 可以喝到多少瓶水。\n\n解析\n小学的我薄纱大学的我\n本题是简单题，换水过程相当于每一次换水损失numExchange个瓶子，但得到一个瓶子，总损失量numExchange-1，保证到最后累计拥有的瓶子减去损失瓶子不足以再换就行numBottles-n(numExchange-1)&lt;numExchange\n\nvar numWaterBottles = function(numBottles, numExchange) {    return numBottles &gt;= numExchange ? Math.floor((numBottles - numExchange) / (numExchange - 1)) + 1 + numBottles : numBottles;};\n\n栈94.二叉树中序遍历(非递归)题目给定一个二叉树的根节点 root ，返回 它的 中序 遍历\n\n解析递归很简单，这里用迭代和莫里斯\n//迭代var inorderTraversal = function(root) {    const res = [];    const stk = [];    while (root || stk.length) {        //先找到最左节点，依次入栈        while (root) {            stk.push(root);            root = root.left;        }        //挨个出栈，按照左中右的顺序push进res        root = stk.pop();        res.push(root.val);        root = root.right;    }    return res;};\n//莫里斯//优势在于没有额外的空间复杂度//就是把树状结构转换成链表//把根节点和右子树挂到左子树的右子节点上var inorderTraversal = function(root) {    const res = [];    let predecessor = null;    while (root) {        if (root.left) {            // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止            predecessor = root.left;            while (predecessor.right &amp;&amp; predecessor.right !== root) {                predecessor = predecessor.right;            }            // 让 predecessor 的右指针指向 root，继续遍历左子树            if (!predecessor.right) {                predecessor.right = root;                root = root.left;            }            // 说明左子树已经访问完了，我们需要断开链接            else {                res.push(root.val);                predecessor.right = null;                root = root.right;            }        }        // 如果没有左孩子，则直接访问右孩子        else {            res.push(root.val);            root = root.right;        }    }    return res;};\n2007.从双倍数组中还原原数组题目一个整数数组 original 可以转变成一个 双倍 数组 changed ，转变方式为将 original 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。\n给你一个数组 changed ，如果 change 是 双倍 数组，那么请你返回 original数组，否则请返回空数组。original 的元素可以以 任意 顺序返回。\n\n解析\n\nO(nlogn)这个做法主要是先排序，保证在遍历changed数组时先遇到的一定是1倍数，后面才会遇到对应的双倍数，后面就可以只遍历一次找原数组\n\nvar findOriginalArray = function(changed) {    if(changed.length%2==1){        return [];    }    changed.sort((a, b) =&gt; a - b);    const count = {};    for (const num of changed) {        count[num] = (count[num] || 0) + 1;    }    const res = [];    for (const a of changed) {        if (count[a] === 0) {            continue;        }        count[a]--;        if (!count[a * 2]) {            return [];        }        count[a * 2]--;        res.push(a);    }    return res;};\n\nO(n)\n\n很巧妙的消消乐思路，不用排序\n举个例子就是 1,2,3,6,8,16。用1消掉2,3消掉6,8消掉16，只要当前x对应的在数组里就先跳过，等到不在数组就查找2x是否在数组里，在的话一起消掉\nvar findOriginalArray = function(changed) {    if(changed.length%2==1){        return [];    }     const cnt = new Map();    for (const x of changed) {        cnt.set(x, (cnt.get(x) ?? 0) + 1);    }    // 单独处理 0    const cnt0 = cnt.get(0) ?? 0;    if (cnt0 % 2) {        return [];    }    cnt.delete(0);    const ans = Array(cnt0 / 2).fill(0);    for (let x of cnt.keys()) {        // 如果 x/2 在 cnt 中，则跳过        if (cnt.has(x / 2)) {            continue;        }        // 把 x, 2x, 4x, 8x, ... 全部配对        while (cnt.has(x)) {            // 每次循环，把 cntX 个 x 和 cntX 个 2x 配对            const cntX = cnt.get(x);            const cnt2x = cnt.get(x * 2) ?? 0;            // 无法配对，至少要有 cntX 个 2x            if (cntX &gt; cnt2x) {                return [];            }            ans.push(...Array(cntX).fill(x));            if (cntX &lt; cnt2x) {                // 还剩下一些 2x                cnt.set(x * 2, cnt2x - cntX);                x *= 2;            } else {                x *= 4;            }        }    }    return ans;};\n402.移掉k位数字题目给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。\n\n解析\n贪心+单调栈\n如果只删一个数，一定是删除从左往右第一个比下一个数大的数，最终能得到的数最小。给定一个长度为 n 的数字序列 ，从左往右找到第一个位置 i（i&gt;0）使得 ，并删去 ；如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。\n然后再对剩下的序列继续删除一个数，直到删除了k次\nvar removeKdigits = function(num, k) {    const stk = [];    for (const digit of num) {        while (stk.length &gt; 0 &amp;&amp; stk[stk.length - 1] &gt; digit &amp;&amp; k) {            stk.pop();            k -= 1;        }        stk.push(digit);    }    for (; k &gt; 0; --k) {        stk.pop();    }    let ans = \"\";    let isLeadingZero = true;    for (const digit of stk) {        if (isLeadingZero &amp;&amp; digit === '0') {            continue;        }        isLeadingZero = false;        ans += digit;    }    return ans === \"\" ? \"0\" : ans;};\n316.去除重复字母题目给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。\n\n解析\nvar removeDuplicateLetters = function(s) {    const vis = new Array(26).fill(0);    const num = _.countBy(s);        const sub = new Array();    for (let i = 0; i &lt; s.length; i++) {        const ch = s[i];        //ascll码的妙用        if (!vis[ch.charCodeAt() - 'a'.charCodeAt()]) {            while (sub.length &gt; 0 &amp;&amp; sub[sub.length - 1] &gt; ch) {                if (num[sub[sub.length - 1]] &gt; 0) {                    vis[sub[sub.length - 1].charCodeAt() - 'a'.charCodeAt()] = 0;                    sub.pop();                } else {                    break;                }            }            vis[ch.charCodeAt() - 'a'.charCodeAt()] = 1;            sub.push(ch);        }        num[ch]--;    }    return sub.join('');};\n321.拼接最大数题目给你两个整数数组 nums1 和 nums2，它们的长度分别为 m 和 n。数组 nums1 和 nums2 分别代表两个数各位上的数字。同时你也会得到一个整数 k。\n请你利用这两个数组中的数字中创建一个长度为 k &lt;= m + n 的最大数，在这个必须保留来自同一数组的数字的相对顺序。\n返回代表答案的长度为 k 的数组。\n\n解析\n本题的思路是两个数组都返回一个保持原数组顺序的从大到小的单调栈，然后两个单调栈进行合并，保证相对顺序不变和位数限制k的情况下最大的数\n但是跟普通的单调栈又有区别，就是单调栈内的元素不是全部有序的！因为限制了单调栈返回的元素，其实就是数组里有序的数量小于数组应该返回的数量，这个时候为了达到数量，后面的元素直接入栈，类似在有序元素后面拼接无序元素凑数\n/** * @param {number[]} nums1 * @param {number[]} nums2 * @param {number} k * @return {number[]} */var maxNumber = function(nums1, nums2, k) {    const m = nums1.length, n = nums2.length;    const maxSubsequence = new Array(k).fill(0);    let start = Math.max(0, k - n), end = Math.min(k, m);    for (let i = start; i &lt;= end; i++) {        const subsequence1 = new MaxSubsequence(nums1, i);        const subsequence2 = new MaxSubsequence(nums2, k - i);        const curMaxSubsequence = merge(subsequence1, subsequence2);        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) &gt; 0) {            maxSubsequence.splice(0, k, ...curMaxSubsequence);        }    }    return maxSubsequence;};var MaxSubsequence = function(nums, k) {    const length = nums.length;    const stack = new Array(k).fill(0);    let top = -1;    let remain = length - k;    for (let i = 0; i &lt; length; i++) {        const num = nums[i];        while (top &gt;= 0 &amp;&amp; stack[top] &lt; num &amp;&amp; remain &gt; 0) {            top--;            remain--;        }        if (top &lt; k - 1) {            stack[++top] = num;        } else {            remain--;        }    }    return stack;}const merge = (subsequence1, subsequence2) =&gt; {    const x = subsequence1.length, y = subsequence2.length;    if (x === 0) {        return subsequence2;    }    if (y === 0) {        return subsequence1;    }    const mergeLength = x + y;    const merged = new Array(mergeLength).fill(0);    let index1 = 0, index2 = 0;    for (let i = 0; i &lt; mergeLength; i++) {        if (compare(subsequence1, index1, subsequence2, index2) &gt; 0) {            merged[i] = subsequence1[index1++];        } else {            merged[i] = subsequence2[index2++];        }    }    return merged;}const compare = (subsequence1, index1, subsequence2, index2) =&gt; {    const x = subsequence1.length, y = subsequence2.length;    while (index1 &lt; x &amp;&amp; index2 &lt; y) {        const difference = subsequence1[index1] - subsequence2[index2];        if (difference !== 0) {            return difference;        }        index1++;        index2++;    }    return (x - index1) - (y - index2);}\n\n队列857.雇佣k名工人的最低成本题目有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。\n现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：\n对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。工资组中的每名工人至少应当得到他们的最低期望工资。给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。\n\n解析\n假设我们已经选择了某一个工资组，组成成员为 [h1,h2,⋯ ,hk]，其中 hi表示第 hi个工人，整个工作组的总工作质量为：totalq，总的支付金额为 totalc。那么按照题目的要求对于任意工人 hi要满足： 即： 所以当某一个工资组的总工作质量固定时，最少的付费金额只与工资组中  有关\n/** * @param {number[]} quality * @param {number[]} wage * @param {number} k * @return {number} */var mincostToHireWorkers = function(quality, wage, k) {    const n=quality.length;    const arr=new Array(n).fill(0).map((_,i)=&gt;i);    //也可以const arr=[...Array(n).keys()];    //arr里存储的是工资质量比从小到大的下标    //这样保证了后面相乘的时候当前的比一定是最大的    arr.sort((a,b)=&gt;{        return wage[a]*quality[b]-wage[b]*quality[a];    });    let res=1e9;    let totalq=0.0;    //最大堆是按照quality大小来的，尽量留下总quality最小的k个    const pq=new MaxPriorityQueue();    for(let i=0;i&lt;k-1;i++){        totalq+=quality[arr[i]];        pq.enqueue(quality[arr[i]]);    }    for(let i=k-1;i&lt;n;i++){        totalq+=quality[arr[i]];        pq.enqueue(quality[arr[i]]);        const totalc=wage[arr[i]]/quality[arr[i]]*totalq;        res=Math.min(res,totalc);        totalq-=pq.dequeue().element;    }    return res;};\n2071.你可以安排的最多任务数目题目\n给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] &gt;= tasks[i] ）。\n除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。\n给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。\n\n解析\n936.戳印序列题目你想要用小写字母组成一个目标字符串 target。\n开始的时候，序列由 target.length 个 ‘?’ 记号组成。而你有一个小写字母印章 stamp。\n在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length  个回合。\n举个例子，如果初始序列为 “?????”，而你的印章 stamp 是 “abc”，那么在第一回合，你可以得到 “abc??”、”?abc?”、”??abc”。（请注意，印章必须完全包含在序列的边界内才能盖下去。）\n如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。\n例如，如果序列是 “ababc”，印章是 “abc”，那么我们就可以返回与操作 “?????” -&gt; “abc??” -&gt; “ababc” 相对应的答案 [0, 2]；\n另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。\n\n解析每一次印章会覆盖前一个，因此最后一个印的一定是完整的，所以倒推。序列中完整的戳印是最后印的，然后用?代替覆盖部分，表示此处位置可以是任何值，接着对序列继续进行印章匹配，匹配完用?替代，以此类推\n/** * @param {string} stamp * @param {string} target * @return {number[]} */var movesToStamp = function(stamp, target) {    const res=[];    let index=target.indexOf(stamp);    if(index==-1){        return res;    }    const fill=new Array(stamp.length).fill(\"?\").join(\"\");    const final=new Array(target.length).fill(\"?\").join(\"\");    target=target.slice(0,index)+fill+target.slice(index+stamp.length);    res.unshift(index);    const match=(str)=&gt;{        if(str==stamp){            return true;        }        for(let i=0;i&lt;str.length;i++){            if(str[i]!=stamp[i]&amp;&amp;str[i]!=\"?\"){                return false;            }        }        return true;    }    let flag=true;    while(flag){        flag=false;        if(final==target){            return res;        }        for(let j=0;j&lt;=target.length-stamp.length;j++){            if(final.slice(j,j+stamp.length)==target.slice(j,j+stamp.length)){                continue;            }            if(match(target.slice(j,j+stamp.length))){                res.unshift(j);                target=target.slice(0,j)+fill+target.slice(j+stamp.length);                flag=true;            }        }    }    return [];};\n\n堆264.丑数Ⅱ题目给你一个整数 n ，请你找出并返回第 n 个 丑数 。丑数 就是质因子只包含 2、3 和 5 的正整数。\n\n解析\n我的代码也很丑陋\n\n最小堆初始时堆为空，现将最小丑数1加入堆，然后每次取出堆顶元素x，把2x,3x,5x入堆，然后不断循环，第n次从最小堆取出的元素就是第n个丑数\n\nvar nthUglyNumber = function(n) {    const factors = [2, 3, 5];    //防止重复元素    const seen = new Set();    const heap = new MinHeap();    seen.add(1);    heap.insert(1);    let ugly = 0;    for (let i = 0; i &lt; n; i++) {        ugly = heap.pop();        for (const factor of factors) {            const next = ugly * factor;            if (!seen.has(next)) {                seen.add(next);                heap.insert(next);            }        }            }    return ugly;};// 最小堆class MinHeap {    constructor() {        this.heap = [];    }    getParentIndex(i) {        return (i - 1) &gt;&gt; 1;    }    getLeftIndex(i) {        return i * 2 + 1;    }    getRightIndex(i) {        return i * 2 + 2;    }    shiftUp(index) {        if(index === 0) { return; }        const parentIndex = this.getParentIndex(index);        if(this.heap[parentIndex] &gt; this.heap[index]){            this.swap(parentIndex, index);            this.shiftUp(parentIndex);        }      }    swap(i1, i2) {        const temp = this.heap[i1];        this.heap[i1]= this.heap[i2];        this.heap[i2] = temp;    }    insert(value) {        this.heap.push(value);        this.shiftUp(this.heap.length - 1);    }    pop() {        this.heap[0] = this.heap.pop();        this.shiftDown(0);        return this.heap[0];    }    shiftDown(index) {        const leftIndex = this.getLeftIndex(index);        const rightIndex = this.getRightIndex(index);        if (this.heap[leftIndex] &lt; this.heap[index]) {            this.swap(leftIndex, index);            this.shiftDown(leftIndex);        }        if (this.heap[rightIndex] &lt; this.heap[index]){            this.swap(rightIndex, index);            this.shiftDown(rightIndex);        }    }    peek() {        return this.heap[0];    }    size() {        return this.heap.length;    }}\n\n动态规划\n\ndp[i]是指第i个丑数，使用三个指针表示下一个丑数是当前指针指向的丑数乘以 2 , 3 , 5，每次都比较这三个指针乘以2,3,5之后的最小值，被选中的指针向右移动一位，\nvar nthUglyNumber = function(n) {    const dp = new Array(n + 1).fill(0);    dp[1] = 1;    let p2 = 1, p3 = 1, p5 = 1;    for (let i = 2; i &lt;= n; i++) {        const num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;        dp[i] = Math.min(Math.min(num2, num3), num5);        if (dp[i] === num2) {            p2++;        }        if (dp[i] === num3) {            p3++;        }        if (dp[i] === num5) {            p5++;        }    }    return dp[n];};\n373.查找和最小的K对数字题目给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。\n定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。\n请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  …  (uk,vk) 。\n\n解析多路并归\n其实就是最小堆，但是js实现堆操作太恶心了，改用java，用现成的数据结构\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) {        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(k, (o1, o2)-&gt;{            return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];        });        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        int m = nums1.length;        int n = nums2.length;        for (int i = 0; i &lt; Math.min(m, k); i++) {            pq.offer(new int[]{i,0});        }        while (k-- &gt; 0 &amp;&amp; !pq.isEmpty()) {            int[] idxPair = pq.poll();            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            list.add(nums1[idxPair[0]]);            list.add(nums2[idxPair[1]]);            ans.add(list);            if (idxPair[1] + 1 &lt; n) {                pq.offer(new int[]{idxPair[0], idxPair[1] + 1});            }        }                return ans;    }}\n诶，突然发现力扣的js环境支持最小优先队列 MinPriorityQueue 和 最大优先队列 MaxPriorityQueue\n/** * @param {number[]} nums1 * @param {number[]} nums2 * @param {number} k * @return {number[][]} */var kSmallestPairs = function (nums1, nums2, k) {    const res = [];    const pq = new MinPriorityQueue({ compare: (a, b) =&gt; nums1[a[0]] + nums2[a[1]] - (nums1[b[0]] + nums2[b[1]]) });    for (let i = 0; i &lt; Math.min(k, nums1.length);  i++) pq.enqueue([i, 0]);    while (res.length &lt; k &amp;&amp; pq.size()) {        const [i, j] = pq.dequeue();        if (j + 1 &lt; nums2.length) pq.enqueue([i, j + 1]);        res.push([nums1[i], nums2[j]]);    }    return res;};\n\n双指针88.合并两个有序数组(不用额外空间)题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n解析创建一个额外空间数组很简单，但是不使用额外空间的思路挺有意思，是逆向双指针，从后往前比较，放到nums1的尾部，这样就不会出现从前往后的覆盖问题\n/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) {    let p1=m-1,p2=n-1;    let cur=m+n-1;    while(p1&gt;=0||p2&gt;=0){        if(p1==-1){            cur=nums2[p2--];        }else if(p2==-1){            cur=nums1[p1--];        }else if(nums1[p1]&gt;nums2[p2]){            cur=nums1[p1--];        }else {            cur=nums2[p2--];        }        nums1[p1+p2+2]=cur;    }};\n31.下一个排列题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n解析\n从后往前遍历，让遇到的第一个nums[i] &lt; nums[i + 1]与遇到的第一个nums[j] &gt; nums[i]互换位置(这里j一定在[i+1,len-1)里面)，然后[i+1,len-1)倒序排列\n/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var nextPermutation = function (nums) {    const len = nums.length;    let i = len - 2;    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {        i--;    }    let j = len - 1;    if (i &gt;= 0) {        while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) {            j--;        }        [nums[i], nums[j]] = [nums[j], nums[i]];    }    let l = i + 1, r = len - 1;    while (l &lt; r) {        [nums[l++], nums[r--]] = [nums[r], nums[l]];    }};\n189.轮转数组题目给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n\n解析可以反转数组，之前为了图省事直接用的数组reverse接口然后转换成字符串拼接，但是忽略了数组和翻转后字符串互转的时候不好判断每个数的位数，例如本来是17，反转后变成71了，就会出错，还是老老实实写一个reverse接口了\n/** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */var rotate = function (nums, k) {    const reverse = (l, r) =&gt; {        while (l &lt; r) {            const tmp = nums[l];            nums[l] = nums[r];            nums[r] = tmp;            l++;            r--;        }    }    k%=nums.length;    reverse(0, nums.length - 1);    reverse(0, k - 1);    reverse(k, nums.length - 1);};\n\n滑动窗口1052.爱生气的书店老板题目有一个书店老板，他的书店开了 n 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 n 的整数数组 customers ，其中 customers[i] 是在第 i 分钟开始时进入商店的顾客数量，所有这些顾客在第 i 分钟结束后离开。\n在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。\n当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。\n书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 minutes 分钟不生气，但却只能使用一次。\n请你返回 这一天营业下来，最多有多少客户能够感到满意 。\n\n解析经典滑动窗口，维护一个长度为 minutes 的滑动窗口。当滑动窗口从下标范围 [i−minutes,i−1] 移动到下标范围 [i−minutes+1,i] 时，下标 i−minutesi 从窗口中移出，下标 i 进入到窗口内\n/** * @param {number[]} customers * @param {number[]} grumpy * @param {number} minutes * @return {number} */var maxSatisfied = function(customers, grumpy, minutes) {    let total=0;    const len=customers.length;    for(let i=0;i&lt;len;i++){        if(grumpy[i]==0){            total+=customers[i];        }    }    let increase=0;    for(let i=0;i&lt;minutes;i++){        //注意这里求的是生气后不满意的顾客数        increase+=customers[i]*grumpy[i];    }    let max=increase;    for(let i=minutes;i&lt;len;i++){        increase=increase-customers[i-minutes]*grumpy[i-minutes]+customers[i]*grumpy[i];        max=Math.max(increase,max);    }    return total+max;};S\n187.重复的DNA序列题目DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。\n例如，”ACGAATTCCG” 是一个 DNA序列 。在研究 DNA 时，识别 DNA 中的重复序列非常有用。\n给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。\n\n解析\n/** * @param {string} s * @return {string[]} */var findRepeatedDnaSequences = function(s) {    let res=[];    let cnt=new Map();    for(let i=0;i&lt;=s.length-10;i++){        const sub=s.slice(i,i+10);        cnt.set(sub,(cnt.get(sub)||0)+1);        if(cnt.get(sub)===2){            res.push(sub);        }    }    return res;};\n480.滑动窗口中位数题目中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。\n例如：\n[2,3,4]，中位数是 3[2,3]，中位数是 (2 + 3) / 2 = 2.5给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。\n\n解析这个题用javascript简直是灾难，因为js内置的MaxPriorityQueue和MinPriorityQueue处理不了大数，自己建堆不仅麻烦还会超时，我真是服了\n尽管如此，我还是觉得这个解题思路值得学一下，尽管js永远无法解决\n双堆和延迟删除。使用最大堆存放窗口中较小的部分，使用最大堆存放窗口中较小的部分，那么两个堆的堆顶配合窗口的奇偶性可以推出中位数。\n窗口每次移动，就比较左右边界和两个堆顶元素的情况，由于要保证两个堆里元素个数平衡，用balance记录大小堆更新元素后的平衡情况。有三种可能，增和删在同一个堆里，balance为0；small增big减，balance为2；big增small减，balance为-2。不平衡的话就从多的堆顶弹出，推入少的堆里。\n这里注意在堆里不好实现删除，所以用map做删除标记，每次弹出元素时才判断该元素是否已被删除，然后删除了的就彻底弹出，不推入另一个堆。\n/** * @param {number[]} nums * @param {number} k * @return {number[]} */var medianSlidingWindow = function (nums, k) {    const small = new MaxPriorityQueue(); // 使用最大堆存放窗口中较小的部分    const big = new MinPriorityQueue(); // 使用使用最大堆存放窗口中较小的部分最小堆存放窗口中较大的部分    const mp = new Map(); // 使用 Map 存放元素及其出现次数    function getMedian() {        if (small.size() &gt; big.size()) {            return small.front().element;        } else {            return (small.front().element+ big.front().element)/ 2.0;        }    }    // 初始化小顶堆    for (let i = 0; i &lt; k; i++) {        small.enqueue(nums[i]);    }    // 调整使得 small 和 big 保持平衡    for (let i = 0; i &lt; Math.floor(k / 2); i++) {        big.enqueue(small.dequeue().element);    }    const ans = [getMedian()]; // 存放结果    for (let i = k; i &lt; nums.length; i++) {        let balance = 0;        const l = nums[i - k];        mp.set(l, (mp.get(l) || 0) + 1);        if (!small.isEmpty() &amp;&amp; l &lt;= small.front().element) {            balance--;        } else {            balance++;        }        if (!small.isEmpty() &amp;&amp; nums[i] &lt;= small.front().element) {            small.enqueue(nums[i]);            balance++;        } else {            big.enqueue(nums[i]);            balance--;        }        if (balance &gt; 0) {            big.enqueue(small.dequeue().element);        }        if (balance &lt; 0) {            small.enqueue(big.dequeue().element);        }        while (!small.isEmpty() &amp;&amp; mp.get(small.front().element) &gt; 0) {            mp.set(small.front().element, mp.get(small.front().element) - 1);            small.dequeue();        }        while (!big.isEmpty() &amp;&amp; mp.get(big.front().element) &gt; 0) {            mp.set(big.front().element, mp.get(big.front().element) - 1);            big.dequeue();        }        ans.push(getMedian());    }    return ans;};\n1652. 拆炸弹题目你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。\n为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。\n如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。如果 k == 0 ，将第 i 个数字用 0 替换。由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。\n给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！\n\n解析题目不难，值得注意的点在于可以创建一个两倍长度的数组来表示循环数组上\n/** * @param {number[]} code * @param {number} k * @return {number[]} */var decrypt = function(code, k) {    const n = code.length;    if (k === 0) {        return new Array(n).fill(0);    }    const res = new Array(n).fill(0);    const newCode = new Array(n * 2).fill(0).map((_, idx) =&gt; {        return code[idx % code.length];    });    code = newCode;    let l = k &gt; 0 ? 1 : n + k;    let r = k &gt; 0 ? k : n - 1;    let w = 0;    for (let i = l; i &lt;= r; i++) {        w += code[i];    }    for (let i = 0; i &lt; n; i++) {        res[i] = w;        w -= code[l];        w += code[r + 1];        l++;        r++;    }    return res;};\n2831. 找出最长等值子数组题目给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。\n如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是 等值子数组 。\n从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。\n子数组 是数组中一个连续且可能为空的元素序列。\n\n解析本题一个比较绕的地方在于窗口边界定义，先用哈希记录下每个数出现在哪些位置，注意循环中的l和r指的是对应数出现的位置数组里的边界下标，r-l+1表示在这个窗口里出现了几次该数字，而val[r]和val[l]表示在原数组里的边界下标，val[r]-val[l]+1表示在这个窗口里的数字总数。两个相减得到的就是要删去的元素\n/** * @param {number[]} nums * @param {number} k * @return {number} */var longestEqualSubarray = function(nums, k) {    let len =nums.length;    let pos=new Map();    for(let i=0;i&lt;len;i++){        if(!pos.has(nums[i])){            pos.set(nums[i],[]);        }        pos.get(nums[i]).push(i);    }    let ans=0;    for(const val of pos.values()){        for(let l=0,r=0;r&lt;val.length;r++){            while(val[r]-val[l]-(r-l)&gt;k){                l++;            }            ans=Math.max(ans,r-l+1);        }    }    return ans;};\n632.最小区间题目你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。\n我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。\n\n解析题目简单来说就是要找一个最小的区间，在这个区间里每个整数列表至少包括一次。那么可以使用哈希表加滑动窗口来解。本题的重点在于哈希映射的对象是什么，思维不是在单个列表里选取小区间，而是应该抽象出来，看哪个区间里能覆盖的列表数量最多。那么就应该把一个元素和这个元素在哪些列表中出现过做哈希映射，然后将哈希表的键排序，滑动窗口比较最小的能覆盖所有列表的区间\n我自己的做法官方的最后一个用例会超时，我主要是用了set来帮助去重，但是这样在后面滑动窗口时移动窗口判断重复的数组很麻烦，会超时，比较下来用数组记录出现次数，然后移动的时候相减就会容易一些\nconst smallestRange = (nums) =&gt; {  let allNums = [];  let map = {};  for (let i = 0; i &lt; nums.length; i++) {    map[i] = 0;          // 初始化出现次数    for (let j = 0; j &lt; nums[i].length; j++) {      allNums.push({        num: nums[i][j], // 数值本身        type: i          // 来源于哪个数组      });    }  }  allNums.sort((a, b) =&gt; a.num - b.num);  let left = 0;  let count = 0;  let minLen = Infinity;  let minStart = 0;  for (let right = 0; right &lt; allNums.length; right++) { // 主旋律定为扩张    if (map[allNums[right].type] == 0) count++;          // 纳入了之前没纳入的目标数字，count++    map[allNums[right].type]++;                          // 纳入数字，对应的出现次数+1    while (count == nums.length &amp;&amp; left &lt;= right) { // 找齐所有目标数字，且区间不被破坏的前提下收缩      if (allNums[right].num - allNums[left].num &lt; minLen) { // 出现了比minLen更小的解        minLen = allNums[right].num - allNums[left].num;     // 更新minLen        minStart = allNums[left].num;                        // 更新minStart      }      map[allNums[left].type]--;                 // left指向的数字被抛弃，收缩前更新map      if (map[allNums[left].type] == 0) count--; // 如果出现次数因此减为0，count--      left++;                                    // 收缩窗口，left右移    }  }  return [minStart, minStart + minLen];};\n\n链表2.两数相加题目给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n解析\n这个题使用链表存储数字的每一位，数字的低位到高位是链表从右到左的顺序，所以是逆序，要注意进位的问题\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function (l1, l2) {    let head = null, tail = null;    let carry = 0;    while (l1 || l2) {        const n1 = l1 ? l1.val : 0;        const n2 = l2 ? l2.val : 0;        const sum = n1 + n2 + carry;        carry = Math.floor(sum / 10);        if (!head) {            head = tail = new ListNode(sum % 10);        } else {            tail.next = new ListNode(sum % 10);            tail = tail.next;        }        if (l1) l1 = l1.next;        if (l2) l2 = l2.next;    }    if(carry&gt;0){        tail.next=new ListNode(carry);    }    return head;};\n\n排序220.存在重复元素Ⅲ题目给你一个整数数组 nums 和两个整数 indexDiff 和 valueDiff 。找出满足下述条件的下标对 (i, j)：i != j,abs(i - j) &lt;= indexDiffabs(nums[i] - nums[j]) &lt;= valueDiff如果存在，返回 true ；否则，返回 false。\n\n解析海康威视笔试原题，考场上只想出来滑动窗口的暴力解法，然后超时了，现在看官方题解才知道桶排\n本题抽象出来就是求一个数x的前后k个数里，存在[x-t,x+t]范围的值。这里设定桶的大小为t+1，即表示为把元素放入这些区间的桶里[0,t],[t+1,2t+1],[2t+1,3t+1]…这样只要两个元素在一个桶里，就代表两者值之差小于等于t，如果是相邻的桶要额外判断一下，非相邻的桶不可能满足要求。\n/** * @param {number[]} nums * @param {number} indexDiff * @param {number} valueDiff * @return {boolean} */var containsNearbyAlmostDuplicate = function (nums, k, t) {    if(t&lt;0){        return false;    }    const map = new Map();    const getIndex = (x) =&gt; {        return Math.floor(x / (t + 1));    }    for (let i = 0; i &lt; nums.length; i++) {        const index = getIndex(nums[i]);        if (map.has(index)) {            return true;        }        if (map.has(index - 1) &amp;&amp; Math.abs(nums[i] - map.get(index - 1)) &lt;= t) {            return true;        }        if (map.has(index + 1) &amp;&amp; Math.abs(nums[i] - map.get(index + 1)) &lt;= t) {            return true;        }        map.set(index, nums[i]);        //注意这里把超出范围的桶删除了        if (i &gt;= k) {            map.delete(getIndex(nums[i - k]));        }    }    return false;};\n\n树230.二叉搜索树中第k小的元素题目给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n\n解析\n\n中序遍历\n\nvar kthSmallest = function (root, k) {    const stack = [];    while (root != null || stack.length) {        while (root != null) {            stack.push(root);            root = root.left;        }        root=stack.pop();        k--;        if(k==0){            break;        }        root=root.right;    }    return root.val;};\nvar kthSmallest = function (root, k) {    const list = [];    const dfs=(node)=&gt;{        if(node==null){            return;        }        dfs(node.left);        list.push(node.val);        dfs(node.right);    }    dfs(root);    return list[k-1];};\n\nAVL官方题解写了个平衡二叉搜索树 我愿称之为屎山代码本题属实是大材小用了\n\n102.二叉树的层序遍历题目给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。\n\n解析层序遍历往往用bfs来做，注意要把每一层单独提取出来\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number[][]} */var levelOrder = function(root) {    if(!root)return[];    let q=[];    let res=[];    q.push(root);    while(q.length){        let len=q.length;        let level=[];        //跟普通bfs的差异在于把每一层单独提出来了        while(len--){            const node=q.shift();            level.push(node.val);            if(node.left!=null){                q.push(node.left);            }            if(node.right!=null){                q.push(node.right);            }        }        res.push(level);    }    return res;};\n103.二叉树的锯齿形层序遍历题目给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n解析不是双端写不起而是reverse更有性价比\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number[][]} */var zigzagLevelOrder = function(root) {if(!root)return[];    let q=[];    let res=[];    let reverse=false;    q.push(root);    while(q.length){        let len=q.length;        let level=[];        //跟普通bfs的差异在于把每一层单独提出来了        while(len--){            const node=q.shift();            level.push(node.val);            if(node.left!=null){                q.push(node.left);            }            if(node.right!=null){                q.push(node.right);            }        }        res.push(reverse==true?level.reverse():level);        reverse=!reverse;    }    return res;};\n1505.最多k次交换相邻数位后得到的最小整数题目给你一个字符串 num 和一个整数 k 。其中，num 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。\n你可以交换这个整数相邻数位的数字 最多 k 次。\n请你返回你能得到的最小整数，并以字符串形式返回。\n\n解析同学腾讯音乐的手撕代码题，特殊做法贪心+树状数组\n\n高级数据结构200.岛屿数量题目给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n此外，你可以假设该网格的四条边均被水包围\n\n解析\n这不就是广州大学城\ndfs或者bfs都可以\n/** * @param {character[][]} grid * @return {number} */var numIslands = function (grid) {    let vis = new Array(grid.length).fill().map(() =&gt; new Array(grid[0].length).fill(0));    const dfs = (curx, cury) =&gt; {        if (curx &lt; 0 || curx &gt;= grid.length || cury &lt; 0 || cury &gt;= grid[0].length || grid[curx][cury] == 0) return;        grid[curx][cury] = 0;        dfs(curx + 1, cury);        dfs(curx, cury + 1);        dfs(curx - 1, cury);        dfs(curx, cury - 1);    }    let res = 0;    for (let i = 0; i &lt; grid.length; i++) {        for (let j = 0; j &lt; grid[i].length; j++) {            if (grid[i][j] == 1) {                res++;                dfs(i, j);            }        }    }    return res;};\n\n图并查集prim算法最小生成树算法，即所有节点权值和最小的连通子图\n\n初始化minDist数组(最大值)，用于记录每一个节点到最小生成树的最短路径，随便选一个节点作为最小生成树，更新最小生成树相邻节点对应的minDist数组值\n选择离最小生成树最近的节点加入最小生成树，更新最小生成树相邻节点对应的minDist数组值\n重复循环2，直至遍历完\n\nkruskal算法Dijkstra很伤心，华为机考的时候只懂大概原理，还不会手撕代码，卡条件了直接寄\n在有权图（权值非负数）中求从起点到其他节点的最短路径算法\n朴素版本步骤\n\n初始化minDist数组(最大值)，用于记录起始点到其他节点的最短路径，与起始点相邻的节点先更新对应的minDist数组值\n选择离起始点最近且未被访问过的节点，该结点被标记访问过\n从新节点出发，更新与新节点相邻的节点minDist数组值\n重复循环23，直至遍历完\n\n优化堆版本步骤\n743.网络延迟时间题目有 n 个网络节点，标记为 1 到 n。\n给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。\n现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。\n\n解析\n3123.最短路径中的边题目给你一个 n 个节点的无向带权图，节点编号为 0 到 n - 1 。图中总共有 m 条边，用二维数组 edges 表示，其中 edges[i] = [ai, bi, wi] 表示节点 ai 和 bi 之间有一条边权为 wi 的边。\n对于节点 0 为出发点，节点 n - 1 为结束点的所有最短路，你需要返回一个长度为 m 的 boolean 数组 answer ，如果 edges[i] 至少 在其中一条最短路上，那么 answer[i] 为 true ，否则 answer[i] 为 false 。\n请你返回数组 answer 。\n注意，图可能不连通。\n\n解析\n207.课程表题目你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\n在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。\n例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n\n解析\n\n递归\n搜索dfs通常都是递归，在遍历树和图的所有节点时往往比bfs更简洁、空间复杂度更低\n代码框架\nfunction dfs(参数) {    if (终止条件，往往是搜到底了，判断当前是否为null) {        存放结果;        return;    }    for (选择：本节点所连接的其他节点) {        处理节点;        dfs(图，选择的节点); // 递归        回溯，撤销处理结果    }}\nbfs通常是使用额外队列来遍历，遍历顺序和dfs是不同的\n在层序遍历和最短路径(无权，带权值dijkstra)的场景下，往往只能用bfs\n代码框架（以网格结构为例，可以上下左右延伸）\n// 表示四个方向const direction = [[0, -1], [-1, 0], [0, 1], [1, 0]]; // grid 是地图，也就是一个二维数组// visited标记访问过的节点，不要重复访问// x,y 表示开始搜索节点的下标//表示层数let level=0;function bfs(grid, visited,  x,  y) {    let que=[]; // 定义队列    que.push([x, y]); // 起始节点加入队列    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点    while(que.length) { // 开始遍历队列里的元素        let len = queue.length;        //如果考虑层数，一定要注意把queue当前的长度抽取出来        while (len--) {            let cur = queue.shift();// 从队列取元素            let curx = cur[0];            let cury = cur[y]; // 当前节点坐标            for (dir of direction) { // 当前节点的四个方向左右上下去遍历                let nextx = curx + dir[0];                let nexty = cury + dir[1]; // 获取周边四个方向的坐标                if (nextx &lt; 0 || nextx &gt;= grid.length() || nexty &lt; 0 || nexty &gt;= grid[0].length()) continue;  // 坐标越界了，直接跳过                if (!visited[nextx][nexty]) { // 如果节点没被访问过                    que.push([nextx, nexty]);  // 队列添加该节点为下一轮要遍历的节点                    visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问                }            }        }        level++;    }    }\n回溯(类似dfs)void backtracking(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}\n39.组合总和题目给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n对于给定的输入，保证和为 target 的不同组合数少于 150 个\n\n解析\n第一反应误以为是背包了，但其实是不同的，用回溯更简单。回溯一般终止条件是对树的层数做限制，这里不限制重复，所以终止条件是和大于等于target\n/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */var combinationSum = function(candidates, target) {    let res=[],path=[],len=candidates.length;    //因为会重复，先排序再剪枝    candidates.sort((a,b)=&gt;a-b);    const backtracking=(target,idx)=&gt;{        if(target==0){            res.push([...path]);            return;        }        for(let i=idx;i&lt;len;i++){            const num=candidates[i];            if(target-num&lt;0)break;            path.push(num);            target-=num;            //关键在这里，因为不限制重复，所以传当前索引            backtracking(target,i);            path.pop();            target+=num;        }    }    backtracking(target,0);    return res;};\n46.全排列题目\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案解析\n/** * @param {number[]} nums * @return {number[][]} */var permute = function(nums) {    const vis=[],res=[],path=[];    const dfs=(len,vis)=&gt;{        if(path.length==len){            res.push([...path]);            return;        }        for(let i=0;i&lt;len;i++){            if(vis[i]){                continue;            }            path.push(nums[i]);            vis[i]=1;            dfs(len,vis);            path.pop();            vis[i]=0;        }    }    dfs(nums.length,vis);    return res;};\n47.全排列Ⅱ题目\n给定一个可含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案解析\n注意这里查找的顺序，有纵向和横向的区别，横向判断同层的的树时，顺序是在这一层每条路径只选择一个节点，所以前面的节点在前一条路径里被选过后，状态又会恢复成false，只要判断前一个节点大小和当前节点是否相等即可\n去重的数组要先排序\n/** * @param {number[]} nums * @return {number[][]} */var permuteUnique = function (nums) {    const vis = [], res = [], path = [];    const dfs = (len, vis) =&gt; {        if (path.length == len) {            res.push([...path]);            return;        }        for (let i = 0; i &lt; len; i++) {            //去重            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !vis[i - 1]) {                continue;            }            if (!vis[i]) {                path.push(nums[i]);                vis[i] = 1;                dfs(len, vis);                path.pop();                vis[i] = 0;            }        }    }    //数组一定要先排序，确保重复的数在一起    nums.sort((a,b)=&gt;a-b);    dfs(nums.length, vis);    return res;};\n924.尽量减少恶意软件的传播题目给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。\n一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。\n假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。\n如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。\n请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。\n\n解析\n并查集+bfs/dfs，本质上是找到一个最大连通块且只包含一个感染节点\nvar minMalwareSpread = function(graph, initial) {    const st = new Set(initial);    const vis = Array(graph.length).fill(false);    //这里用nodeID来记录连通块的状态nodeId为-1是初始状态，x表示当前连通块里的感染节点下标，-2代表有多个感染节点    let nodeId, size;    function dfs(x) {        vis[x] = true;        size++;        // 按照状态机更新 nodeId        if (nodeId !== -2 &amp;&amp; st.has(x)) {            nodeId = nodeId === -1 ? x : -2;        }        for (let y = 0; y &lt; graph[x].length; y++) {            if (graph[x][y] === 1 &amp;&amp; !vis[y]) {                dfs(y);            }        }    }    let ans = -1;    let max_size = 0;    for (const x of initial) {        if (vis[x]) {            continue;        }        nodeId = -1;        size = 0;        dfs(x);        if (nodeId &gt;= 0 &amp;&amp; (size &gt; max_size || size === max_size &amp;&amp; nodeId &lt; ans)) {            ans = nodeId;            max_size = size;        }    }    return ans &lt; 0 ? Math.min(...initial) : ans;};\n928.尽量减少恶意软件的传播II题目给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。\n一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。\n假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。\n我们可以从 initial 中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。\n请返回移除后能够使 M(initial) 最小化的节点。如果有多个节点满足条件，返回索引 最小的节点 。\n\n解析本题跟前面一题最大的区别在于924 是从 initial 中删除，928 是从 graph 中删除。\n前一个题可以直接dfs解决，因为graph里面结点没有变化，但是本题不行，因为从graph里删除了节点，原本可以联通删除后不能联通了，所以每删除一个要重新dfs，导致复杂度很大，所以逆向思维。从不在 initial中的点 v 出发 DFS，在不经过 initial 中的节点的前提下，看看 v 是只能被一个点感染到，还是能被多个点感染到。如果 v 只能被点 x=initial[i] 感染到，那么在本次 DFS 过程中访问到的其它节点，也只能被点 x 感染到。\nvar minMalwareSpread = function(graph, initial) {    const st = new Set(initial);    const vis = Array(graph.length).fill(false);    let nodeID, size;    function dfs(x) {        vis[x] = true;        size++;        for (let y = 0; y &lt; graph[x].length; y++) {            if (graph[x][y] === 0) {                continue;            }            if (st.has(y)) {                // 按照 924 题的状态机更新 nodeID                // 注意避免重复统计，例如上图中的 0 有两条不同路径可以遇到 1                if (nodeID !== -2 &amp;&amp; nodeID !== y) {                    nodeID = nodeID === -1 ? y : -2;                }            } else if (!vis[y]) {                //对不在initial里的节点继续dfs                dfs(y);            }        }    }    const cnt = new Map();    for (let i = 0; i &lt; graph.length; i++) {        if (vis[i] || st.has(i)) {            continue;        }        nodeID = -1;        size = 0;        dfs(i);        if (nodeID &gt;= 0) { // 只找到一个在 initial 中的节点            // 删除节点 nodeId 可以让 size 个点不被感染            //注意因为是从graph里删除了节点和所有连接，原来能连接到该节点的不一定都能在一个连通块里，所以要累积nodeID相同的连通块            cnt.set(nodeID, (cnt.get(nodeID) ?? 0) + size);        }    }    let maxCnt = 0;    let minNodeID = 0;    for (const [nodeID, c] of cnt) {        if (c &gt; maxCnt || c === maxCnt &amp;&amp; nodeID &lt; minNodeID) {            maxCnt = c;            minNodeID = nodeID;        }    }    return cnt.size ? minNodeID : Math.min(...initial);};\n2385.感染二叉树需要的总时间题目给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。\n每分钟，如果节点满足以下全部条件，就会被感染：\n节点此前还没有感染。节点与一个已感染节点相邻。返回感染整棵树需要的分钟数。\n\n解析\n\nbfs先把题目中的树dfs转化成图，再bfs搜索\n\n/** * @param {TreeNode} root * @param {number} start * @return {number} */var amountOfTime = function (root, start) {    let graph = new Map();    const dfs = (node) =&gt; {        if (node.left != null) {            const child = node.left;            //这里小细节set的时候第二项value一定要[]一下，因为插入的是数组            graph.has(node.val) ? graph.get(node.val).push(child.val) : graph.set(node.val, [child.val]);            graph.has(child.val) ? graph.get(child.val).push(node.val) : graph.set(child.val, [node.val]);            dfs(child);        }        if (node.right != null) {            const child = node.right;            graph.has(node.val) ? graph.get(node.val).push(child.val) : graph.set(node.val, [child.val]);            graph.has(child.val) ? graph.get(child.val).push(node.val) : graph.set(child.val, [node.val]);            dfs(child);        }    }    dfs(root);    let vis = new Set();    vis.add(start);    let time = 0;    let q = [];    //注意这里不适用len = queue.length再while (len--)再time++，因为本题可能只有一个节点同时也是感染节点，会出现答案是0但结果time为1    q.push([start, 0]);    while (q.length) {        const [n, t] = q.shift();        time = t;        if (graph.has(n)) {            graph.get(n).forEach(item =&gt; {                if (!vis.has(item)) {                    q.push([item, t + 1]);                    vis.add(item);                }            })        }    }    return time;};\n\ndfs还可以把题目转化为求树中距离目标节点最远的节点，即拆分为两个问题，一个是从目标节点往下求二叉树的最大深度；二个是去掉目标节点的所有子树，求二叉树的最大直径\n\n/** * @param {TreeNode} root * @param {number} start * @return {number} */var amountOfTime = function (root, start) {    let res = 0;    const dfs = (node) =&gt; {        if (node == null) {            return [0, false];        }        let [l, lFound] = dfs(node.left);        let [r, rFound] = dfs(node.right);        if (node.val == start) {            //计算start最大深度            res = Math.max(l, r);            return [1, true];        }        // 只有在左子树或右子树包含 start 时，才能更新答案        if (lFound || rFound) {            res = Math.max(res, l + r);            //向上返回当前节点最大深度，但是要保证返回的是包含start的那边一边子树深度            return [lFound ? l + 1 : r + 1, true];        }        return [Math.max(l, r) + 1, false];    }    dfs(root);    return res;};\n529.扫雷游戏题目\n给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：\n‘M’ 代表一个 未挖出的 地雷，‘E’ 代表一个 未挖出的 空方块，‘B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块 已挖出的 方块相邻，‘X’ 则表示一个 已挖出的 地雷。给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（’M’ 或者 ‘E’）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。\n根据以下规则，返回相应位置被点击后对应的盘面：\n如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’ 。如果一个 没有相邻地雷 的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。如果一个 至少与一个地雷相邻 的空方块（’E’）被挖出，修改它为数字（’1’ 到 ‘8’ ），表示相邻地雷的数量。如果在此次点击中，若无更多方块可被揭露，则返回盘面\n\n解析为了做题，第一次看懂扫雷的规则思路蛮简单的,有三种变化情况\n\n一来就遇到 M，直接踩雷，更新为X，游戏结束。\n遍历中遇到E，再细分两种情况：\n相邻 8 个节点有雷，即用于计数的count不为0，更新为count，结束当前节点的遍历。\n相邻 8 个节点没有雷，即用于计数的count为0，更新为 B，并继续对当前节点的相邻节点进行遍历。\n\n\n\ndfs就是在b情况下继续递归当前节点的相邻节点\nbfs就是在b情况下把当前节点的相邻节点加入循环队列\n\ndfs\n\n/** * @param {character[][]} board * @param {number[]} click * @return {character[][]} */var updateBoard = function (board, click) {    const directions = [[0, 1], [0, -1], [1, 0], [1, 1], [1, -1], [-1, 0], [-1, 1], [-1, -1]];    const dfs = (x, y) =&gt; {        let count = 0;        for (dir of directions) {            let curx = x + dir[0];            let cury = y + dir[1];            if (curx &lt; 0 || curx &gt;= board.length || cury &lt; 0 || cury &gt;= board[0].length) {                continue;            }            if (board[curx][cury] == 'M') {                count++;            }        }        if (count &gt; 0) {            board[x][y] = count.toString();        } else {            board[x][y] = 'B';            for (dir of directions) {                let curx = x + dir[0];                let cury = y + dir[1];                if (curx &lt; 0 || curx &gt;= board.length || cury &lt; 0 || cury &gt;= board[0].length||board[curx][cury]!='E') {                continue;            }                dfs(curx,cury);            }        }    }    if(board[click[0]][click[1]]=='M'){        board[click[0]][click[1]]='X';    }else{        dfs(click[0],click[1]);    }    return board;};\n\nbfs\n\n/** * @param {character[][]} board * @param {number[]} click * @return {character[][]} */var updateBoard = function (board, click) {    const directions = [[0, 1], [0, -1], [1, 0], [1, 1], [1, -1], [-1, 0], [-1, 1], [-1, -1]];    const bfs = (sx, sy) =&gt; {        let queue=[];        const vis=new Array(board.length).fill(0).map(()=&gt;new Array(board[0].length).fill(0));        queue.push([sx,sy]);        vis[sx][sy]=1;        while(queue.length){            const [x,y]=queue.shift();            let count = 0;        for (dir of directions) {            let curx = x + dir[0];            let cury = y + dir[1];            if (curx &lt; 0 || curx &gt;= board.length || cury &lt; 0 || cury &gt;= board[0].length) {                continue;            }            if (board[curx][cury] == 'M') {                count++;            }        }        if (count &gt; 0) {            board[x][y] = count.toString();        } else {            board[x][y] = 'B';            for (dir of directions) {                let curx = x + dir[0];                let cury = y + dir[1];                if (curx &lt; 0 || curx &gt;= board.length || cury &lt; 0 || cury &gt;= board[0].length||board[curx][cury]!='E'||vis[curx][cury]==1) {                continue;            }                queue.push([curx,cury]);                vis[curx][cury]=1;            }        }        }            }    if(board[click[0]][click[1]]=='M'){        board[click[0]][click[1]]='X';    }else{        bfs(click[0],click[1]);    }    return board;};\n\n贪心\n二分查找开闭区间整理直接画图先推得了，每次都卡条件，套公式不管用\n注意一下二分的开闭区间问题\n这里整理一下二分区间常见写法注意具体题目中if上取等要看题意能否等于目标值\n\n[left, right]\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] &gt;= target                right=middle-1; // target 在右区间，所以[left, middle - 1]            }        }        //不存在的话返回的是nums.size()和-1        return left;    }\n\n[left, right)\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        //不存在的话返回的是nums.size()        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            //这里位运算一定一定一定要括号括起来，我这个错误被卡bug了一天            int middle = left + ((right - left) &gt;&gt; 1);            if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] &gt;= target                right=middle; // target 在左区间，在[left, middle)中            }        }        //不存在的话返回的是nums.size()和0        return left;    }\n\n(left, right)\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = -1;        int right = nums.size(); // 定义target在左开右开的区间里，即：(left, right)        while (lef+1 &lt; right) { // 因为left+1 == right的时候，在(left, right)是无效的空间，所以使用 &lt;            //这里位运算一定一定一定要括号括起来，我这个错误被卡bug了一天            int middle = left + ((right - left) &gt;&gt; 1);            //这里一定要注意，返回的是从后往前第一个满足的，如果出现了重复元素，返回的是最后一个的位置            if (nums[middle] &lt; target) {                left = middle ;// target 在右区间，在(middle, right)中            } else {                right = middle; // target 在左区间，在(left, middle)中            }        }        //不存在的话返回的是nums.size()和-1        return right;    }\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = -1;        int right = nums.size(); // 定义target在左开右开的区间里，即：(left, right)        while (lef+1 &lt; right) { // 因为left+1 == right的时候，在(left, right)是无效的空间，所以使用 &lt;            //这里位运算一定一定一定要括号括起来，我这个错误被卡bug了一天            int middle = left + ((right - left) &gt;&gt; 1);            //这里一定要注意，返回的是从前往后第一个满足的，如果出现了重复元素，返回的是第一个的位置            if (nums[middle] &lt;= target) {                left = middle ;// target 在右区间，在(middle, right)中            } else {                right = middle; // target 在左区间，在(left, middle)中            }        }        //不存在的话返回的是nums.size()和-1        return left;    }\n436.寻找右区间题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n解析\n/** * @param {number[][]} intervals * @return {number[]} */var findRightInterval = function(intervals) {    const len=intervals.length;    const startIntervals=new Array(len).fill(0).map(()=&gt;new Array(2).fill(0));    for(let i=0;i&lt;len;i++){        startIntervals[i][0]=intervals[i][0];        startIntervals[i][1]=i;    }    startIntervals.sort((a,b)=&gt;a[0]-b[0]);    const res=new Array(len).fill(0);    for(let i=0;i&lt;len;i++){        let left=0;        let right=len-1;        let target = -1;        while(left&lt;=right){            const mid=left+((right-left)&gt;&gt;1);            if(startIntervals[mid][0]&gt;=intervals[i][1]){                target = startIntervals[mid][1];                right=mid-1;            }else{                left=mid+1;            }        }        res[i]=target;    }    return res;};\n1146.快照数组题目实现支持下列接口的「快照数组」- SnapshotArray：\nSnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。void set(index, val) - 会将指定索引 index 处的元素设置为 val。int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。\n\n解析\n注意这里题目说的是每调用一次snap才会增加时间，所以会出现同一时间多次调用set的情况，即重复元素，因此要考虑取的是第一次snap的\n/** * @param {number} length */var SnapshotArray = function (length) {    this.arr = Array.from({length},() =&gt; []);    this.time = 0;};/**  * @param {number} index  * @param {number} val * @return {void} */SnapshotArray.prototype.set = function (index, val) {    this.arr[index].push([val, this.time]);};/** * @return {number} */SnapshotArray.prototype.snap = function () {    return this.time++;};/**  * @param {number} index  * @param {number} snap_id * @return {number} */SnapshotArray.prototype.get = function (index, snap_id) {    let l = -1, r = this.arr[index].length;    while (l+1 &lt; r) {        let mid = l + ((r - l) &gt;&gt; 1);        //这里小心别被重复元素坑了，要返回的是第一个        if (this.arr[index][mid][1] &lt;=snap_id) {            l = mid;        } else {            r = mid;        }    }    const id = l;    if(id==-1||id==this.arr[index].length){        return 0;    }    return this.arr[index][id][0];};/** * Your SnapshotArray object will be instantiated and called as such: * var obj = new SnapshotArray(length) * obj.set(index,val) * var param_2 = obj.snap() * var param_3 = obj.get(index,snap_id) */\n\n动态规划背包问题归纳现实中谁会这么算，都是乱装让一个出门不带包的人天天算怎么装满包\n\n类型\n\n\n能否装满/最多装背包(01)\n\n一维dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n二维dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n\n\n装满背包的方法(完全/01)dp[j] += dp[j - nums[i]]\n\n背包能装的最大价值dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\n装满背包的物品最小个数dp[j] = min(dp[j - coins[i]] + 1, dp[j]);\n\n\n\n遍历顺序\n\n\n01背包\n\n二维 物品和容量内外都可以，第二层for循环是从小到大遍历\n一维 先物品再容量，第二层for循环是从大到小遍历\n\n\n完全背包\n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包。第二层for循环是从小到大遍历\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。第二层for循环是从小到大遍历\n\n\n\n记忆化搜索动态规划里减少计算重复的情况\n\n写出问题的动态规划「状态」和「状态转移方程」。\n定义一个缓存（数组或哈希表），用于保存子问题的解。\n定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。\n在主函数中，调用递归函数并返回结果。\n\n416.分割等和子集题目给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n解析题目可以等价于在数组中找到一组子集，使它们的和等于数组总和的一半，那么就是一个01背包问题\n可以一维dp做，先物品(每个数组元素的值)再容量(要达成的总和)，内部第二层注意从大到小，dp[i]=dp[i]||dp[i-item]\n/** * @param {number[]} nums * @return {boolean} */var canPartition = function(nums) {    if(nums.length&lt;2){        return false;    }    let sum=0;    let max=0;    for(item of nums){        sum+=item;        max=Math.max(max,item);    }    if(sum%2==1||max&gt;(sum/2)){        return false;    }    const dp=new Array(sum/2+1).fill(false);    dp[0]=true;    for(const item of nums){        for(let i=sum/2;i&gt;=item;i--){            dp[i]|=dp[i-item];        }    }    return dp[sum/2];};\n也可以记忆化搜索\nconst canPartition = function(nums) {    const s = _.sum(nums);    if (s % 2) {        return false;    }    const n = nums.length;    const memo = Array.from({length: n}, () =&gt; Array(s / 2 + 1).fill(-1)); // -1 表示没有计算过    function dfs(i, j) {        if (i &lt; 0) {            return j === 0;        }        if (memo[i][j] !== -1) { // 之前计算过            return memo[i][j] === 1;        }        const res = j &gt;= nums[i] &amp;&amp; dfs(i - 1, j - nums[i]) || dfs(i - 1, j);        memo[i][j] = res ? 1 : 0; // 记忆化        return res;    }    return dfs(n - 1, s / 2);};\n337.打家劫舍Ⅲ题目小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\n\n解析终于来了，经典树形dp，之前没练习过，导致笔试遇到几次都挂了思考逻辑：递归-&gt;记忆化搜索+递归-&gt;树形dp递归的思路就是暴力求解，每一层都比较是偷当前节点还是不偷当前节点，dfs的思路，但是会导致中间的子节点在多次递归中反复计算\nclass Solution {public:    int rob(TreeNode* root) {        if (root == NULL) return 0;        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return root-&gt;val;        // 偷父节点        int val1 = root-&gt;val;        if (root-&gt;left)         val1 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); // 跳过root-&gt;left，相当于不考虑左孩子了        if (root-&gt;right)         val1 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); // 跳过root-&gt;right，相当于不考虑右孩子了        // 不偷父节点        int val2 = rob(root-&gt;left) + rob(root-&gt;right); // 考虑root的左右孩子        return max(val1, val2);    }};\n为了减少重复计算，使用记忆化搜索，创建一个map，保存每个节点对应的偷与不偷的最大值\nclass Solution {public:    unordered_map&lt;TreeNode* , int&gt; umap; // 记录计算过的结果    int rob(TreeNode* root) {        if (root == NULL) return 0;        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return root-&gt;val;        if (umap[root]) return umap[root]; // 如果umap里已经有记录则直接返回        // 偷父节点        int val1 = root-&gt;val;        if (root-&gt;left) val1 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); // 跳过root-&gt;left        if (root-&gt;right) val1 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); // 跳过root-&gt;right        // 不偷父节点        int val2 = rob(root-&gt;left) + rob(root-&gt;right); // 考虑root的左右孩子        umap[root] = max(val1, val2); // umap记录一下结果        return max(val1, val2);    }};\n使用动态规划的方法来做，就返回的不是最大值了，而是处于两个不同状态下的值。所以dp数组是一个长度为2的数组，下标0记录不偷该节点所得到的的最大金钱，下标1记录偷该节点所得到的的最大金钱。\nclass Solution {public:    int rob(TreeNode* root) {        vector&lt;int&gt; result = robTree(root);        return max(result[0], result[1]);    }    // 长度为2的数组，0：不偷，1：偷    vector&lt;int&gt; robTree(TreeNode* cur) {        if (cur == NULL) return vector&lt;int&gt;{0, 0};        vector&lt;int&gt; left = robTree(cur-&gt;left);        vector&lt;int&gt; right = robTree(cur-&gt;right);        // 偷cur，那么就不能偷左右节点。        int val1 = cur-&gt;val + left[0] + right[0];        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况        int val2 = max(left[0], left[1]) + max(right[0], right[1]);        return {val2, val1};    }};\nconst rob = root =&gt; {    // 后序遍历函数    const postOrder = node =&gt; {        // 递归出口        if (!node) return [0, 0];        // 遍历左子树        const left = postOrder(node.left);        // 遍历右子树        const right = postOrder(node.right);        // 不偷当前节点，左右子节点都可以偷或不偷，取最大值        const DoNot = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);        // 偷当前节点，左右子节点只能不偷        const Do = node.val + left[0] + right[0];        // [不偷，偷]        return [DoNot, Do];    };    const res = postOrder(root);    // 返回最大值    return Math.max(...res);};\n403.青蛙过河题目一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。\n给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n\n解析\n青蛙为什么不会自己游过去！\ndp[i][k]表示青蛙能否达到「现在所处的石子编号」为 i 且「上一次跳跃距离」为 k 的状态\ndp[i][k]=dp[j][k−1]⋁dp[j][k]⋁dp[j][k+1]stones[i]−stones[j]=k\n现在所处的石子索引为 i (不是stones[i])时，上一次跳跃距离k 必定满足 k≤i。可以这么理解，假设青蛙每次都比上一次多跳一格，石子索引为i代表跳了i次，那么k最多加到i。那么当第i个石子和第i-1个石子的距离即stones[i]−stones[i-1]&gt;i的时候，青蛙绝对无法到达终点\n/** * @param {number[]} stones * @return {boolean} */var canCross = function (stones) {    const len = stones.length;    const dp = new Array(len).fill(0).map(() =&gt; new Array(len).fill(0));    dp[0][0] = true;    for (let i = 1; i &lt; len; i++) {        if (stones[i] - stones[i - 1] &gt; i) {            return false;        }        for (let i = 1; i &lt; len; i++) {            for (let j = i; j &gt; 0; j--) {                const k = stones[i] - stones[j - 1];                if (k &gt; j) {                    break;                }                dp[i][k] = dp[j - 1][k - 1] || dp[j - 1][k] || dp[j - 1][k + 1];                if (i == len - 1 &amp;&amp; dp[i][k]) {                    return true;                }            }        }        return false;    }};\n494.目标和题目给你一个非负整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n\n解析\n\n回溯算法暴力搜索\n\n动态规划\n\n\n本题要如何使表达式结果为target，既然为target，那么就一定有 left组合 - right组合 = target，left + right = sum，而sum是固定的。right = sum - left，因此left - (sum - left) = target 推导出 left = (target + sum)/2\n从而问题转变成01背包问题，装满容量为left的背包的方法\n\n一维dp(滚动数组)dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法，递推公式为dp[j] += dp[j - nums[i]]，注意dp[0]=1和倒序，因为dp数组被全部初始化为0，从右向左不会出现dp[j - nums[i]]覆盖了已经赋值过的数组，保证每个元素只放入一次\n\n二维dpdp[i][j] 表示在数组 nums 的前 i 个数中选取元素，使得这些元素之和等于 j 的方案数\n\n\nconst findTargetSumWays = (nums, target) =&gt; {    //一维dp    const sum = nums.reduce((a, b) =&gt; a+b);        if(Math.abs(target) &gt; sum) {        return 0;    }    if((target + sum) % 2) {        return 0;    }    const halfSum = (target + sum) / 2;    let dp = new Array(halfSum+1).fill(0);    dp[0] = 1;    for(let i = 0; i &lt; nums.length; i++) {        for(let j = halfSum; j &gt;= nums[i]; j--) {            dp[j] += dp[j - nums[i]];        }    }    return dp[halfSum];};\n//二维dpvar findTargetSumWays = function(nums, target) {    let sum = 0;    for (const num of nums) {        sum += num;    }    const diff = sum - target;    if (diff &lt; 0 || diff % 2 !== 0) {        return 0;    }    const n = nums.length, neg = diff / 2;    const dp = new Array(n + 1).fill(0).map(() =&gt; new Array(neg + 1).fill(0));    dp[0][0] = 1;    for (let i = 1; i &lt;= n; i++) {        const num = nums[i - 1];        for (let j = 0; j &lt;= neg; j++) {            dp[i][j] = dp[i - 1][j];            if (j &gt;= num) {                dp[i][j] += dp[i - 1][j - num];            }        }    }    return dp[n][neg];};\n70.爬楼梯(进阶)题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？\n\n解析\n我直接坐电梯！\n原题是每次爬1个或者2个，就是斐波那契数列\n现在每次可以爬m种台阶，且不限制数量，就是完全背包问题\ndp[i]：爬到有i个台阶的楼顶，有dp[i]种方法\n递推公式：dp[i] += dp[i - j]\nfunction climbStairs(n) {    /**        一次可以爬m阶        dp[i]: i阶楼梯的方法种数        dp[1]: 1;        dp[2]: 2;        dp[3]: dp[2] + dp[1];        ...        dp[i]: dp[i - 1] + dp[i - 2] + ... + dp[max(i - m, 1)]; 从i-1加到max(i-m, 1)     */    const m = 2;    // 本题m为2    const dp = new Array(n + 1).fill(0);    dp[0]=1;    dp[1] = 1;    for (let i = 2; i &lt;= n; i++) {        for (let j = 1; j &lt;=m; j++) {            dp[i] += dp[i-j];        }    }    return dp[n];};\n377.组合总和Ⅳ题目给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n\n解析完全背包排列问题\n如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n记不住就现场举例子，计算dp[4]的时候，遍历nums（物品）放在外循环，遍历target的作为内循环的话，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面\n/** * @param {number[]} nums * @param {number} target * @return {number} */var combinationSum4 = function(nums, target) {    let dp=new Array(target+1).fill(0);    dp[0]=1;    for(let i = 0; i &lt;= target; i++) {        for(let j = 0; j &lt; nums.length; j++) {            if (i &gt;= nums[j]) {                dp[i] += dp[i - nums[j]];            }        }    }    return dp[target];};\n1235.规划兼职工作题目你打算利用空闲时间来做兼职工作赚些零花钱。\n这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。\n给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。\n注意，时间上出现重叠的 2 份工作不能同时进行。\n如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。\n\n解析有点类似以前做过的气球问题(无重叠区间)用结束时间从小到大排序，使用 dp[i] 表示前 i 份兼职工作可以获得的最大报酬，区间范围[0,i−1]， k 表示满足结束时间小于等于第 i−1 份工作开始时间的兼职工作数量dp[i]=max(dp[i−1],dp[k]+profit[i−1])然后二分解决\nvar jobScheduling = function (startTime, endTime, profit) {    const n = startTime.length;    const arr = new Array(n).fill(0).map((_, i) =&gt; [startTime[i], endTime[i], profit[i]]);    arr.sort((a, b) =&gt; a[1] - b[1]);    const dp = new Array(n + 1).fill(0);    for (let i = 1; i &lt;= n; i++) {        const k = binarySearch(arr, i - 1, arr[i - 1][0]);        dp[i] = Math.max(dp[i - 1], dp[k] + arr[i - 1][2]);    }    return dp[n];};const binarySearch = (arr, r, t) =&gt; {    let l = 0;    //[l,r)    while (l &lt; r) {        const mid = l + Math.floor((r - l) / 2);        //同一个时间点上可以重叠，切记取等        if (arr[mid][1] &lt;= t) {            l = mid + 1;        } else {            r = mid;        }    }    return l;};\n741.摘樱桃题目给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：\n0 表示这个格子是空的，所以你可以穿过它。1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。-1 表示这个格子里有荆棘，挡着你的路。请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：\n从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 0 或者 1 的格子）；当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）；如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。\n\n解析我第一反应是两次dp，但是错了，才意识到局部最优不等于全局最优，导致这个的原因在于规定了移动方法只能向两个方向，导致如果单次取最优，会导致下一次有些点根本无法到达\n0:[1, 1, 1, 1, 0, 0, 0]1:[0, 0, 0, 1, 0, 0, 0]2:[0, 0, 0, 1, 0, 0, 1]3:[1, 0, 0, 1, 0, 0, 0]4:[0, 0, 0, 1, 0, 0, 0]5:[0, 0, 0, 1, 0, 0, 0]6:[0, 0, 0, 1, 1, 1, 1]\n所以唯一的解决方案就是两次dp同时进行，求两者和的最优解\n为了统计两次dp是否经过了同一个格子，将第二次dp(向上走的)等效成向下走，这样当两次dp坐标相同就代表经过同一个格子\n因为如果考虑横纵坐标，状态维度太大了，进行简化。由于每一次移动都只能移动一格，同时进行的两次dp的坐标x,y之和是相等的，都是移动步数，只要两次dp横坐标相同，坐标就相同，所以把四维简化成二维。即dp[steps][x1][x2]表示两人各自都走了steps步，分别走到[x1][steps-x1]和[x2][steps-x2]，此时得到的樱桃个数的最大值\n一共四种情况，取最大值都往右：从 dp[steps−1][x1][x2]转移过来；往下，往右：从 dp[steps−1][x1-1][x2]转移过来；往右，往下：从 dp[steps−1][x1][x2-1]转移过来；都往下：从 dp[steps−1][x1-1][x2-1]转移过来；\n为了简化代码，可以假设第一次dp的不会走到第二次dp的下方，即x1&lt;=x2，可以减少一半的循环次数\n/** * @param {number[][]} grid * @return {number} */var cherryPickup = function(grid) {    const n = grid.length;    const f = new Array(n * 2 - 1).fill(0).map(() =&gt; new Array(n).fill(0).map(() =&gt; new Array(n).fill(-Number.MAX_VALUE)));    f[0][0][0] = grid[0][0];    for (let k = 1; k &lt; n * 2 - 1; ++k) {        for (let x1 = Math.max(k - n + 1, 0); x1 &lt;= Math.min(k, n - 1); ++x1) {            const y1 = k - x1;            if (grid[x1][y1] === -1) {                continue;            }            for (let x2 = x1; x2 &lt;= Math.min(k, n - 1); ++x2) {                let y2 = k - x2;                if (grid[x2][y2] === -1) {                    continue;                }                let res = f[k - 1][x1][x2]; // 都往右                if (x1 &gt; 0) {                    res = Math.max(res, f[k - 1][x1 - 1][x2]); // 往下，往右                }                if (x2 &gt; 0) {                    res = Math.max(res, f[k - 1][x1][x2 - 1]); // 往右，往下                }                if (x1 &gt; 0 &amp;&amp; x2 &gt; 0) {                    res = Math.max(res, f[k - 1][x1 - 1][x2 - 1]); // 都往下                }                res += grid[x1][y1];                if (x2 !== x1) { // 避免重复摘同一个樱桃                    res += grid[x2][y2];                }                f[k][x1][x2] = res;            }        }    }    return Math.max(f[n * 2 - 2][n - 1][n - 1], 0);};\n进一步优化维度，把dp三维优化成二维，删除steps。可以类比背包问题二维转一维，使用倒序避免覆盖问题\nvar cherryPickup = function(grid) {    const n = grid.length;    const f = new Array(n).fill(0).map(() =&gt; new Array(n).fill(-Number.MAX_VALUE));    f[0][0] = grid[0][0];    for (let k = 1; k &lt; n * 2 - 1; ++k) {        for (let x1 = Math.min(k, n - 1); x1 &gt;= Math.max(k - n + 1, 0); --x1) {            for (let x2 = Math.min(k, n - 1); x2 &gt;= x1; --x2) {                const y1 = k - x1, y2 = k - x2;                if (grid[x1][y1] === -1 || grid[x2][y2] === -1) {                    f[x1][x2] = -Number.MAX_VALUE;                    continue;                }                let res = f[x1][x2]; // 都往右                if (x1 &gt; 0) {                    res = Math.max(res, f[x1 - 1][x2]); // 往下，往右                }                if (x2 &gt; 0) {                    res = Math.max(res, f[x1][x2 - 1]); // 往右，往下                }                if (x1 &gt; 0 &amp;&amp; x2 &gt; 0) {                    res = Math.max(res, f[x1 - 1][x2 - 1]); //都往下                }                res += grid[x1][y1];                if (x2 !== x1) { // 避免重复摘同一个樱桃                    res += grid[x2][y2];                }                f[x1][x2] = res;            }        }    }    return Math.max(f[n - 1][n - 1], 0);};\n1463.摘樱桃Ⅱ题目\n给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。\n你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。\n请你按照如下规则，返回两个机器人能收集的最多樱桃数目：\n从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。两个机器人在任意时刻都不能移动到 grid 外面。两个机器人最后都要到达 grid 最底下一行。\n\n解析这个题机器人走的路径就是向下的三个相邻格子，两个机器人每次移动都在同一行状态方程可以写为dp[y][x1][x2]=max(dp[y-1][dx1][dx2]+grid[y][x1]+grid[y][x2])，dx1取值范围[x1-1,x1,x1+1]，dx2取值范围[x2-1,x2,x2+1]\n/** * @param {number[][]} grid * @return {number} */var cherryPickup = function(grid) {    const m = grid.length;    const n = grid[0].length;    let f = Array.from({ length: n }, () =&gt; Array(n).fill(-1));    let g = Array.from({ length: n }, () =&gt; Array(n).fill(-1));    f[0][n - 1] = grid[0][0] + grid[0][n - 1];    for (let i = 1; i &lt; m; ++i) {        for (let j1 = 0; j1 &lt; n; ++j1) {            for (let j2 = 0; j2 &lt; n; ++j2) {                let best = -1;                for (let dj1 = j1 - 1; dj1 &lt;= j1 + 1; ++dj1) {                    for (let dj2 = j2 - 1; dj2 &lt;= j2 + 1; ++dj2) {                        if (dj1 &gt;= 0 &amp;&amp; dj1 &lt; n &amp;&amp; dj2 &gt;= 0 &amp;&amp; dj2 &lt; n &amp;&amp; f[dj1][dj2] != -1) {                            best = Math.max(best, f[dj1][dj2] + (j1 == j2 ? grid[i][j1] : grid[i][j1] + grid[i][j2]));                        }                    }                }                g[j1][j2] = best;            }        }        [f, g] = [g, f];    }    let ans = 0;    for (let j1 = 0; j1 &lt; n; ++j1) {        ans = Math.max(ans, Math.max(...f[j1]));    }    return ans;};\n\n位运算这类的题目不多，但是一些小技巧不会能卡很久\n异或任何数和 0 做异或运算，结果仍然是原来的数，即  。任何数和其自身做异或运算，结果是 0，即 。异或运算满足交换律和结合律，即 。\nBrian Kernighan 算法经典题目338计算二进制里1的个数\n对于任意整数x，令 ，该运算将x的二进制表示的最后一个1变成 0，以及后面的0都变成1，而1前面的数不会变。进行&amp;操作之后原本最后一个1以及后面所有的0都会变成0，这样成功实现了减少一个1的目的，可以用这个方法来计数所有的1的个数\n总的时间复杂度为O(nlogn)\n/** * @param {number} n * @return {number[]} */var countBits = function (n) {    const bits = new Array(n + 1).fill(0);    const countOnes = (x) =&gt; {        let ones = 0;        while (x &gt; 0) {            x &amp;= (x - 1);            ones++;        }        return ones;    }    for (let i = 0; i &lt; n + 1; i++) {        bits[i] = countOnes(i);    }    return bits;};\n1017.负二进制转换题目给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。\n注意，除非字符串就是 “0”，否则返回的字符串中不能含有前导零。\n\n解析当基数 x&gt;1时，将整数 n 转换成 x 进制的原理是：令 ，计算过程如下:\n当计算第 0 位上的数字时，此时 ，，其中 0≤r&lt;x\n当计算第 i 位上的数字时，此时 ，，其中 0≤r&lt;x\n按照上述计算方式进行计算，直到满足  结束。\n如果基数 x 为负数，只要能确定余数的可能取值，上述做法同样适用。由于「负二进制」余数的可能取值是 0,1,-1，举例子5%(-2)=-3…(-1)和5%(-2)=-2…1，但是表示上没有负数，只有0和1。所有的负数表示都是补码形式，最低位奇偶性不变，做最低位&amp;操作就行\nvar baseNeg2 = function(n) {    if (n === 0 || n === 1) {        return '' + n;    }    let res = '';    while (n !== 0) {        const remainder = n &amp; 1;        res += remainder;        //减去余数，其实就是把最低位抹掉，防止不能整除        n -= remainder;        n /= -2;    }    return res.split('').reverse().join('');};\n\n数论gcd最大公约数，理解辗转相除的关键在于被除数和除数有相同的因数，那么被除数和除数的余数跟它们也有一样的因数，反之亦然\nfunction gcd(a, b) {    while (b !== 0) {        [a, b] = [b, a % b];    }    return a;}或者简写const gcd = (a, b) =&gt; (b===0 ? a : gcd(b, a % b))\n质数在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数为质数，统计 [2,n] 中质数的数量\n\n枚举假设x=a*b，只需要找到到a和b中较小的那一个，就可以排除x，查找范围在 之间\n\nconst prime=(x)=&gt;{        for(let i=2;i*i&lt;=x;i++){            if(x%i==0){                return false;            }        }        return true;    }\n\n埃氏筛\n\n如果x是质数，那么2x,3x…一定不是质数，然后判断应该从x*x开始，因为2x,3x…x*x会被小于x的数标记，会重复\n\n/** * @param {number} n * @return {number} */var countPrimes = function (n) {    const isPrime = new Array(n).fill(1);    let ans = 0;    for (let i = 2; i &lt; n; ++i) {        if (isPrime[i]) {            ans += 1;            for (let j = i * i; j &lt; n; j += i) {                isPrime[j] = 0;            }        }    }    return ans;};\n快速幂一个数的因数个数一个数分解质因数，如果有相同的质因数就整理成幂次方的形式。将结果的指数加一，再将此结果相乘得到其因数个数。举例：72，用列举法不易找出其因数个数。而72＝2×2×2×3×3＝2³×3²，分别将指数3,2加一变成4,3，4×3＝12个。列举证明1,2,3,4,6,8,9,12,18,24,36,72共12个因数。\nlet cnt=0;for(let i=1;i*i&lt;=num;i++){    if(num%i==0){        factors[cnt++]=i;        if(i!=num/i){            ans[factors++]=num/i;        }    }}\n1492.n 的第 k 个因子题目给你两个正整数 n 和 k 。\n如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。\n考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。\n\n解析\n","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（三）","url":"/2024/04/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（二），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \n题库LeetCode75本题库涉及到的知识点一览\n\n[x] 数组 / 字符串\n[ ] 双指针\n[ ] 滑动窗口\n[x] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈\n[x] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[x] 二叉搜索树\n[ ] 图 - 深度优先搜索\n[ ] 图 - 广度优先搜索\n[ ] 堆 / 优先队列\n[ ] 二分查找\n[ ] 回溯\n[ ] 动态规划 - 一维\n[ ] 动态规划 - 多维\n[x] 位运算\n[ ] 前缀树\n[x] 区间集合\n[x] 单调栈\n\n\n136.只出现一次的数字题目：\n给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n解析：\n虽然是简单题，但是没做过类似的位运算真的会被卡，不用位运算应该有三种，集合去重，哈希计数，集合去重*2减去原本数组元素，但是空间复杂度都会超，这里只有异或不用额外空间\n复习一下异或的特性\n任何数和 0 做异或运算，结果仍然是原来的数，即  。任何数和其自身做异或运算，结果是 0，即 。异或运算满足交换律和结合律，即 。\nvar singleNumber = function(nums) {    let res=0;    for(const num of nums){        res^=num;    }    return res;};\n1318.或运算的最小翻转次数题目：\n给你三个正整数 a、b 和 c。你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b == c  成立的最小翻转次数。「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。\n\n解析：\n异或秒了\n分类讨论就是遍历每一位，当a和b都为0，而c为1，只用翻转一次；当a和b都为1，而c为0，要翻转两次。\n如果直接ab或再与c异或会少翻转次数，通过ab与得到两个为1再与非c与，就可以补上少的一部分翻转次数\n使用异或来数二进制数的1的个数\nvar minFlips = function(a, b, c) {    const countOne=(x)=&gt;{        let ones=0;        while(x&gt;0){            x&amp;=(x-1);            ones++;        }        return ones;    }    return countOne((a|b)^c)+countOne((a&amp;b)&amp;(~c));};\n894.所有可能的真二叉树题目：\n给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val == 0 。答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。\n\n解析：\n通过题目意思可以推测处真二叉树是指每个节点的子节点为0或者2的树。因为二叉树一定有一个根节点，所以真二叉树的节点个数一定是奇数。\n\n从叶子的角度(dp)\n\n一棵有 n 个节点的真二叉树恰好有个叶子。示例中返回列表的顺序是一层一层的返回，如果某个节点在上一层就是叶子结点了，那么在下一层对应的位置会返回两个null，因此可以考虑n与2n-1或者n与来表示当前节点和其对应的叶子结点。\n定义 f[i] 为有 i 个叶子的所有真二叉树的列表。枚举左子树有 j=1,2,⋯ ,i−1 个叶子，那么右子树有 i−j 个叶子。\n左子树的所有真二叉树列表为 f[j]，右子树的所有真二叉树列表为 f[i−j]。从这两个列表中各选一棵真二叉树，作为根节点的左右子树，从而得到有 i 个叶子的真二叉树，这些真二叉树组成了 f[i]。\n初始值：f[1] 为只包含一个节点的二叉树列表。\nconst f = Array.from({length: 11}, () =&gt; []);f[1].push(new TreeNode());for (let i = 2; i &lt; f.length; i++) { // 计算 f[i]    for (let j = 1; j &lt; i; j++) { // 枚举左子树叶子数        for (const left of f[j]) { // 枚举左子树            for (const right of f[i - j]) { // 枚举右子树                f[i].push(new TreeNode(0, left, right));            }        }    }}var allPossibleFBT = function(n) {    return f[n % 2 ? (n + 1) / 2 : 0];};\n\n从节点角度\n\n当 n 是奇数时，n 个结点的真二叉树满足左子树和右子树的结点数都是奇数，此时左子树和右子树的结点数之和是 n−1，假设左子树的数目为 i，则左子树的节点数目则为 n−1−i，则可以推出左子树与右子树的节点数目序列为：[(1,n−2),(3,n−4),(5,n−6),⋯ ,(n−2,1)]\n自底向上进行动态规划:n=1的子树，就是根节点；[(1,1)]的子树序列，可以构成n=3的真二叉树；[(1,3),(3,1)]的子树序列，可以构成n=5的真二叉树；[(1,5),(3,3),(5,1)]的子树序列，可以构成n=7的真二叉树；\nvar allPossibleFBT = function (n) {    if (n % 2 === 0) {        return [];    }    const dp = Array(n + 1).fill().map(() =&gt; []);    dp[1] = [new TreeNode(0)];    for (let i = 3; i &lt;= n; i += 2) {        for (let j = 1; j &lt; i; j += 2) {            for (let leftSubtree of dp[j]) {                for (let rightSubtree of dp[i - 1 - j]) {                    const root = new TreeNode(0, leftSubtree, rightSubtree);                    dp[i].push(root);                }            }        }    }    return dp[n];};\n1600.王位继承顺序题目：\n一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。Successor(x, curOrder):    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：        如果 x 是国王，那么返回 null        否则，返回 Successor(x 的父亲, curOrder)    否则，返回 x 不在 curOrder 中最年长的孩子通过以上的函数，我们总是能得到一个唯一的继承顺序。请你实现 ThroneInheritance 类：ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n\n解析：\n本题其实类似于多叉树的前序遍历，存储这棵树的方法可以是哈希映射，(父，子列表)的形式存储\n本题逻辑不难，但是有个时间性能的点要注意，如果我的dead使用array来存储，最后会超时，但是用set来存储不会。数组里面的搜索是基于索引的都是 O(N) ，而set是基于键值对的O(1)，数组的indexOf()和includes()方法查找比较慢，而set的has()会快很多\n/** * @param {string} kingName */var ThroneInheritance = function(kingName) {    this.king=kingName;    this.edges=new Map();    this.dead=new Set();};/**  * @param {string} parentName  * @param {string} childName * @return {void} */ThroneInheritance.prototype.birth = function(parentName, childName) {    if(!this.edges.has(parentName)){        this.edges.set(parentName,[]);    }    this.edges.get(parentName).push(childName);    };/**  * @param {string} name * @return {void} */ThroneInheritance.prototype.death = function(name) {    this.dead.add(name);};/** * @return {string[]} */ThroneInheritance.prototype.getInheritanceOrder = function() {    const res=[];    const preorder=(name)=&gt;{        if(!this.dead.has(name)){            res.push(name);        }        if(this.edges.has(name)){            for(const child of this.edges.get(name)){                preorder(child);            }        }            }    preorder(this.king);    return res;};/** * Your ThroneInheritance object will be instantiated and called as such: * var obj = new ThroneInheritance(kingName) * obj.birth(parentName,childName) * obj.death(name) * var param_3 = obj.getInheritanceOrder() */\n2192.有向无环图的祖先题目：\n给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。\n\n解析：\n第一反应可以逆向+dfs注意这里用js创建邻接表用Array.from()方法\n/** * @param {number} n * @param {number[][]} edges * @return {number[][]} */var getAncestors = function(n, edges) {    //创建[[],[],[],[]]    const adj=Array.from({length:n},()=&gt;[]);    //反向建图    for(const [x,y] of edges){        adj[y].push(x);    }    const dfs=(x,adj,vis)=&gt;{        vis[x]=true;        for(const y of adj[x]){            if(!vis[y]){                dfs(y,adj,vis);            }        }    }    const res=Array.from({length:n},()=&gt;[]);    const vis=Array(n);    for(let i=0;i&lt;n;i++){        vis.fill(false);        dfs(i,adj,vis);        vis[i]=false;        for(let j=0;j&lt;n;j++){            if(vis[j]){                res[i].push(j);            }        }    }    return res;};\n1026.节点与其祖先之间的最大差值题目：\n给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n\n解析：\ndfs+记录前面节点的最大值和最小值即可\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number} */var maxAncestorDiff = function(root) {    const dfs=(root,min,max)=&gt;{        if(root==null){            return 0;        }        let res=Math.max(Math.abs(root.val-min),Math.abs(root.val-max));        min=Math.min(min,root.val);        max=Math.max(max,root.val);        res=Math.max(dfs(root.left,min,max),res);        res=Math.max(dfs(root.right,min,max),res);        return res;    }    return dfs(root,root.val,root.val);};\n1483.树节点的第k个祖先题目：\n给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。实现 TreeAncestor 类：TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。getKthAncestor(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。\n\n解析：\n暴力向上递归查找父节点会超时，学一下倍增的方法\n官方题解又没太看懂，先通过例子来理解一下ST表和倍增的思路\n假如有链表A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G，从任意节点跳k步可以到下一个节点，比如A跳两步到C，B跳两步到D\n那么设 f[step][begin] 表示从 begin 开始跳 step 步到达的位置，f[0][begin] = begin，f[1][begin] = f[0][begin]-&gt;next ，f[2][begin] =f[1][begin]-&gt;next，那么f[4]可以表示为跳四步跳两步再跳两步，即f[4][begin] = f[2][f[2][begin]]。\n至此跳任意k步都可以化为二进制的形式求和，而二进制的步长完全可以由前一步递推得到，这就是倍增思想，是st表的指导思想. 一般地有\n当 step1+step2 == step时f[step][begin] = f[step2][f[step1][begin]]\n选取2作为一般步长保留计算结果取log(step) 节约空间 f[i][begin] 表示从 begin 位置起跳，跳 1&lt;&lt;i 步到达的点，利用 dp 可求得 f[i][j]\n回到本题定义 ancestors[i][j] 表示节点 i 的第 个祖先。状态转移方程是 ancestors[i][j]=ancestors[ancestors[i][j−1]][j−1]，即当前节点的第 个祖先，是他的第 个祖先的第 个祖先。当第 个祖先不存在时，记为 −1。\ngetKthAncestor需要找到 k 的二进制表示中的所有 1（相当于把 k 分解为若干 ），然后对K进行移位，k的每个1位都表示跳数\n/** * @param {number} n * @param {number[]} parent */const LOG = 16;var TreeAncestor = function(n, parent) {    ancestors = new Array(n).fill(0).map(() =&gt; new Array(LOG).fill(-1));    for (let i = 0; i &lt; n; i++) {        ancestors[i][0] = parent[i];    }    for (let j = 1; j &lt; LOG; j++) {        for (let i = 0; i &lt; n; i++) {            if (ancestors[i][j - 1] !== -1) {                ancestors[i][j] = ancestors[ancestors[i][j - 1]][j - 1];            }        }    }    };/**  * @param {number} node  * @param {number} k * @return {number} */TreeAncestor.prototype.getKthAncestor = function(node, k) {    for (let j = 0; j &lt; LOG; j++) {        if (((k &gt;&gt; j) &amp; 1) !== 0) {            node = ancestors[node][j];            if (node === -1) {                return -1;            }        }    }    return node;};/** * Your TreeAncestor object will be instantiated and called as such: * var obj = new TreeAncestor(n, parent) * var param_1 = obj.getKthAncestor(node,k) */\n42.接雨水题目：\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n解析：\n经典题目\n1.dp从左至右最高的扫过去，可以得到以左边边界为最大值的雨水；从右至左最高的扫过去，可以得到以右边边界为最大值的雨水。两者重叠部分就是能接到的雨水，可以理解为某一下标处能接到的雨水等于左右两边的最大值较小的那一个减去当前下标\n\nleftMax[i] 表示下标 i及其左边的位置中，height的最大高度，rightMax[i]表示下标 i 及其右边的位置中，height的最大高度，正向和反向各遍历一次即可\nvar trap = function(height) {    const len = height.length;    if(len==0){        return 0;    }    const leftMax=new Array(len).fill(0);    const rightMax=new Array(len).fill(0);    leftMax[0]=height[0];    rightMax[len-1]=height[len-1];    for(let i=1;i&lt;len;i++){        leftMax[i]=Math.max(leftMax[i-1],height[i]);    }    for(let i=len-2;i&gt;=0;i--){        rightMax[i]=Math.max(rightMax[i+1],height[i]);    }    let res=0;    for(let i=0;i&lt;len;i++){        res+=Math.min(rightMax[i],leftMax[i])-height[i];    }    return res;};\n代码可以进一步优化，不用两个数组，两个指针就行\nvar trap = function(height) {    const len = height.length;    if(len==0){        return 0;    }    const rightMax=new Array(len).fill(0);    let leftMax=0;    rightMax[len-1]=height[len-1];    for(let i=len-2;i&gt;=0;i--){        rightMax[i]=Math.max(rightMax[i+1],height[i]);    }    let res=0;    for(let i=0;i&lt;len;i++){        leftMax=Math.max(leftMax,height[i]);        res+=Math.min(rightMax[i],leftMax)-height[i];    }    return res;};\n\n单调栈\n\n创建一个栈来存储height的索引，依次遍历数组入栈，保证栈里的高度是递减的，当遇到比当前的栈顶元素的高度高时，栈顶元素出栈，栈顶元素索引左右两边的元素高度取最小值，减去栈顶元素的高度，再乘以两个元素索引之间的间距，一直循环直到栈里为空，再进入下一个索引比较\n这样是可以保证当元素高度递减的时候，不停入栈，但是当出现一个更高的，就会停下来循环出栈，直到高度差被磨平(凹槽被填满)，再继续入栈\n/** * @param {number[]} height * @return {number} */var trap = function(height) {    let res=0;    //栈里压入的是索引序号，要通过height获取高度值    const stack=[];    const len=height.length;    for(let i=0;i&lt;len;i++){        while(stack.length&amp;&amp;height[i]&gt;height[stack[stack.length-1]]){            const top=stack.pop();            if(!stack.length){                break;            }            res+=(Math.min(height[i],height[stack[stack.length-1]])-height[top])*(i-stack[stack.length-1]-1);        }        stack.push(i);    }    return res;};\n1268.搜索推荐系统题目：\n给你一个产品数组 products 和一个字符串 searchWord ，products  数组中每个产品都是一个字符串。请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。\n\n解析：\n题目的意思是每键入一个字母，就全局比较一次前缀。最简单的方法应该是字典树，把product数组里的每一个字符串都存入字典树里，然后searchWord字符串键入就是进入下一层搜索\n题目中需要先对product进行字典序排序，然后依次插入字典树，每个节点都维护一个数组记录一下当前插入的字符所属原字符串在product数组中的顺序，这个表只记录前3个就可\n由于字典树构建空间消耗很大，当products数组已经排序后可以考虑二分\n/** * @param {string[]} products * @param {string} searchWord * @return {string[][]} */var suggestedProducts = function(products, searchWord) {    products.sort();    const len=products.length;    const res=[];    for(let i=0;i&lt;searchWord.length;i++){        const cur=searchWord.substring(0,i+1);        let l=0,r=len-1;        while(l&lt;r){            //可以用位运算来/2            const mid=(l+r)&gt;&gt;1;            if(products[mid].localeCompare(cur) &gt;= 0){                r=mid;            }else{                l=mid+1;            }        }        const list=[];        //localeCompare方法如果引用字符串（referenceStr）存在于比较字符串（compareString）之前则为负数；如果引用字符串存在于比较字符串之后则为正数；相等的时候返回 0        if(products[r].localeCompare(cur)&gt;=0){            for(let j=r;j&lt;=Math.min(len-1,r+2);j++){                if(products[j].length&lt;cur.length||!products[j].startsWith(cur)){                    break;                }                list.push(products[j]);            }        }        res.push(list);    }    return res;};\n77.组合题目：\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。\n\n解析：\n经典回溯，树的宽度是可选的范围大小，深度是选择次数，在本题里就是宽度是n，深度是k\n还需要额外维护一个保存结果的二维数组和记录了遍历路径的数组\n/** * @param {number} n * @param {number} k * @return {number[][]} */var combine = function(n, k) {    let res=[];    let path=[];    const backtracking=(n,k,next)=&gt;{        if(path.length==k){            //// 将 path的副本推入 res，而不是直接推入 path，否则后面pop和push操作都会影响path            res.push([...path]);            return;        }        //这里如果剪枝的话，应该改成i&lt;=n - (k - path.length) + 1        //就是保证当后面还要选取的对象都包含在path里时，当前遍历可以停止了        //例：n = 4, k = 3        //path.size() = 0 时还需要3个数构成组合，最后3个数为{2, 3, 4}，故此时至多应遍历到2，即4-3+1=2        //path.size() = 1 时还需要2个数构成组合，最后2个数为{3, 4}，故此时至多应遍历到3，即4-2+1=3        //path.size() = 2 时还需要1个数构成组合，最后1个数为{4}，故此时至多应遍历到4，即4-1+1=4        for(let i=next;i&lt;=n;i++){            path.push(i);            backtracking(n,k,i+1);            path.pop();        }    }    backtracking(n,k,1);    return res;};\n216.组合总和III题目：\n找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：只使用数字1到9每个数字 最多使用一次返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n\n解析：\n还是回溯，只不过多了一个条件就是求和，可以用n在每次查找过程中减去当前选择的元素，回溯的时候加上，最后n为0且path.length=k的path就是答案\n/** * @param {number} k * @param {number} n * @return {number[][]} */var combinationSum3 = function(k, n) {    let res=[],path=[];    const backtracking=(k,n,next)=&gt;{        if (n &lt; 0) {            return;        }        if(path.length==k){            if(n==0){                res.push([...path]);            }            return;        }        for(let i=next;i&lt;=9 - (k - path.length) + 1;i++){            n-=i;            path.push(i);            backtracking(k,n,i+1);            path.pop();            n+=i;        }    }    backtracking(k,n,1);    return res;};\n394.字符串解码题目：\n给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n解析：\n/** * @param {string} s * @return {string} */var decodeString = function (s) {    let res = \"\";    let num = 0;    let stack = [];    let stack_num = [];    for (const ch of s) {        if (ch == '[') {            stack_num.push(num);            stack.push(res);            num = 0;            res = \"\";        } else if (ch == ']') {            const tmp_num = stack_num.pop();            res = stack.pop() + res.repeat(tmp_num);;        } else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {            num = num * 10 + parseInt(ch);        } else {            res+=ch;        }    }    return res;};\n1702.修改后的最大二进制字符串题目：\n给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：操作 1 ：如果二进制串包含子字符串 “00” ，你可以用 “10” 将其替换。比方说， “00010” -&gt; “10010”操作 2 ：如果二进制串包含子字符串 “10” ，你可以用 “01” 将其替换。比方说， “00010” -&gt; “00001”请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。\n\n解析：\n思路就是二进制前面00越多越好，00可以由操作2构造出来，例如01110，可以用操作2把后面的0冒泡式往前推，变成00111，然后替换成10111\n/** * @param {string} binary * @return {string} */var maximumBinaryString = function (binary) {    let res = binary.split(\"\");    for (let i = 0,j=0; i &lt; res.length; i++) {        if (res[i] == \"0\") {            //找到当前0之后第一次出现0的位置            //然后可以冒泡式把0往前推            while(j&lt;=i||(j&lt;res.length&amp;&amp;res[j]==\"1\")){                j++;            }            if(j&lt;res.length){                res[j]=\"1\";                res[i]=\"1\";                res[i+1]=\"0\";            }        }    }    return res.join(\"\");};\n进一步思考，最后的结果应该最多只有1个0，有两个0或以上就可以变成10的模式减少0，所以只需要知道第一次出现0的位置就可以构造答案\n/** * @param {string} binary * @return {string} */var maximumBinaryString = function (binary) {    const n = binary.length;    const i = binary.indexOf('0');    if (i &lt; 0) {        return binary;    }    //有多少个0，结果0就要往后移几-1位    const zeros = binary.split('0').length - 1;    const res = Array(n).fill('1');    res[i + zeros - 1] = '0';    return res.join('');};\n1657.确定两个字符串是否接近题目：\n如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：操作 1：交换任意两个 现有 字符。例如，abcde -&gt; aecdb操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）你可以根据需要对任意一个字符串多次使用这两种操作。给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。\n\n解析：\n题目的意思是只要两个字符串出现过的字母相同，出现过的次数相同，就是接近\n/** * @param {string} word1 * @param {string} word2 * @return {boolean} */var closeStrings = function (word1, word2) {    if (word1.length != word2.length) {        return false;    }    const set1=new Array(26).fill(0);    const set2=new Array(26).fill(0);    for(let i=0;i&lt;word1.length;i++){        set1[word1.charCodeAt(i)-'a'.charCodeAt()]++;        set2[word2.charCodeAt(i)-'a'.charCodeAt()]++;    }    for(let i=0;i&lt;26;i++){        if((set1[i]===0)!==(set2[i]===0)){            return false;        }    }    set1.sort((a, b) =&gt; a - b);    set2.sort((a, b) =&gt; a - b);    //这里被坑了一下不能用==或者===来判断，因为判断的是引用而不是数组内容    return set1.toString()==set2.toString();};\n2352.相等行列对题目：\n给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。\n\n解析：\n哈希表，就是把每一行转成string都存进哈希表里，然后遍历列对应查找\n/** * @param {number[][]} grid * @return {number} */var equalPairs = function(grid) {    const len=grid.length;    const hash={};    for(const row of grid){        const rowStr=row.toString();        hash[rowStr]=(hash[rowStr]||0)+1;    }    let res=0;    for(let i=0;i&lt;len;i++){        let col=[];        for(let j=0;j&lt;len;j++){            col.push(grid[j][i]);        }        if(hash[col.toString()]){            res+=hash[col.toString()];        }    }    return res;};\n1161.最大层内元素和题目：\n给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。\n\n解析：\n\ndfs\n\n带层号进行深度遍历\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number} */var maxLevelSum = function(root) {    const sum=[];    const dfs=(node,level)=&gt;{        if(level==sum.length){            sum.push(node.val);        }else{            sum[level]+=node.val;        }        if(node.left){            dfs(node.left,level+1);        }        if(node.right){            dfs(node.right,level+1);        }    }    dfs(root,0);    let idx=0;    for(let i=0;i&lt;sum.length;i++){        if(sum[i]&gt;sum[idx]){            idx=i;        }    }    return idx+1;};\n\nbfs\n\n记录一下每层的和\nvar maxLevelSum = function (root) {    let maxsum=root.val;    let q = [];    q.push(root);    let maxlevel=1,level=1;    while (q.length) {        let sum=0,len=q.length;        for (let i = 0; i &lt; len; i++) {            const node = q.shift();            sum += node.val;            if (node.left) {                q.push(node.left);            }            if (node.right) {                q.push(node.right);            }        }        if(sum&gt;maxsum){            maxlevel=level;            maxsum=sum;        }        level++;    }    return maxlevel;};\n328.奇偶链表题目：\n给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。\n\n解析：\n链表的题主要是要画图，这里额外使用奇偶两个指针，遍历一次把奇偶节点分开，然后再拼接\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var oddEvenList = function(head) {    if(head==null||head.next==null){        return head;    }    let evenhead=head.next;    let odd=head,even=head.next;    while(even!=null&amp;&amp;even.next!=null){        odd.next=even.next;        odd=odd.next;        even.next=odd.next;        even=even.next;    }    odd.next=evenhead;    return head;};\n2130.链表最大孪生和题目：\n在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;= i &lt;= (n / 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。比方说，n = 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。孪生和 定义为一个节点和它孪生节点两者值之和。给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。\n\n解析：\n快慢指针先找到后一半的起始节点，然后翻转前一半的节点\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {number} */var pairSum = function(head) {    let s=head,f=head.next;    while(f.next!=null){        s=s.next;        f=f.next.next;    }    let head1 =s.next;    s.next=null;    const reverseList = function(head) {    let prev = null;    let curr = head;    while (curr) {        const next = curr.next;        curr.next = prev;        prev = curr;        curr = next;    }    return prev;    };    let head2=reverseList(head);    let max=0;    while(head1!=null){        max=Math.max(head1.val+head2.val,max);        head1=head1.next;        head2=head2.next;    }    return max;};\n547.省份数量题目：\n有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量。\n\n解析：\n\ndfs其实就是查找图里有多少连通的集合\n\n/** * @param {number[][]} isConnected * @return {number} */var findCircleNum = function (isConnected) {    let provinces = 0;    let vis = new Set();    let cities = isConnected.length;    const dfs = (isConnected, vis, cities, i) =&gt; {        for (let j = 0; j &lt; cities; j++) {            if (isConnected[i][j] == 1 &amp;&amp; !vis.has(j)) {                vis.add(j);                dfs(isConnected, vis, cities, j);            }        }    }    for (let i = 0; i &lt; cities; i++) {        if (!vis.has(i)) {            dfs(isConnected, vis, cities, i);            provinces++;        }    }        return provinces;};\n\nbfs\n\n/** * @param {number[][]} isConnected * @return {number} */var findCircleNum = function (isConnected) {    let provinces = 0;    let vis = new Set();    let cities = isConnected.length;    let queue=[];    for (let i = 0; i &lt; cities; i++) {        if (!vis.has(i)) {            queue.push(i);            //这里只有一个while的原因是没有同一时刻的要求，只要联通就可以算作一个省            while(queue.length){                const city=queue.shift();                vis.add(city);                for(let j=0;j&lt;cities;j++){                    if(isConnected[city][j]==1&amp;&amp;!vis.has(j)){                        queue.push(j);                    }                }            }            provinces++;        }    }        return provinces;};\n1926.迷宫中离入口最近的出口题目：\n给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 ‘.’ 表示）和墙（用 ‘+’ 表示）。同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。\n\n解析：\n应该是广度优先，遍历到边界就证明有出口，这里可以注意一下写法，把行列变化量作为数组，不然容易太多数组加减\n/** * @param {character[][]} maze * @param {number[]} entrance * @return {number} */var nearestExit = function (maze, entrance) {    let queue = [];    let move = [[0, -1], [-1, 0], [0, 1], [1, 0]];    let rows = maze.length, cols = maze[0].length;    maze[entrance[0]][entrance[1]] = \"+\";    queue.push([...entrance,0]);    while (queue.length) {        let [i, j,step] = queue.shift();        for (let m of move) {            let curi = m[0] + i, curj = m[1] + j;            if (curi &gt;= 0 &amp;&amp; curi &lt; rows &amp;&amp; curj &gt;= 0 &amp;&amp; curj &lt; cols &amp;&amp; maze[curi][curj] == \".\") {                if (curi == 0 || curi == rows - 1 || curj == 0 || curj == cols - 1) {                    return step + 1;                }                maze[curi][curj] = \"+\";                queue.push([curi, curj,step+1]);            }        }    }    return -1;};\n/** * @param {character[][]} maze * @param {number[]} entrance * @return {number} */var nearestExit = function (maze, entrance) {    let queue = [];    let move = [[0, -1], [-1, 0], [0, 1], [1, 0]];    let rows = maze.length, cols = maze[0].length;    let step = 0;    queue.push(entrance);    while (queue.length) {        let len = queue.length;        //这里要有另外一个while的主要原因是不同路径是同一时刻延伸的，所以每一分钟都必须清空queue里所有值，再进入下一分钟        while (len--) {            let [i, j] = queue.shift();            maze[i][j] = \"+\";            for (let m of move) {                let curi = m[0] + i, curj = m[1] + j;                if (curi &gt;= 0 &amp;&amp; curi &lt; rows &amp;&amp; curj &gt;= 0 &amp;&amp; curj &lt; cols &amp;&amp; maze[curi][curj] == \".\") {                    if (curi == 0 || curi == rows - 1 || curj == 0 || curj == cols - 1) {                        return step + 1;                    }                    maze[curi][curj] = \"+\";                    queue.push([curi, curj]);                }            }        }        step++;    }    return -1;};\n\n接算法笔记（四）~","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（一）","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言最近在准备面试，投递岗位主要是前端，但是本人也有点想转后端，所以算法题必刷不可。本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java数据结构部分回顾直接看我大二上的数据结构复习笔记，感觉网上查到的没有总结的特别好和全面的(如果我还有精力，会考虑把之前专业课的笔记也放上来。以前的笔记都是OneNote里写的，不是Markdown语法，还都是全英的，整理起来有点复杂)目前先看了一下算法基础，可以参考以下文章的介绍，基本上js扫盲没问题，然后开始力扣刷题https://juejin.cn/post/7087134135193436197\n力扣目前是先把LeetCode75刷完，同时也做每日一题，进行算法扫盲  \n唉，没想到上一次刷力扣都是一年前了，这一次争取刷题量大一点，坚持的久一点，会持续更新的  \n算法笔记（一）已经记录了二十道题，后续每二十道题会新开笔记，刷完后会对题型类别进行再整理\n\n\n题库LeetCode75本笔记涉及到的知识点一览\n\n[ ] 数组 / 字符串 334 151 1071 605 2789\n[ ] 双指针\n[ ] 滑动窗口 1493 1004 1793\n[ ] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈 735\n[ ] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[ ] 二叉搜索树\n[ ] 图 - 深度优先搜索 1261 841\n[ ] 图 - 广度优先搜索 2684 310\n[ ] 堆 / 优先队列 215\n[ ] 二分查找 875\n[ ] 回溯\n[ ] 动态规划 - 一维 1137\n[ ] 动态规划 - 多维 72 2312 62\n[ ] 位运算\n[ ] 前缀树\n[ ] 区间集合\n[x] 单调栈 739 901\n\n\n334.递增的三元子序列题目：\n给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。\n\n解析：\n\n双向遍历 其实本质上就是找到数组中的一个元素，左边有值比它小，右边有值比它大。那么新创建两个长度为n的MIN和MAX数组，即MIN[i]表示nums[0]到nums[i]中的最小值，MAX[i]表示nums[0]到nums[i]中的最大值，然后遍历nums数组找到MIN[i-1]&lt;nums[i]&lt;MAX[i+1]的返回true  \n 整个逻辑需要遍历数组三遍，额外创建两个数组\n\n贪心算法 简单说就是寻找局部最优解，再把每次迭代后的最优解叠加\n 本题目怎么联想到贪心呢，因为看完题目后三元组中的第一个肯定是越小越容易满足递增的情况，所以就是要找到最小的做first，第二小的做second，这样遍历只用找到比second大就返回true  \n 那么迭代思路就是先令nums[0]为first，second为正无穷，开始遍历。遇到nums[i]&gt;second的返回true;遇到first","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（二）","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（一），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \n题库LeetCode75本题库涉及到的知识点一览\n\n[x] 数组 / 字符串 443\n[ ] 双指针\n[ ] 滑动窗口\n[x] 前缀和\n[ ] 哈希表 / 哈希集合\n[ ] 栈\n[x] 队列\n[ ] 链表\n[ ] 二叉树 - 深度优先搜索\n[ ] 二叉树 - 广度优先搜索\n[x] 二叉搜索树\n[ ] 图 - 深度优先搜索\n[ ] 图 - 广度优先搜索\n[ ] 堆 / 优先队列\n[ ] 二分查找\n[ ] 回溯\n[ ] 动态规划 - 一维\n[ ] 动态规划 - 多维\n[ ] 位运算 338\n[ ] 前缀树\n[x] 区间集合\n[x] 单调栈\n\n\n238.除自身以外数组的乘积题目：\n给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。\n\n解析：\n经典的前缀和和后缀和，不做多解释了，不过可以稍微优化一下，毕竟维护两个数组内存消耗太大了\n/** * @param {number[]} nums * @return {number[]} */var productExceptSelf = function(nums) {    const len=nums.length;    let ans=new Array(len).fill(1);    let L=1;    for(let i=0;i&lt;len;i++){        ans[i]*=L;        L*=nums[i];    }    let R=1;    for(let i=len-1;i&gt;=0;i--){        ans[i]*=R;        R*=nums[i];    }    return ans;};\n206.反转链表进阶题目：\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。使用递归完成\n\n解析：\n简单解法就是迭代，双指针，保存当前和之前节点，然后遍历修改指向对象\n比较复杂的是递归，需要理解想让指向，可以通过，然后要注意的下一个节点要指向null\n/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function(head) {    if(head==null||head.next==null){        return head    }    //靠这一步一直递归到列表的最后一个节点    const newHead=reverseList(head.next);    /*    第一轮出栈，head为5，head.next为空，返回5    第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，        把当前节点的子节点的子节点指向当前节点        此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null        此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5        返回节点5    第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，        此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null        此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5        返回节点5    第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，        此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null        此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5        返回节点5    出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1     */    head.next.next=head;    head.next=null;    return newHead};s\n1969.数组元素的最小非零乘积题目：\n给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：从 nums 中选择两个元素 x 和 y  。选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。注意：答案应为取余 之前 的最小值。\n\n解析：​贪心：为了使整体的乘积最小，缩小时优先缩小最小的元素，增加时优先增加最大的元素\n证明：假设a &lt; b &lt; c。选择a缩小1时，此时三者乘积为 (a−1)bc，整体较 abc 缩小了 bc，缩小的幅度最大；当选择b增加1时，此时三者乘积为(a−1)(b+1)c，整体较(a−1)bc 增加了 (a−1)c，增加的幅度最小，得证。\n两个数在进行相同的位交换时，本质即将一个元素缩小 ，另外一个元素增加，为了让这两个数乘积最小，应该尽量把小的那个数换成1。\n根据上述分析，进行相同位交换时，优先缩小数组中最小的元素，再增加数组中最大的元素。\n可以以p为分界线，小于p的为一组，大于p的为一组，大小组的每一个元素(除了)外，遵循最大配最小，第二大配第二小的原则，两两配对(每组两个数之和为)，交换后的必然为和1，乘积是。\n最后，最小乘积为\n由于幂次很大，计算时需要用到快速幂，之前有题目用到了快速幂(指路算法笔记（一）1137.第N个泰波那契数https://ella1019.site/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/#1137-%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)\n/** * @param {number} p * @return {number} */const MOD = 1_000_000_007n;function pow(x, p) {    let res = 1n;    while (p--) {        res = res * x % MOD;        x = x * x % MOD;    }    return res;}var minNonZeroProduct = function(p) {    const k = (1n &lt;&lt; BigInt(p)) - 1n;    return k * pow(k - 1n, p - 1) % MOD;};\n338.比特位计数题目：\n给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。\n\n解析：\n借由本题学习一下位运算相关的知识\n\nBrian Kernighan 算法 对于任意整数x，令 ，该运算将x的二进制表示的最后一个1变成 0，以及后面的0都变成1，而1前面的数不会变。进行&amp;操作之后原本最后一个1以及后面所有的0都会变成0，这样成功实现了减少一个1的目的，可以用这个方法来计数所有的1的个数\n 总的时间复杂度为O(nlogn)\n /** * @param {number} n * @return {number[]} */var countBits = function (n) {    const bits = new Array(n + 1).fill(0);    const countOnes = (x) =&gt; {        let ones = 0;        while (x &gt; 0) {            x &amp;= (x - 1);            ones++;        }        return ones;    }    for (let i = 0; i &lt; n + 1; i++) {        bits[i] = countOnes(i);    }    return bits;};\n\n动态规划(最高有效位) 主要是利用2的整数幂(  )对应的二进制表示都是最高位是1，其余位都是0，这里尝试抽象出状态变化 \n 举一个例子，13的二进制表达为1101，它的最高位是1000，即为8(  )，减去最高位后5的二进制表达式为101，1的个数比13要少1\n 那么只需要遍历然后判断2的整数幂即可\n var countBits = function(n) {    const bits = new Array(n + 1).fill(0);    let highBit = 0;    for (let i = 1; i &lt;= n; i++) {        if ((i &amp; (i - 1)) == 0) {            highBit = i;        }        bits[i] = bits[i - highBit] + 1;    }    return bits;};\n\n动态规划(最低有效位) 同样的，也可以从最低位入手，将二进制表示x右移一位，等价于。\n 如果x是偶数，则 \n 如果x是奇数，则\n 上述两种情况可以进一步简化。由于可以通过 x&gt;&gt;1得到，x除以2的余数可以通过得到，因此有：\n var countBits = function(n) {const bits = new Array(n + 1).fill(0);for (let i = 1; i &lt;= n; i++) {    bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);}return bits;};\n\n动态规划(最低设置位) 就是整合前面的规律，得到 \n var countBits = function(n) {    const bits = new Array(n + 1).fill(0);    for (let i = 1; i &lt;= n; i++) {        bits[i] = bits[i &amp; (i - 1)] + 1;    }    return bits;};\n\n\n322.零钱兑换题目：\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。\n\n解析：\n\n动态规划\n 这里的状态转移方程应该是 ，F(i)为组成金额i所需最少的硬币数量，表示第j枚硬币的面值，这里枚举所有的硬币面值，选数量最少的。\n 这里循环的内外顺序没有区别\n 时间复杂度为O(amount*coins.length)，空间复杂度为O(amount)\n var coinChange = function(coins, amount) {    let num=new Array(amount+1).fill(amount+1);    num[0]=0;    for(let i=1;i&lt;amount+1;i++){        for(const coin of coins){            if(coin&lt;=i){                num[i]=Math.min(num[i],num[i-coin]+1);            }        }    }    return num[amount] &gt; amount ? -1 : num[amount];};\n\n贪心\n 本题我的第一反应就是贪心，优先大面值，余数小面值，不行的话就大面值回滚一个再小面值，但是会超时？而且有些奇葩用例最先找到的并不是数量最少的，还是得全部遍历(例如amount=14，coins[1,7,10]，贪心会选择[10,1,1,1,1]，但正确答案应该是[7,7])？算下来还不如直接dp\n\n\n518.零钱兑换Ⅱ题目：\n给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。题目数据保证结果符合 32 位带符号整数。\n\n解析：\n本题是完全背包问题(不限量)的计数类型。注意循环顺序有讲究，外物品(钱类别)内背包(金额)，原因是这里返回的是组合数，不是排列数(不同顺序也算一种，即元素重复)，排列数循环反过来\ndp[j]：凑成总金额j的货币组合数为dp[j]，dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加\n本题递推公式 \n/** * @param {number} amount * @param {number[]} coins * @return {number} */var change = function (amount, coins) {    let num = new Array(amount + 1).fill(0);    num[0] = 1;    for (const coin of coins) {        for (let i = coin; i &lt; amount + 1; i++) {            num[i] += num[i - coin];        }    }    return num[amount];};\n443.压缩字符串题目：\n给你一个字符数组 chars ，请使用下述算法压缩：从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：如果这一组长度为 1 ，则将字符追加到 s 中。否则，需要向 s 追加字符，后跟这一组的长度。压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。请在 修改完输入数组后 ，返回该数组的新长度。你必须设计并实现一个只使用常量额外空间的算法来解决此问题。\n\n解析：\n没有特别需要说明的，就是正常遍历，用两个指针记录子串长度\n/** * @param {character[]} chars * @return {number} */var compress = function (chars) {    let r = 0, w = 0;    const len = chars.length;    while (r &lt; len) {        let index = r;        while (chars[index] == chars[r] &amp;&amp; index &lt; len) {            index++;        }        let cnt = index - r;        chars[w++] = chars[r];        if (cnt &gt; 1) {            let str = cnt.toString();            for (let i = 0; i &lt; str.length; i++) {                chars[w++] = str[i];            }        }        r = index;    }    return w;};\n11.盛最多水的容器题目：\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。\n\n解析：\n经典的双指针问题，面积实际上等于两个指针中较小的那一个值乘以两个指针间的距离\n这里先从数组边界开始，每一次都移动较小的边界指针(因为只有最短的会影响到整体)，最后遍历返回最大的\n/** * @param {number[]} height * @return {number} */var maxArea = function (height) {    let l = 0, r = height.length - 1, max = 0;    while (l &lt; r) {        max = Math.max(max, (r - l) * Math.min(height[l], height[r]));        if (height[l] &lt;= height[r]) {            ++l;        } else {            --r;        }    }    return max;};\n17.电话号码的字母组合题目：\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n解析：\n回溯：本质上就是穷举，把所有的情况以n叉树的形式表示出来，可以用伪代码表示递归逻辑\nvoid backtracking(递归深度，即树的高度) {    //终止条件    if (树是否递归完) {        保存结果;        return;    }    for (当前节点的子节点数量) {        处理当前子节点;        backtracking(下一层节点); // 递归        回溯，撤销当前子节点;    }}\n本题关键在于树的宽度是由每个数字对应的字母决定，树的深度由数字的数量决定\n/** * @param {string} digits * @return {string[]} */var letterCombinations = function (digits) {    if (digits.length == 0) return [];    let res = [], path = [];    const map = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];    if (digits.length === 1) return map[digits].split(\"\");    const backtracking = (digits, length, index) =&gt; {        if (path.length == length) {            res.push(path.join(\"\"));            return;        }        for (const s of map[digits[index]]) {            path.push(s);            backtracking(digits, length, index + 1);            path.pop(s);        }    }    backtracking(digits, digits.length, 0)    return res;};\n2580.统计将重叠区间合并成组的方案数题目：\n给你一个二维整数数组 ranges ，其中 ranges[i] = [starti, endi] 表示 starti 到 endi 之间（包括二者）的所有整数都包含在第 i 个区间中。你需要将 ranges 分成 两个 组（可以为空），满足：每个区间只属于一个组。两个有 交集 的区间必须在 同一个 组内。如果两个区间有至少 一个 公共整数，那么这两个区间是 有交集 的。比方说，区间 [1, 3] 和 [2, 5] 有交集，因为 2 和 3 在两个区间中都被包含。请你返回将 ranges 划分成两个组的 总方案数 。由于答案可能很大，将它对 109 + 7 取余 后返回。\n\n解析：\n合并区间的思路，一般是先把区间按照左边界排序，然后遍历区间，维护当前合并区间的最大右边界maxR。如果当前区间左边界l &gt; maxR，则没有重叠，更新maxR为当前区间右边界r；反之则右重叠区域，把当前区间合并，再更新maxR\n/** * @param {number[][]} ranges * @return {number} */var countWays = function(ranges) {    ranges.sort((a,b)=&gt;a[0]-b[0]);    let res=1,maxR=-1;    for(const [l,r] of ranges){        if(l&gt;maxR){            res=res*2%1_000_000_007;        }        maxR=Math.max(r,maxR);    }    return res;};\n435.无重叠区域题目：\n给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。\n\n解析：\n\n动态规划(超时)\n\n总结一下动态规划的逻辑一般是倒推，先假定一种情况，然后再逆推要达到这种情况的条件，找到规律以后遍历即可\n本题逻辑就是用fi表示以i区间为集合最后一个区间，不重叠的最大区间数。那么逆推条件，这个最大区间数应该是倒数第二个区间+1得到的，因为这里要求不重叠，所以倒数第二个区间不一定和最后一个区间相邻，应该寻找满足同时fj最大的。因此状态方程为 \n这里的时间复杂度达到了，所以必须优化\n\n贪心\n\n官方题解没太看懂，但是看评论区大佬解释理解了，可以代入情景今天有好几个活动，每个活动都可以用区间 [start,end]表示开始和结束的时间，请问你今天最多能参加几个活动呢？\n正确逻辑就是照结束时间从早到晚排序，优先选择参加那些结束时间早的，因为这样可以留下更多的时间参加其余的活动。如果有多个结束时间相同的，我们选择开始时间晚的，因为这样也有助于参加更多的活动。然后再从前往后遍历一遍，把后面重叠的删去，这样保证了最后得到的一定是最大不重叠区间\nvar eraseOverlapIntervals = function(intervals) {    if (!intervals.length) {        return 0;    }    intervals.sort((a, b) =&gt; a[1] - b[1]);    const n = intervals.length;    let right = intervals[0][1];    let ans = 1;    for (let i = 1; i &lt; n; ++i) {        if (intervals[i][0] &gt;= right) {            ++ans;            right = intervals[i][1];        }    }    return n - ans;};\n452.用最少数量的箭引爆气球题目：\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数\n\n解析：\n再来一道重叠区间！逻辑是一样的气球尾的位置升序排列，然后以第一个气球尾作为右边界，依次遍历，只要遇到第一个气球头超过了当前右边界，那么说明后续要么都没跟第一个气球重叠，要么哪怕有重叠后面的箭也会引爆，这样只用一次遍历即可\n/** * @param {number[][]} points * @return {number} */var findMinArrowShots = function(points) {    if (!points.length ) {        return 0;    }    points.sort((a, b) =&gt; a[1] - b[1]);    let pos = points[0][1]    let ans = 1;    for (let balloon of points) {        if (balloon[0] &gt; pos) {            pos = balloon[1];            ans++;        }    }    return ans;};\n1997.访问完所有房间的第一天题目：\n你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：假设某一天，你访问 i 号房间。如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 &lt;= nextVisit[i] &lt;= i 。如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果\n\n解析：\n动态规划，题目的意思是如果首次到达房间i，那么一定会回退到前面的房间nextVisit[i]，如果想到下一个房间只能是第二次访问，所以可以推测出到达i房间，[0,i)的房间已经被访问过偶数次\n这题麻烦在提取哪一个量作为状态量，这里定义dp[i]是从房间0到第一次到达房间i所花费的天数，这个转换逻辑是\n\n从0第一次到i-1    dp[i−1]  (隐藏条件[0,i-1)访问次数都是偶数)\n从i-1跳到nextVisit[i-1]    走1天\n从nextVisit[i-1]到i-1    dp[i-1]−dp[nextVisit[i]] ((nextVisit[i],i-1)访问次数都是偶数，所以这个区间的跳转情况跟第一次访问是一样的)\ni-1到i    走1天\n\n得到状态方程dp[i]=2*dp[i−1]−dp[nextVisit[i-1]]+2\n/** * @param {number[]} nextVisit * @return {number} */var firstDayBeenInAllRooms = function(nextVisit) {    const mod =1e9+7;    const len=nextVisit.length;    const dp=new Array(len).fill(0);    for(let i=1;i&lt;len;i++){        //注意这里为了避免负数要+mod        dp[i]=(2*dp[i-1]-dp[nextVisit[i-1]]+2+ mod)%mod;    }    return dp[len-1];};\n208.实现 Trie (前缀树)题目：\nTrie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类：Trie() 初始化前缀树对象。void insert(String word) 向前缀树中插入字符串 word 。boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n\n解析：\n简单解释前缀树就是多叉树，类似于把字符串纵向排列，每层子节点为26个，表示26字母，每个子节点又会对应下一层26个子节点，直到字符串所有字符遍历完，通常不会初始化所有的26个子节点，按照需求初始化\nvar Trie = function() {    this.children={};};/**  * @param {string} word * @return {void} */Trie.prototype.insert = function(word) {    let node = this.children;    for(const ch of word){        if(!node[ch]){            node[ch]={};        }        node=node[ch];    }    node.isEnd=true;};/**  * @param {string} word * @return {boolean} */Trie.prototype.search = function(word) {    let node = this.children;    for(const ch of word){        if(!node[ch]){            return false;        }        node=node[ch];    }    return node!==undefined&amp;&amp;node.isEnd!==undefined;};/**  * @param {string} prefix * @return {boolean} */Trie.prototype.startsWith = function(prefix) {    let node = this.children;    for(const ch of prefix){        if(!node[ch]){            return false;        }        node=node[ch];    }    return node!==undefined;};/** * Your Trie object will be instantiated and called as such: * var obj = new Trie() * obj.insert(word) * var param_2 = obj.search(word) * var param_3 = obj.startsWith(prefix) */\n649.Dota2参议院题目：\nDota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。\n\n解析：\n贪心加循环队列，维护两个阵营记录了各自参议员顺序的队列，按照顺序，当前参议院一定会淘汰掉下一个对方参议员，那么被淘汰掉的踢出队列，没被淘汰的进入队列尾部准备下一轮循环，最后看哪个队列不为空，即为获胜方\n这里注意获取字符串的每个字符序列可以用Array.from(string).entries()，from是转化为array，entries可以获取每一个元素和对应的索引，可以用for (const [index, element] of array.entries())获取\n一个小坑，在JavaScript中循环退出数组用while (array.length)，而不用array！=null，因为会超时[]!=null\n/** * @param {string} senate * @return {string} */var predictPartyVictory = function(senate) {    let radient=[],dire=[];    const n = senate.length;    for(const [index,ch] of Array.from(senate).entries()){        if(ch==\"R\"){            radient.push(index);        }else{            dire.push(index);        }    }    while(radient.length&amp;&amp;dire.length){        if(radient[0]&lt;dire[0]){            radient.push(radient[0]+n);        }else{            dire.push(dire[0]+n);        }        radient.shift();        dire.shift();    }    return radient.length ? \"Radiant\" : \"Dire\";};\n2095.删除链表的中间节点题目：\n给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。\n\n解析：\n设置一个head前的哨兵指针，然后设置快慢指针，快的一次走两个，慢的走一个，快的走到头，慢的所指就是中间节点\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution {    public ListNode deleteMiddle(ListNode head) {        ListNode pre = new ListNode(0, head);        ListNode fp = pre.next;        ListNode sp = pre;        while (fp != null &amp;&amp; fp.next != null) {            fp = fp.next.next;            sp = sp.next;        }        sp.next = sp.next.next;        return pre.next;    }}\n450.删除二叉搜索树中的节点题目：\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。\n\n解析：\n二叉搜索树构建增删改算法没啥好说的，数据结构基本常识了，做一下纯当练手了\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */var deleteNode = function(root, key) {    if(!root){        return null;    }    if (root.val &gt; key) {        root.left = deleteNode(root.left, key);        return root;    }    if (root.val &lt; key) {        root.right = deleteNode(root.right, key);        return root;    }    if(root.val==key){        if (!root.left &amp;&amp; !root.right) {            return null;        }        if (!root.right) {            return root.left;        }        if (!root.left ) {            return root.right;        }        let node=root.right;        while(node.left){            node=node.left;        }        root.right=deleteNode(root.right, node.val)        node.right=root.right;        node.left=root.left;        return node;    }};\n199.二叉树的右视图题目：\n给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n解析：\n\nbfs 广度优先，层序遍历，每次返回最右边的那一个\n     /** * Definition for a binary tree node.* public class TreeNode {*     int val;*     TreeNode left;*     TreeNode right;*     TreeNode() {}*     TreeNode(int val) { this.val = val; }*     TreeNode(int val, TreeNode left, TreeNode right) {*         this.val = val;*         this.left = left;*         this.right = right;*     }* }*/class Solution {    public List&lt;Integer&gt; rightSideView(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null) return ans;        Queue&lt;TreeNode&gt; q=new LinkedList&lt;&gt;();        q.offer(root);        int count;        while(!q.isEmpty()){            count=q.size();            for(int i=0;i&lt;count;i++){                TreeNode node=q.poll();                if(node.left!=null)q.offer(node.left);                if(node.right!=null)q.offer(node.right);                if(i==count-1)ans.add(node.val);            }        }        return ans;    }}\n\ndfs 深度优先，ans数组会获取到二叉树汇总最长路径，因为后访问右子树，如果有的话每层最右边节点会覆盖ans原先位置节点，最终可以得到右视图\n class Solution {    public List&lt;Integer&gt; rightSideView(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        dfs(root,0,ans);        return ans;            }    private void dfs(TreeNode node,int depth,List&lt;Integer&gt; ans){        if(node==null)return;        if(ans.size()&lt;=depth){            ans.add(node.val);        }else{            ans.set(depth, node.val);        }        dfs(node.left, depth + 1,ans);        dfs(node.right, depth + 1,ans);                }}\n\n\n2952.需要添加的硬币的最小数量题目：\n给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 可取得的金额 。返回需要添加到数组中的 任意面值 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。数组的 子序列 是通过删除原始数组的一些（可能不删除）元素而形成的新的 非空 数组，删除过程不会改变剩余元素的相对位置。\n\n解析：\n贪心假设现在得到了区间 [0,x−1] 中的所有整数，如果此时遍历到整数 coins[i]，那么把 [0,x−1]中的每个整数都增加 coins[i]，我们就得到了区间 [coins[i],coins[i]+x−1]中的所有整数。\n如果 coins[i]&lt;=x，那么合并 [0,x−1] 和 [coins[i],coins[i]+x−1] 这两个区间，我们可以得到 [0,coins[i]+x−1] 中的所有整数。如果 coins[i]&gt;x，或者遍历完了 coins数组，这意味着我们无法得到 x，那么就一定要把 x加到数组中（加一个比 x还小的数字就没法得到更大的数，不够贪），这样就可以得到了 [x,2x−1]中的所有整数，再与 [0,x−1]合并，可以得到 [0,2x−1]中的所有整数。然后再考虑 coins[i] 和 2x 的大小关系，继续分类讨论。\n/** * @param {number[]} coins * @param {number} target * @return {number} */var minimumAddedCoins = function(coins, target) {    coins.sort((x,y)=&gt;x-y);    let ans=0,x=1,i=0;    while(x&lt;=target){        if(i&lt;coins.length&amp;&amp;coins[i]&lt;=x){            x+=coins[i++];        }else{            ans++;            x*=2;        }    }    return ans;};\n331.验证二叉树的前序序列化题目：\n序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n\n解析：\n回忆一下前序中序后序遍历，前中后指的是根节点的位置\n本题用栈来模拟遍历，判断是否是叶子节点就是看该节点是否有两个#子节点\n因为是递归，判断当前是否递归完叶子结点就是通过查找到连续x,#,#，然后把这三个全部出栈，用#代替，这样父节点也可以模拟叶子结点，只要最后栈里只剩下#，那么就成功遍历完\n参考他人画的动画理解\n(好像消消乐)\n/** * @param {string} preorder * @return {boolean} */var isValidSerialization = function(preorder) {    let stack=[];    const arr=preorder.split(\",\")    for(const ch of arr){        stack.push(ch);        while(stack.length&gt;=3&amp;&amp;stack[stack.length-1] =='#'&amp;&amp; stack[stack.length-2] == '#' &amp;&amp; stack[stack.length-3] != '#'){            stack.pop();            stack.pop();            stack.pop();            stack.push(\"#\");        }    }    return stack.length==1&amp;&amp;stack.pop()==\"#\";};\n\n接算法笔记（三）~","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"算法学习笔记（四）","url":"/2024/04/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"前言本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java\n承接算法笔记（三），继续刷LeetCode75，同时也做每日一题，进行算法扫盲  \nLeetCode75完结！\n题库LeetCode75本题库涉及到的知识点一览\n\n[x] 数组 / 字符串\n[x] 双指针\n[x] 滑动窗口\n[x] 前缀和\n[x] 哈希表 / 哈希集合\n[x] 栈\n[x] 队列\n[x] 链表\n[x] 二叉树 - 深度优先搜索\n[x] 二叉树 - 广度优先搜索\n[x] 二叉搜索树\n[x] 图 - 深度优先搜索\n[x] 图 - 广度优先搜索\n[x] 堆 / 优先队列\n[x] 二分查找\n[x] 回溯\n[x] 动态规划 - 一维\n[x] 动态规划 - 多维\n[x] 位运算\n[x] 前缀树\n[x] 区间集合\n[x] 单调栈\n\n\n198.打家劫舍题目：\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n解析：\n经典dp，状态方程dp[i]=max(dp[i-2]+nums[i],dp[i-1])\n//copy灵神极致简洁代码var rob = function (nums) {    let f0 = 0, f1 = 0;    for (const x of nums) {        [f0, f1] = [f1, Math.max(f1, f0 + x)]    }    return f1;};\n431.路径求和Ⅲ题目：\n给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n解析：\n我的想法是先用dfs遍历，然后每个节点记录一下当前位置到根节点的路径上所有节点和，就是前缀和，但是没想好怎么用数据结构存储前缀和以及怎么确定节点是某一个节点的祖先。看了官解，用的是Map，记录的不是节点，而是某一个前缀和出现的次数，每次遍历了一个节点的路径会恢复状态查询其他路径\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @param {number} targetSum * @return {number} */var pathSum = function(root, targetSum) {    let presum=new Map();    presum.set(0,1);    const dfs=(root,presum,targetSum,cur)=&gt;{        if(root==null){            return 0;        }        let res=0;        cur+=root.val;        //查找是否有符合的前缀和        res=presum.get(cur-targetSum)||0;        presum.set(cur,(presum.get(cur)||0)+1);        res+=dfs(root.left,presum,targetSum,cur)+dfs(root.right,presum,targetSum,cur);        //这里是把下面所有节点遍历后，恢复原来状态，搜索其他路径        presum.set(cur,presum.get(cur)-1);        return res;    }    return dfs(root,presum,targetSum,0);};\n236.二叉树的最近公共祖先题目：\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n解析：\n本题在于递归的思路若 root 是 p,q的 最近公共祖先 ，那么只有三种情况p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；p=root ，且 q 在 root的左或右子树中；q=root ，且 p 在 root 的左或右子树中；\n先自顶向下遍历，遇到节点p或者q返回，然后自底向上回溯，第一个符合的root就是最近公共祖先\nvar lowestCommonAncestor = function (root, p, q) {    if (root == null || root == p || root == q) {        return root;    }    const left = lowestCommonAncestor(root.left, p, q);    const right = lowestCommonAncestor(root.right, p, q);    //p 和 q 都不在 root 的子树中，继续向上回溯    if(left==null&amp;&amp;right==null){        return null;    }    //左子树为空，那么p和q肯定在右子树里(一个在或者都在)    if(left==null){        return right;    }    //右子树为空，那么p和q肯定在左子树里(一个在或者都在)    if(right==null){        return left;    }    //p 和 q 在 root 的子树中    return root; };\n994.腐烂的橘子题目：\n在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n\n解析：\n多源bfs，和1926的迷宫很像，但是要注意这两个题都是同一时刻多点进行bfs，不一定是一条路径上或者联通的，所以要有两个while，第二个while是用于清空每一时刻queue里的值，这些是同时发生的\n/** * @param {number[][]} grid * @return {number} */var orangesRotting = function (grid) {    const direction = [[0, -1], [-1, 0], [0, 1], [1, 0]];    let queue = [];    let fresh = 0;    let rows = grid.length, cols = grid[0].length;    for (let i = 0; i &lt; rows; i++) {        for (let j = 0; j &lt; cols; j++) {            if (grid[i][j] == 1) {                fresh++;            }            //把所有腐烂橘子都加入队列            if (grid[i][j] == 2) {                queue.push([i, j]);            }        }    }    let minutes = 0;    while (queue.length != 0 &amp;&amp; fresh) {        let len = queue.length;        //这里一定要注意把queue当前的长度抽取出来，这是把同一分钟的腐烂橘子都一起向四周污染，如果不单独while的话会漏掉同一时间的腐烂橘子        while (len--) {            let cur = queue.shift();            for (dir of direction) {                let curi = dir[0] + cur[0], curj = dir[1] + cur[1];                if (curi &gt;= 0 &amp;&amp; curi &lt; rows &amp;&amp; curj &gt;= 0 &amp;&amp; curj &lt; cols &amp;&amp; grid[curi][curj] == 1) {                    grid[curi][curj] = 2;                    queue.push([curi, curj]);                    fresh--;                }            }        }        minutes++;    }    return fresh == 0 ? minutes : -1;};\n2009.使数组连续的最少操作数题目：\n给你一个整数数组 nums 。每一次操作中，你可以将 nums 中 任意 一个元素替换成 任意 整数。如果 nums 满足以下条件，那么它是 连续的 ：nums 中所有元素都是 互不相同 的。nums 中 最大 元素与 最小 元素的差等于 nums.length - 1 。比方说，nums = [4, 2, 5, 3] 是 连续的 ，但是 nums = [1, 2, 3, 5, 6] 不是连续的 。请你返回使 nums 连续 的 最少 操作次数。\n\n解析：\n滑动窗口问题，先排序，再每个数字都作为最小值试一下最少的操作数\nvar minOperations = function(nums) {    const n = nums.length;    const sortedUniqueNums = [...new Set(nums)];    sortedUniqueNums.sort((a, b) =&gt; a - b);    let res = n;    let j = 0;    for (let i = 0; i &lt; sortedUniqueNums.length; i++) {        const left = sortedUniqueNums[i];        const right = left + n - 1;        while (j &lt; sortedUniqueNums.length &amp;&amp; sortedUniqueNums[j] &lt;= right) {            res = Math.min(res, n - (j - i + 1));            j++;        }    }    return res;};\n1766.互质树题目：\n给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。\n\n解析：\ndfs，先暴力得到1-50内所有互质的元素集合gcds，然后后面对节点dfs，比较当前值gcds数组元素是否已经在前面的祖先节点出现过，然后再把当前的值对应位置存入tmp中\nvar getCoprimes = function(nums, edges) {    const n = nums.length;    const gcds = Array.from({ length: 51 }, () =&gt; []);    const tmp = Array.from({ length: 51 }, () =&gt; []);    const ans = Array(n).fill(-1);    const dep = Array(n).fill(-1);    const g = Array.from({ length: n }, () =&gt; []);    function gcd(a, b) {        while (b !== 0) {            [a, b] = [b, a % b];        }        return a;    }    function dfs(x, depth) {        dep[x] = depth;        for (const val of gcds[nums[x]]) {            if (tmp[val].length === 0) continue;            const las = tmp[val][tmp[val].length - 1];            if (ans[x] === -1 || dep[las] &gt; dep[ans[x]]) {                ans[x] = las;            }        }        //遍历过就把当前值对应的位置存进tmp，后面找互质就直接找的等于该值的最后一个位置，也就是最近祖先        tmp[nums[x]].push(x);        for (const val of g[x]) {            if (dep[val] === -1) { // 被访问过的点dep不为-1                dfs(val, depth + 1);            }        }        //边没有指明方向，所以回溯的时候要把当前的弹出来        tmp[nums[x]].pop();    }    // 初始化    for (let i = 1; i &lt;= 50; i++) {        for (let j = 1; j &lt;= 50; j++) {            if (gcd(i, j) === 1) {                gcds[i].push(j);            }        }    }    //这里是因为不知道边的方向，要等到遍历的时候才知道    for (const [x, y] of edges) {        g[x].push(y);        g[y].push(x);    }    dfs(0, 1);    return ans;};\n1372.二叉树中的最长交错路径题目：\n给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：选择二叉树中 任意 节点和一个方向（左或者右）。如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。改变前进方向：左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。请你返回给定树中最长 交错路径 的长度。\n\n解析：\n难得纯自己写了一次超越100%，思路蛮简单的，就是dfs，每个节点判断一下是向左还是向右，记录长度最大值即可\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number} */var longestZigZag = function(root) {    let max=0;    const dfs=(root,len,dir)=&gt;{        max=Math.max(max,len);        if(dir==\"left\"&amp;&amp;root.left!=null){            dfs(root.left,len+1,\"right\");        }        if(dir==\"right\"&amp;&amp;root.right!=null){            dfs(root.right,len+1,\"left\");        }        if(dir==\"left\"&amp;&amp;root.right!=null){            dfs(root.right,1,\"left\");        }        if(dir==\"right\"&amp;&amp;root.left!=null){            dfs(root.left,1,\"right\");        }    }    dfs(root,0,\"left\");    dfs(root,0,\"right\");    return max;};\n1466.重新规划路线题目：\nn 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。路线用 connections 表示，其中 connections[i] = [a, b] 表示从城市 a 到 b 的一条有向路线。今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。\n\n解析：\n这个题目就是把有向图变成以城市0为根的树，每个节点遍历能不能到城市0不好做，改成反向城市0能不能遍历到所有节点，能遍历过去的边代表实际中要反向，累加一下返回即可\n/** * @param {number} n * @param {number[][]} connections * @return {number} */var minReorder = function(n, connections) {    const graph=new Array(n).fill(0).map(()=&gt;new Array());    for(const edge of connections){        //这里按照一个点能到达所有点来构造邻接表        //正向到达被记为1，反向为0(后面要累积正向的)        graph[edge[0]].push([edge[1],1]);        graph[edge[1]].push([edge[0],0]);    }    const dfs=(cur,parent)=&gt;{        let res=0;        //对于当前节点遍历以其为起点的所有边        for(const edge of graph[cur]){            //如果当前边的终点是当前节点的父节点，证明已访问过，跳过，进入下一循环            if(edge[0]==parent){                continue;            }            //正向到达的实际上需要反向，所以累计加            //递归访问当前边的终点节点            res+=edge[1]+dfs(edge[0],cur);        }        return res;    }    return dfs(0,-1);};\n399.除法求值题目：\n给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。\n\n解析：\n这道题像是hard的medium\n\n建表把所有的点建模成一张图，边代表两个变量的比值\n\nvar calcEquation = function(equations, values, queries) {    let nvars = 0;    const variables = new Map();    //这一步是把字母先映射成数字    const n = equations.length;    for (let i = 0; i &lt; n; i++) {        if (!variables.has(equations[i][0])) {            variables.set(equations[i][0], nvars++);        }        if (!variables.has(equations[i][1])) {            variables.set(equations[i][1], nvars++);        }    }    // 对于每个点，存储其直接连接到的所有点及对应的权值    const edges = new Array(nvars).fill(0);    for (let i = 0; i &lt; nvars; i++) {        edges[i] = [];    }    for (let i = 0; i &lt; n; i++) {        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);        edges[va].push([vb, values[i]]);        edges[vb].push([va, 1.0 / values[i]]);    }    const queriesCount = queries.length;    const ret = [];    for (let i = 0; i &lt; queriesCount; i++) {        const query = queries[i];        let result = -1.0;        if (variables.has(query[0]) &amp;&amp; variables.has(query[1])) {            const ia = variables.get(query[0]), ib = variables.get(query[1]);            if (ia === ib) {                result = 1.0;            } else {                const points = [];                points.push(ia);                const ratios = new Array(nvars).fill(-1.0);                ratios[ia] = 1.0;                while (points.length &amp;&amp; ratios[ib] &lt; 0) {                    const x = points.pop();                    for (const [y, val] of edges[x]) {                        if (ratios[y] &lt; 0) {                            ratios[y] = ratios[x] * val;                            points.push(y);                        }                    }                }                result = ratios[ib];            }        }        ret[i] = result;    }    return ret;};\n\nFloyd算法优化查询次数\n\nvar calcEquation = function(equations, values, queries) {    let nvars = 0;    const variables = new Map();    const n = equations.length;    for (let i = 0; i &lt; n; i++) {        if (!variables.has(equations[i][0])) {            variables.set(equations[i][0], nvars++);        }        if (!variables.has(equations[i][1])) {            variables.set(equations[i][1], nvars++);        }    }    const graph = new Array(nvars).fill(0).map(() =&gt; new Array(nvars).fill(-1.0));    for (let i = 0; i &lt; n; i++) {        const va = variables.get(equations[i][0]), vb = variables.get(equations[i][1]);        graph[va][vb] = values[i];        graph[vb][va] = 1.0 / values[i];    }    for (let k = 0; k &lt; nvars; k++) {        for (let i = 0; i &lt; nvars; i++) {            for (let j = 0; j &lt; nvars; j++) {                if (graph[i][k] &gt; 0 &amp;&amp; graph[k][j] &gt; 0) {                    graph[i][j] = graph[i][k] * graph[k][j];                }            }        }    }    const queriesCount = queries.length;    const ret = new Array(queriesCount).fill(0);    for (let i = 0; i &lt; queriesCount; i++) {        const query = queries[i];        let result = -1.0;        if (variables.has(query[0]) &amp;&amp; variables.has(query[1])) {            const ia = variables.get(query[0]), ib = variables.get(query[1]);            if (graph[ia][ib] &gt; 0) {                result = graph[ia][ib];            }        }        ret[i] = result;    }    return ret;};\n2923.找到冠军题目：\n一场比赛中共有 n 支队伍，按从 0 到  n - 1 编号。给你一个下标从 0 开始、大小为 n * n 的二维布尔矩阵 grid 。对于满足 0 &lt;= i, j &lt;= n - 1 且 i != j 的所有 i, j ：如果 grid[i][j] == 1，那么 i 队比 j 队 强 ；否则，j 队比 i 队 强 。在这场比赛中，如果不存在某支强于 a 队的队伍，则认为 a 队将会是 冠军 。返回这场比赛中将会成为冠军的队伍。\n\n解析：\n本来只是个简单题，但是我觉得打擂台的思路很巧妙，记录一下。不用打擂台的话，有两种解法，i行的行和为n-1，代表i是冠军；j列中没有1，代表j是冠军\n打擂台：假设冠军是 champ=0，我们从 i=1 开始遍历，寻找可以击败 cham的队伍，也就是 grid[i][champ]=1。\n如果没有出现 grid[i][champ]=1，那么答案就是 champ，否则冠军可能是 i，更新 champ=i。然后从 i+1 继续向后遍历，因为 [1,i−1]中没有比 0 强的队，更别说比 i 强了。重复上述过程，最后返回 champ。\n/** * @param {number[][]} grid * @return {number} */var findChampion = function(grid) {    let champ=0;    for(let i=1;i&lt;grid.length;i++){        if(grid[i][champ]){            champ=i;        }    }    return champ;};\n162.寻找峰值题目：\n峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。你可以假设 nums[-1] = nums[n] = -∞ 。你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n\n解析：\n时间复杂度为 O(log n)一出，肯定是二分法，学一下爬坡法\n在 [0,n) 的范围内随机一个初始位置 i，随后根据 nums[i−1],nums[i],nums[i+1]三者的关系决定向哪个方向走：\n如果 nums[i−1]nums[i+1]，那么位置 i 就是峰值位置，可以直接返回 i 作为答案；\n如果 nums[i−1]&lt;nums[i]&lt;nums[i+1]，那么位置 i 处于上坡，需要往右走，即 i←i+1；\n如果 nums[i−1]&gt;nums[i]&gt;nums[i+1]，那么位置 i 处于下坡，需要往左走，即 i←i−1；\n如果 nums[i−1]&gt;nums[i]&lt;nums[i+1]，那么位置 i 位于山谷，两侧都是上坡，可以朝任意方向走。\n爬坡法为什么一定能找到山峰呢，一种通俗的理解是中点所在地方，可能是某座山的山峰，山的下坡处，山的上坡处，如果是山峰，最后会二分终止也会找到，关键是二分方向，并不知道山峰在我们左边还是右边，如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界。但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰，总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有。\n二分法最要注意的是区间问题，l和r带不带等号，mid+1还是-1，建议现场画图\n/** * @param {number[]} nums * @return {number} */var findPeakElement = function(nums) {    let l=0,r=nums.length-1;    while(l&lt;r){        let mid=Math.floor((l+r)/2);        if(nums[mid]&gt;nums[mid+1]){            r=mid;        }else{            l=mid+1;        }    }    return r;};\n2300.咒语和药水的成功对数题目：\n峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。你可以假设 nums[-1] = nums[n] = -∞ 。你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n\n解析：\n注意一下二分的开闭区间问题\n这里整理一下二分区间常见写法\n\n[left, right]\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] &gt; target) {                right = middle - 1; // target 在左区间，所以[left, middle - 1]            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }\n\n[left, right)\n\nint search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            int middle = left + ((right - left) &gt;&gt; 1);            if (nums[middle] &gt; target) {                right = middle; // target 在左区间，在[left, middle)中            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }\n本题用闭区间\n/** * @param {number[]} spells * @param {number[]} potions * @param {number} success * @return {number[]} */var successfulPairs = function(spells, potions, success){    potions.sort((a,b)=&gt;a-b);    const binarySearch=(l,r,nums,target)=&gt;{        let res=r+1;        while(l&lt;=r){            const mid=Math.floor((l+r)/2);            if(nums[mid]&gt;target){                res=mid;                r=mid-1;            }else{                l=mid+1;            }        }        return res;    }    return spells.map((item) =&gt; {        return potions.length - binarySearch( 0, potions.length - 1, potions,(success - 1) / item)    })};\n790.多米诺和托米诺平铺题目：\n有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。\n\n解析：\n\ndp这个方法得配图解释在第 i 列前面的正方形都被瓷砖覆盖，在第 i 列后面的正方形都没有被瓷砖覆盖（i 从 1 开始计数）。那么第 i 列的正方形有四种被覆盖的情况：\n\n一个正方形都没有被覆盖，记为状态 0；\n只有上方的正方形被覆盖，记为状态 1；\n只有下方的正方形被覆盖，记为状态 2；\n上下两个正方形都被覆盖，记为状态 3。\n使用 dp[i][s] 表示平铺到第 i 列时，各个状态 s 对应的平铺方法数量。考虑第 i−1列和第 i 列正方形，它们之间的状态转移如下图（红色条表示新铺的瓷砖）：\n\nvar numTilings = function(n) {    const mod = 1e9 + 7;    const dp = new Array(n + 1).fill(0).map(() =&gt; new Array(4).fill(0));    dp[0][3] = 1;    for (let i = 1; i &lt;= n; i++) {        dp[i][0] = dp[i - 1][3];        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % mod;        dp[i][3] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % mod;    }    return dp[n][3];};\n\n规律\n\n\n/** * @param {number} n * @return {number} */var numTilings = function(n) {    const mod = 1e9 + 7;    if (n == 1) return 1;        let f = new Array(n + 1);        f[0] = f[1] = 1;        f[2] = 2;        for (let i = 3; i &lt;= n; ++i)            f[i] = (f[i - 1] * 2 + f[i - 3]) % mod;        return f[n];};\n1143.最长公共子序列题目：\n给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n\n解析：\n经典dp\ndp[i][j] 表示 text1[0:i]和 text2[0:j]的最长公共子序列的长度\n状态转移方程：\n\n/** * @param {string} text1 * @param {string} text2 * @return {number} */var longestCommonSubsequence = function(text1, text2) {    let dp=new Array(text1.length+1).fill(0).map(()=&gt;new Array(text2.length+1).fill(0));    for(let i=1;i&lt;=text1.length;i++){        const ch=text1[i-1];        for(let j=1;j&lt;=text2.length;j++){            if(ch==text2[j-1]){                dp[i][j]=dp[i-1][j-1]+1;            }else{                dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);            }        }    }    return dp[text1.length][text2.length];};\n714.买卖股票的最佳时机含手续费题目：\n给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n解析：\n\ndp\n\n定义状态 dp[i][0]表示第 iii 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。\ndp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]−fee}dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}\n/** * @param {number[]} prices * @param {number} fee * @return {number} */var maxProfit = function (prices, fee) {    let dp = new Array(prices.length).fill(0).map(() =&gt; new Array(2).fill(0));    dp[0][0] = 0;    dp[0][1] = -prices[0];    for (let i = 1; i &lt; prices.length; i++) {        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    }    return dp[prices.length - 1][0];};//优化一下空间var maxProfit = function (prices, fee) {    [sell,buy]= [0, -prices[0]];    for (let i = 1; i &lt; prices.length; i++) {        [sell,buy] = [Math.max(sell, buy + prices[i] - fee),Math.max(buy, sell - prices[i])];    }    return sell;};\n\n贪心\n\n不关心买卖的具体时间，只讲求每天的净利润最大\nvar maxProfit = function(prices, fee) {    const n = prices.length;    // 记录买入最低价格（加了手续费）    let buy = prices[0] + fee;    let profit = 0;    for (let i = 1; i &lt; n; i++) {        //当前价格比之前买入时低，所以现在再买        if (prices[i] + fee &lt; buy) {            buy = prices[i] + fee;        } //当前价格比买入高，先假装卖掉        else if (prices[i] &gt; buy) {            profit += prices[i] - buy;            buy = prices[i];        }        //其余情况不动    }    return profit;};\n2542.最大子序列的分数题目：\n给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两者长度都是 n ，再给你一个正整数 k 。你必须从 nums1 中选一个长度为 k 的 子序列 对应的下标。对于选择的下标 i_0 ，i_1 ，…， i_{k - 1} ，你的 分数 定义如下：nums1 中下标对应元素求和，乘以 nums2 中下标对应元素的 最小值 。用公式表示： 。请你返回 最大 可能的分数。一个数组的 子序列 下标是集合 {0, 1, …, n-1} 中删除若干元素得到的剩余集合，也可以不删除任何元素。\n\n解析：\n这题关键在怎么遍历两个数组可以保证遍历次数最少，这里先把要算最小值的nums2降序排列，保证nums2是从大到小一个一个遍历的，然后对nums1使用最小堆，保证每一次遍历sum一定会比之前的sum更大\n/** * @param {number[]} nums1 * @param {number[]} nums2 * @param {number} k * @return {number} */var maxScore = function(nums1, nums2, k) {    const n = nums1.length;    const ids = [...Array(n).keys()];    // 对下标排序，不影响原数组的顺序    //这里先把nums2从大到小排序，选取前k个，这时的nums2[ids[k-1]]就是前k个中最小的    ids.sort((i, j) =&gt; nums2[j] - nums2[i]);    const pq = new MinPriorityQueue();    let sum = 0;    //这里按照nums2的下标计算nums1对应的和，并把nums1对应下标的每个元素入最小堆    for (let i = 0; i &lt; k; i++) {        sum += nums1[ids[i]];        pq.enqueue(nums1[ids[i]]);    }    //对下标数组k之后进行遍历，如果后面下标对应的nums1的值大于当前和的最小堆的最小值，就替换最小值，比较更改后的乘积是否会更大    let ans = sum * nums2[ids[k - 1]];    for (let i = k; i &lt; n; i++) {        const x = nums1[ids[i]];        if (x &gt; pq.front().element) {            sum += x - pq.dequeue().element;            pq.enqueue(x);            ans = Math.max(ans, sum * nums2[ids[i]]);        }    }    return ans;};\n2462.雇佣k位工人的总代价题目：\n给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。比方说，costs = [3,2,7,7,1,2] 且 candidates = 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。一位工人只能被选择一次。返回雇佣恰好 k 位工人的总代价。\n\n解析：\n注意一下这个candidates是指从前数candidates个元素和从后数candidates个元素找这两个里面的最小值，所以用两个最小堆\n/** * @param {number[]} costs * @param {number} k * @param {number} candidates * @return {number} */var totalCost = function(costs, k, candidates) {    let left = new MinPriorityQueue();    let right = new MinPriorityQueue();    let i = 0;    let j = costs.length - 1;    let ans = 0;    while (k--) {        while (i &lt;= j &amp;&amp; left.size() &lt; candidates) {            left.enqueue(costs[i++]);        }        while (i &lt;= j &amp;&amp; right.size() &lt; candidates) {            right.enqueue(costs[j--]);        }        let min1 = left.size() &gt; 0 ? left.front().element : Infinity;        let min2 = right.size() &gt; 0 ? right.front().element : Infinity;        if (min1 &lt;= min2) {            ans += left.dequeue().element;        } else {            ans += right.dequeue().element;        }    }    return ans;};\n\n力扣75堂堂完结","categories":["技术学习","算法"],"tags":["前端","算法"]},{"title":"美团机考","url":"/2024/05/11/%E7%BE%8E%E5%9B%A2%E6%9C%BA%E8%80%83/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e60582621976402c123a86c8b8920fbcfd0e552e9857267c16c3ad8a88ec3da0d5371d8701f8c1daab3d4a97d5406ccb923e8ffe6c9224451977a33ad2cb1e3fde1d315ae535cfe28f83df1490bae67fcd91a039843522963d3fe374694e05364b926e5a3cd34da15f64284cfddeea164f6ec898df4aece71b44ef51e17d67f251ac231fae0981d8230eada98aa11aadfd154bce8fba2b0a2e4a6cac5bffd8cb6e935de02a78f369706b119ac3eed09c99c999b328b2aa4b43b54ef566dae3b1ca6b11d67e38b99a0419fd897b1a49a7bb3d8a5a66f4ceba198f777354fad6622b2130fa82a57b4446a712f2439776e9895b1cae3e576462f9c04bf2f21411da3c009ffc006423751513820fb471e654d71cf98f3af5e649d576dabd97c0e1ddbb7b3e822726b0ff6d75c1864cdca2d8aedbfcb34f5f00cf816569f0dcc734c3b6647cc34b45c286559b22aa7cf1b91451c55dd61e4d24e975b18907d057cd6af9eb5379c78760abe66a059b588420778e66779505f2a705355b841706865aa31b37144ce4868fce2f4f63188a0af2ec17b6a2e742ae7aeb47a0c8fec83d080911abf375cf581f91b3e08194acbeade098f19dfb3d0bbdb5c9e0c0b47fe0f5ec06d8921e1d9ad73d298f90d0ce48e11e7b41263337e2736d427207d2dfbcac4197917f5e040cb9f60620dc9749e57ba4ef117794e40f7b090cf11415f7cc8188bef1df30fafa53ed2f612708f2722849d0c09cb3f6218ca391f5b144c950fc16100e855afaa545d1c2a3723d7d0d79c4238608a1ba3f9447332a8a56b9a7397e3b0ab1e40c75afb8d939a1bd76303a49e8f580b167105815ca33d730aea492a9e622a7766fad0c25159f9d670284e8937cc1c84e3ce5d64b4c3057ac952fd6e3e482e58ab21b6fcda709f7148b49ada44afe99eee612c4ca075f9ae04af443460642537cd204c854e92e5ad6c7b81a30fafe7094703897393a6c64c10174ea55354781a6170de0ca88acb5acf9c2cf3e9ad8954c9ccc1275fc19d5e6f61a75f71b8f418cebab6c181b0b1e86ec70ddcc665321bfcfdefa0bedc1c79c8da9e68733a36352e3259cac65f1e20ed3b42e08be333adbf2abaa6bd97ec2bb70c53fae6344358d0f72789a8f3c1e8f33faefaf3c7b07bdc6ee00068117c3e413576ed28d87673cd5fe9ce7dba39ad12741e9e5ff8b3eb99b70c1d609c9fd55743937466b40f1d515d880c2dbfeb2d51b6360a5f2126496c9b9991a8b86e3b11e057a3640a43e3cdd3d83259f9a82bf6c444b5b9e72a8d6a255c1865d9faccd68ff8fe77fdec463bab777a8d7bc1b91ee6143dadae8adacdef4a780a1cdd1af8ebfcb6f74b0ef32130b96ef1bdbf88b0463903fc26d98cc4755b9bc98ca8a9b2819570c628c760834c2487c3113235f3c9210942739f628a7b0e971b161a7ae9ca7ce5033a050240189698f951fa9cc38c248c7363f20bd838cdab449f2a177c358b716fa0d9d08cf9b0c79ddff4eb0264073a6c720304b90b2a1b33ef75f3bf48b7f14ac0958b8388317d6883bced30d1873d2cb9849ee9f7c956675e7e286ff4da14cda4e82ba13d21a112efe2b2b16e8016f9859936fa32cc2a798b32fdca23b67b9f5cb66821784d4b4d081c4684f2243120aac9f55982305a1078f84fecdd55d7895509e27769e7ec5b1aabb2c97266cd159c451c97d61983d2e3bd95a1a3a97ac3c35b594d75e0af6f5ded8e48fc22953aeb25e8370be6509fce3a48e3dde8f98340b2f6639336e2672b3e26ebefd614b9a8e36c6b28d1ce5e38087d9f2d248afb2b5795e85fa446dd0999eda28748a05c49032445db4b5a777aa4f9c21fedbb9292c3123d5ebcc3976d5fc978ca4cbeb48511580be6447c828e4f1f860aef54abc320ff40c907001eb4d5437b4801ef638037ed59095499564ec85f1022fbf19d7da4b694d1d0be51bdbb0b678c29d6231314469fbce3d93a9fc484285c6a006d9733e4a70c6dd7b2e7452a11442e53204c229ec6b281123be8bc7e7aedc5f3f30bb76334de391291993f4c86210aa4471ba441eb0218b032d8ddee356b6a40aa1a4c6e2e6928136a92126e7fb377e3fcd005f74d2\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["机考","美团"]},{"title":"李白，与大众想象相差不止三万里","url":"/2023/07/11/%E9%95%BF%E5%AE%89%E4%B8%89%E4%B8%87%E9%87%8C/","content":"首发知乎\n也是搬运的去年的影评，哈哈哈，今年还没遇到值得写的长影评\n因为这部电影李白的形象很有争议，我在这里补充说明一下我的看法。我一直主张作品和人需要分开，不能因为一个人的作品足够优秀就认为其人也如作品一样优秀。这个世上有很多天才，但很少有全才。李白的诗歌成就让他名垂青史，但也必须承认除去诗歌才华的他只是一个普通人，也会有世俗的行为和坎坷的经历。\n你可以只爱李白的诗歌，或者能够接受真实李白不完美的一面而爱李白这个人，但不要只读了部分作品就来神化李白的一切行为，这样和某些饭圈粉丝的极端追星行为有什么区别。\n&nbsp;\n\n&nbsp;\n看完长安三万里，火速来影评。\n这部电影并不是传统的商业片，而更像是一部浓缩唐史的纪录片。我之前一直觉得追光只重视画面视效，而不重视剧本。这一次直接选择改编历史，算是弥补了一直以来的剧本缺陷。在视效方面将不少经典诗词用瑰丽的画面呈现了出来，当那些历史中的人物一个一个走出书本，心中还是很感慨。我看完的后想到了一句话你年少读过的诗词，在未来才会产生共鸣。追光这次的建模也更贴近现实中的普通人以及史书画像的形象，没有像杨戬那样精致帅气的模型，大概是想表达希望观众更注重剧情本身，多增加一些历史感（不过这样会少一大批冲着颜值看电影的观众）。\n首先谈谈关键人物李白。我中学时非常喜欢李白的诗词，在我心中他一直是丰神俊逸、放浪形骸、自信豁达的形象，但是在我真的去了解历史上的李白之后，他的形象瞬间崩塌，从云游四海浪漫随性的谪仙人落到了恃才傲物却无政治才能的失意之人。你会发现李白两次婚姻都是入赘，风流韵事颇多，用现代思维来看不仅吃软饭还是渣男；他虽然多次在诗歌中抒发政治理想，但更多只是空有辞藻而无实用；他留下过“安能摧眉折腰事权贵”的豪言壮语，但也给杨贵妃写过极尽谄媚的清平调……说到底真实的他入世仕途不顺，出世也得道未果。但是这些让李白从一个虚幻飘渺的诗仙具象化成了更真实更鲜活的人，离我们这些普通人更近。当了解了真实的李白，再看他的诗词反而让我能走进李白的内心，读诗时也不再只停留在浪漫的意境和瑰丽的想象，能够窥见背后的深意，读懂那个“痛饮狂歌空度日，飞扬跋扈为谁雄”的李白。&nbsp;\n长安三万里给我的感觉也类似如此，他从高适的视角出发，塑造了一个既洒脱不羁才华横溢又失意落魄的形象，矛盾但却很立体丰满。我知道这部电影肯定会打破很多人心中李白的形象，但我想说一方面真实的李白确实如此，一方面电影中是描绘相对平庸但勤奋刻苦的高适心中的李白形象，高适内心对李白的部分个性和行为其实不太认可，在他的回忆中自然会对李白一些行为呈现出否定态度，这也会间接影响到观众对于李白的看法。然后历史上的高适一直因为没有救好友李白遭人诟病，电影中结尾有借他人之口试图为高适解释，不过高适也没回应，这一点改编见仁见智。\n在电影中，导演有意将李白作为大唐的一个化身，在李白身上浓缩了一部由盛转衰的厚重唐史。青年和中年李白身负才气恣意欢愉，正如盛唐，但当繁华转瞬而逝，安史之乱让大厦一夜倾塌，老年李白也意气不再令人惋惜。我个人认为这部分拍的还不错，能够让观众身临其境体会历史风云变幻。&nbsp;\n不论这部电影是还原历史也好，亦或是改编人物也罢，后世的评价都不会影响李白半分。李白无需洗白，亦不会为人抹黑，他有自己鲜活跌宕的人生和纵横后世的才华，这是属于他的万里长安。\n虽然电影会偏历史纪录片向，但其实多数诗句都是义务教育阶段都接触过的，当银幕上出现一首首诗篇时，被牵动的不仅是中学阶段语文课的回忆，更是每个华夏儿女骨子里文化传承的底蕴，非常推荐大家去看看。\n最后，关于李白最好的形象概括，我想起了在中学期间就很喜欢的余光中的诗《寻李白》，我至今都认为是对李白形象最好的描述。\n&nbsp;\n寻李白\n——痛饮狂歌空度日 飞扬跋扈为谁雄\n余光中\n那一双傲慢的靴子至今还落在\n高力士羞愤的手里，人却不见了\n把满地的难民和伤兵\n把胡马和羌笛交践的节奏\n留给杜二去细细的苦吟\n自从那年贺知章眼花了\n认你做谪仙，便更加佯狂\n用一只中了魔咒的小酒壶\n把自己藏起来，连太太也寻不到你\n怨长安城小而壶中天长\n在所有的诗里你都预言\n会突然水遁，或许就在明天\n只扁舟破浪，乱发当风\n——而今，果然你失了踪\n树敌如林，世人皆欲杀\n肝硬化怎杀得死你\n酒入豪肠，七分酿成了月光\n余下的三分啸成剑气\n绣口一吐，就半个盛唐\n从开元到天宝，从洛阳到咸阳\n冠盖满途车骑的嚣闹\n不及千年后你的一首\n水晶绝句轻叩我额头\n当地一弹挑起的回音\n一贬世上已经够落魄\n再放夜郎毋乃太难堪\n至今成谜是你的籍贯\n陇西或山东，青莲乡或碎叶城\n不如归去归哪个故乡\n凡你醉处，你说过，皆非他乡\n失踪，是天才唯一的下场\n身后事，究竟你遁向何处\n猿啼不住，杜二也苦劝你不住\n一回头囚窗下竟已白头\n七仙、五友，都救不了你了\n匡山给雾锁了，无路可入\n仍炉火未纯青，就半粒丹砂\n怎追蹑葛洪袖里的流霞\n樽中月影，或许那才是你故乡\n常得你一生痴痴地仰望\n而无论出门向东哭，向西哭\n长安却早已陷落\n这二十四万里的归程\n也不必惊动大鹏了，也无须招鹤\n只消把酒杯向半空一扔\n便旋成一只霍霍的飞碟\n诡绿的闪光愈转愈快\n接你回传说里去\n","categories":["影评"],"tags":["影评"]},{"title":"计算机网络","url":"/2024/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"","categories":["技术学习","八股文"],"tags":["计算机网络"]},{"title":"生活不能没有音乐","url":"/2024/03/22/%E9%9F%B3%E4%B9%90/","content":"3月3月专辑\n\n3月古风单曲\n\n\n3月R&amp;B单曲\n\n\n3月日语单曲\n\n4月4月专辑很喜欢DT和Ashlee的三张蓝色专辑，纯正的神仙R&amp;B三部曲\n\n\n\n\n\n","categories":["音乐"],"tags":["音乐"]},{"title":"阿里国际","url":"/2024/05/15/%E9%98%BF%E9%87%8C%E5%9B%BD%E9%99%85/","content":"\n  e9a1473e1e9e93bf613021d6e638079f266fc00226326bbe39f2984117491280d5856d4061014235454e7b3b0363896f8bdb3a6c6bd12eda2c0c3a0d59ca3a6f4fd9bc16918d2cfe74fb3ad693c569b3632ac2e702f40b515e5ce2cc66be5050a56c56f2ed8f485e887f82848b5900e5743963be91f10229372f7955fd2d8298b596653a8c020a88dce0e55f8219b6eaf999af47e9a28d6fae1c390be892edb5de38b99895b722d1a0252b645bea7f786f8e6533fa84a7cf0e7046405a5e0400df60e9e11cef3f3c6fc177f720bd4d7c995183460e52b8536594f0f4af34d852fe20f8751e0f0eba274ba96941445aafbe34f823f55ba912669d322046e38ead3e7fd9a781a7042fe492ac29fd521d280e355e149868e8f8f9e02a2edb923b1ad6b52a0f55fda27588770383a51dc2e3a608b88bd848e70c8817de16c4e38f7c9635184c79e0de0e7b63eae02b58f9b7be75bf18f21ce6a9d340e72ac6f8577e370acaefec0efd92248f1c09194222fb033ad00eeacaa58e9356e9e60582621976402c123a86c8b8920fbcfd0e552e9818f351bc4602f7412cd5bcd13dc2eacfb4e13a3cfce4452bb5e6f0b6c72fa5b1d1ce5ce76cbc92ef24410c6f744cea8a54df9788478c9e51b83dd1e5927109875a49d6eadaa4d336040413c398e9ee7b16ef91eef7ed9341c7e03ea64d96296eeba41a9e9a9b3169a75516feab4035cd85cae7c052e5dc3478e73218525614993546ccfcf4a16d8751f67e9e7ad7aa31259f3695a28dca93c6093142c591db32c9c4318f54e88f6b31f164f98dfda83ed9c471ff7be3c6fe01040e3dea88bf4f23f786808dbdcaa605038e7f1ceb7eda2932e2adc68216333b52ce003dce4e91f5ddbb9fc7b731448632250a534b20b8c174669cca269e972ce8d7ec2b6d46485aef2a74783e2937f226dfe2c0bac6f16c6e9c5477cdc1e8b1a764d47c77324a00998a4254df903ec1453739975f33d7f824abb6057b4ff0f8716bcb193483b3348b0c311891c72155f8a5ebe6f7a62fa089cce37c1129a5037e43261dbb129d2ef5a5ca909b63dfb0fc6432da4da95c540b94feb250eefd43467e4b08fbb08d76909598c4f21e25caf644cf806e0c45fc28391307f25b39616735b9125b7562a7fd2b86b4ef0f34929addfda91d6be861648887bd634919338f94b008e3578c508f41df8808427c6ff05be2ccaefc880b928f81c823bf5c7413b84b563611ffd04ec101a33dd2033ccdfe336e7cbc81e8c3c8dd99a268bd3407bb67c0a20661b59056210386f2fa19b6a836519faf3ed2c329c7575b9eafd5c08290fa00d16c3460c4cc0b0881a965eaa7f0a122010b95633b4f1d2da64a777967fe4ad8b27864ccb2e1807a9a85c4f39994b54a140e6419e4f096a74e4c6461c8c60f3d855513e5a7daeacf29fc2aa37e23278a6dce3c85667f9d10cf730a4135867da411a2790163bf14de45c54d2a0ad24ad535f8cd2969c93e5284442fd09c53c2f8b1468f7eb0959cf53cc1cc7763ef9b6905085a83a79bf9a2b6d8d3de084fb9fa719981d2b7944c8213ef8dc20528deadc583b7b529d6fc1e5e14a6e619dc20486482e3035e25de7a8bfe28baece2f3f59feefbc23438b20cc4c37f33a2aadff92a1e3113be5970c27ed499fc089a3ad17b0b084a03f58a08ba631f0e6d3dfa8fd824e3687019b22f1e52f2ebc98caa9ff49544427ed994f7ca598b4ffcd7e4b63f8255bdefd5755dc3ba045fde00104c3cd94f7874cb9c090f47878a867577af7e6ca1c994c991b8189ae8bda055fe497fa8b252de93bf0200ef6d7a51857f60151ac3020bb40bc8a45fb1c58283af9b691e473269aed6a4cf0b5f34396d9f1683dc9eef5524d0f651f64b19d43ff53b5d55b80c7193971a8d4861fedc8e6c9116d53d77e9972a9a88d2aba2579c965b85d57120ee902c57865375d4a3d30d4f2ac00d1463adcf6da601d52e4eb077a8e47f044895e22456d68c098306f7fbff7c761e5d36025e24c8b951b669fe73e85f652b4ef17c0eb4ef4b1a5d99064c15a6c7c5099d89136d32676fcefa09295e1eabc398d6ed8b4b90ffd21e5f77272d886ee2f41a06166b91b5e8658fe5bcd23f0f4c5c91d998839ab504a89acc14902d59bd4e3431399d3a54ad83e39f11262b40137b0323ec31245c342803b3f486bb2943f0215033065169610b9374d9f66c6583fa92f6ca4e918a0e16974fdb543649b76ba26545188542049a4fa42e70fad26a01cdc2a7a42330f913d64dfb0ec8802ee1c3e8b9d7f5dbd520b9c6b570c313c0af907bd3c8425f521247366a436817129c94a00201131c876f0abfce8919041a8dc02c2ef352e91bfd75924117e73519a908be7d95b129ed3f95b8f96d77f008e419173ef22cd5fe0a4aad8e47060b9f362151a522eaa9f6ae7194ab2dfe28410aeda96abd46ba428ec537005d0525be0bde39a8f54ce3db34b7e1c41e197a6a82f513f09469bc752585ca065b0f55c37f06d6f04aa84ea0cd510b446a689247827c8b8aa77244b93c3fd7c36bc94d16473ee84f92f363909b9fb8f195f12d32c04feb9a22aab0be5efd25102dfd8f7d251a75da29a63738369a44f5fde4b306f38dd1720175bc3832c66c07354908e3e0ddac405b900620b4fddee3ae0b4c9eb5e443586b7e86470712eadc9aaf4ad52bb9f21bb98ed7de87e321fbad7c55e26f33e3529b5bb03c2fee8066bdf9a566ae63b39ccf957a2e4c5a51307e53a6b0b637d709e8dacf7370dee69d6eb3d2ef12adde6af101c0245d9f063f7ffd6f8734294c9d6e091e07aba9d7ba7c6c043430e6337c395f6f2680bf718953ea324b6bd968ed7974eca4c6507d75ffb6bb3cb492390179791965cccf61356e6121d2f9c149911005b837ebeda02389a0a94cc9030356e1c6758abdac1a1055d26a17b6a24d2ab52d5e22946602d1a1b9ab9cfba7353c1ce22ca2da823ea040b209e4b8e03156c2669acde5461592429a42e7043172a202360d3503831ef561acc8efb35df34e118cdc086233987f7c9d439dcaf124326574f61cc6abc88e78a25db2bbbdd7f5fcb5d40548526e128c6dfc6820fe85a9493ba62ac1a8eab91d3d6b862d2598bdd0196a2db1d142610e1f3534da5951e499fddeb6664dc68e70b52ec5c35176cbc9e60fa60d23cb5e996ea0dea63f3b3b790b7cfc4154209354a412c39c6b53810073e8cae87a5610e1caa7d478a6b8c2616af202d6ba4b6ee1eff26cbfa503b2bc4cf4aac9d87ef59b76e291e0ca8349bc66ccaea2eef6464162ed\n  \n    \n      \n      \n        您好，查看本文需要密码，请联系博主获取 (tips:博主本人学校名称缩写)\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["面试辛酸史"],"tags":["前端","面试","阿里国际"]}]