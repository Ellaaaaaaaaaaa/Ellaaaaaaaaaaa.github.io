[{"title":"JavaScript学习笔记","url":"/2024/03/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"主要是介绍了ES5的语法，后面补充了ES6的不同之处\n\n\nJavaScript三部分核心(ECMAScript)语言的基本组成部分文档对象模型(DOM)把页面映射成多层节点结构 XML 扩展HTML提供访问和操作网页内容的方法和接口浏览器对象模型(BOM)与浏览器交互的方法和接口  \n&lt; script&gt;async:下载脚本，外部脚本文件有效，不保证执行顺序charset:src属性指定的字符集defer:延迟到文档完全被解析后执行，外部脚本文件有效src:包含执行代码的外部文件type:脚本语言内容类型，默认值text&#x2F;javascript  \n放在HTML文件底部直接嵌入或包含外部文件直接嵌入要指定type属性&lt;script&gt; &lt;&#x2F;script&gt; 一对出现，函数内部出现记得用转义符号&lt;/script&gt;包含外部文件要指定src属性，&lt;script&gt; &lt;&#x2F;script&gt;中不包含额外代码&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”a.js”&gt; &lt;&#x2F;script&gt;放在&lt;body&gt;元素中页面内容的后面  \n基本概念(只记录了一些跟我印象中不同的点)区分大小写var创建变量是局部变量，省略后是全局变量使用var和function声明的变量不可删除，因为被标记成不可配置了delete不能删除全局变量，但是可以删除window对象上定义的属性delete操作符跟直接释放内存无关，是断开引用间接完成的，对象的属性和数组成员才可以删除这样的删除仍然占据内存空间，要设置null才能释放\n\n数据类型\n\n\nUndefined声明未初始化typeof()\nNull\nBooleantrue false 字面值 全小写其他类型的空值、0、NaN、null、undefined转换后都是false\nNumberNaN Number() parseInt() parseFloat()\nString转义字符不可变toString()\nobjectnew 跟Java蛮像的P35一些函数\n\ntypeof 返回数据类型 object null注意返回\n\n操作符（意外跟C很像）一元操作符自增自减前置后置位操作符~非&amp;与|或^异或&gt;&gt;右移&lt;&lt;左移 &gt;&gt;&gt;无符号右移&#x3D;&#x3D;会强制转换 &#x3D;&#x3D;&#x3D;不会强制转换?:\n语句if do-while while for for-inlabel标识特定位置 break continue with设置作用域switch\n函数function 参数不限制个数和类型 通过argument对象访问元素参数传递都是值传递没有重载，后面覆盖\n引用instanceof\n作用域没有块级作用域，if for语句中初始化变量在语句执行完之后依旧存在于语句外部执行环境var是添加到最近的环境，没有就是添加到全局环境\n垃圾收集标记清除\n\n引用类型\nobject类型用new创建；对象字面量很像字典，都是花括号里属性名：属性值\n\nArray类型每一项可以保存任何类型的数据，动态调整数组大小Array(数字)表示数组项目数量Array(其他类型参数)创建包含那个值的只有一项的数组方括号[]索引isArray()toString() 每个值的字符串形式，以逗号分隔valueOf()join()分隔符字符串push() pop() stackshift()移除第一个 unshift()前端添加 list queuereverse()翻转sort()比较字符串 小心15&lt;5，从字符串上看，定义compare函数作为参数传入sort()concat() 拼接字符串和多个数组的每一项slice() 返回[开始索引，结束索引)中间的项，负数则用数组长度加上该数来确定位置splice()\n\n删除 第一项位置，删除项数\n插入 起始位置，删除项数，插入的项\n替换 起始位置，删除项数，插入的项\n\nindexOf() lastIndexOf()查找位置，没找到返回-1\n\n\n迭代方法every() some() filter() forEach() map()reduce() reduceRight()\n\nDate类型\n\nRegExp类型 每一次要创建新的实例g全局i不分大小写m多行exec()\n\nfunction类型function 函数名(参数){语句;}var 函数名&#x3D;function(参数){语句;};一个函数可以有多个名字没有重载arguments callee用于解除代码和函数名的耦合this 先局部再全局call() apply()基本包装类型Boolean Number String不能添加属性和方法charAt() charCodeAt() slice() substr() substring() indexOf() trim() toLowerCase() toUpperCase() match() search() replace() split() localeCompare() fromCharCode()\n\n\n全局对象URI编码方法eval() 解析器 接受要执行的JS字符串window对象Math对象\n面向对象对象有属性和方法使用Object.defineProperty()来修改属性特性\n\n数据属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nWritable能否修改属性值\nValue读写值\n\n\n访问器属性\nConfigurable能否修改或删除属性特性\nEnumerable能否for-in循环\nGet读取\nSet写入使用Object.defineProperties()定义多个属性\n\n\n\n工厂模式 在函数里面新创建一个对象构造函数模式 把函数当做构造函数，在外部直接new对象原型模式 一个函数有prototype属性，其他实例共享prototype里面的属性和函数，先找对象实例本身属性，再找原型对象的属性，实例和原型之间的连接是指针每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针hasOwnProperty()inconstructor()可以随时为原型添加属性和方法，但不要重写构造函数和原型模式的组合动态原型模式 在构造函数里初始化原型函数寄生构造函数 要用new的工厂模式稳妥构造函数 不能用this\n实现继承 原型链搜索属性会沿着原型链往上通过原型链实现继承的时候，不能使用对象字面量创建原型方法，因为会重写原型链在每一个创建的子类对象上使用超类对象的call或者apply方法进行所有对象初始化寄生组合式继承是最完美的继承方式不必为指定子类型的原型而调用超类型的构造函数\n函数表达式\n函数声明:function 函数名(){}函数声明可以置于调用语句之后\n函数表达式:var 变量名&#x3D;function(){};此为匿名函数要先赋值才可以调用编写递归函数，函数内部用argument.callee代替函数名函数第一次调用创建一个执行环境和作用域链，并把作用域连赋值给一个特殊的内部属性scope，然后初始化活动对象，外部，外部的外部，知道作用域链终点全局执行环境\n\n闭包，在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域闭包结构：\n\n一个函数，里面有一些变量和另一个函数\n外部函数里面的函数使用了外部函数的变量\n外部函数最后把它里面的那个函数用return抛出去\n\n闭包作用：\n\n在函数外部可以读取函数内部的变量\n让这些变量的值始终保持在内存中\n\n闭包只能取得包含函数中任何变量的最后一个值解决方法是再嵌套一层函数，形成一个闭包注意this的指向问题，可能闭包函数是在window作用域下执行的，this就不是指向外部函数而是window内存泄漏问题，闭包引用外层对象，写一个变量保存对象副本，结束闭包后把对象置为null多次声明同一变量，会对后续声明视而不见在匿名函数中定义的任何变量都会在执行结束时被销毁(function(){作用域})\nBOM\nwindow对象全局作用域中声明的变量和函数收拾window对象的属性和方法尝试访问未声明的变量会抛出错误，但是可以查询window对象判断未声明的对象是否存在窗口关系和框架top对象指向最外层框架即浏览器窗口parent对象指向当前框架的直接上层框架没有框架的情况下parent&#x3D;top&#x3D;window窗口位置和大小moveTo(x,y)移动到实际位置moveBy(x,y)移动量resizeTo(x,y)设置大小resizeBy(x,y)新的和原来的差导航和打开窗口window.open()参数：URL，窗口目标，特性字符串，新页面是否取代浏览器中当前加载页的布尔值window.setTimeout()执行代码和等待时间clearTimeout()取消超时调用setInterval()间隔时间重复执行clearInterval()\n\nlocation对象既是window的属性也是document的属性location.search访问URL里面的内容location.assign()传递URLlocation.reload()无参重载&#x2F;有参服务器重载\n\nnavigatorpluginsregisterContentHandler()\n\nscreen对象\n\nhistory对象\n\n\nDOM把HTML或者XML文档描绘成多层节点结构\n\nNode类型nodeType, nodeName, nodeValue, childNodes, NodeList, ownerDocumentappendChild(), insertBefore(),replaceChild(), cloneNode()(注意区别这里深复制是复制节点和子节点树，浅复制是只复制节点本身), normalize()\nDocument类型window对象的一个属性，可以当做全局对象来访问documentElement指向&lt;html&gt;body指向&lt;body&gt;title, URL, domain, referrergetElementById()getElementByTagName()返回的是同一个tag集合HTMLCollection.namedItem()HTMLCollection.getElementByNamed()特殊集合P258write(), writeln(), open(), close()\nElementattributes属性 get set remove\n\nquerySelector()接受CSS选择符\nHTML5getElementByClassName()classList属性 add() contains() remove() toggle()document.activeElement focus()HTMLDocument属性readyStatecompatModeheadcharsetdata-自定义数据属性innerHTMLouterHTMLscrollIntoView()简单描述一下就是一棵DOM树有节点和元素，还有自己对应的属性，可以创建节点然后添加到树里面，还可以直接设置元素的style属性可以直接查询包含某些类或者ID的元素遍历NodeIteratorTreeWalker\n事件ES6语法\n变量声明let const var可以创建块作用域\n剩余……参数 动态参数…variable…数组 拆解数组\napply(this,array) call(this,arg)\n解构赋值左侧定义了要取出的值剩余属性位于末尾结束解构模式\n箭头函数去掉function，直接(参数)&#x3D;&gt;{}不能用作方法function定义的函数this随上下文变化而变化箭头函数this始终指向定义函数的环境\npromisePromise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数，接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。then：用于处理 Promise 成功状态的回调函数。catch：用于处理 Promise 失败状态的回调函数。finally：无论 Promise 是成功还是失败，都会执行的回调函数。\nfor in和 for of数组遍历用for of，对象遍历用for infor…in 语句以任意顺序迭代对象的可枚举属性。for…of 语句遍历可迭代对象定义要迭代的数据。\n\n运行时 runtimeJavaScript是一门解释执行语言。这意味着源代码在执行前，无需编译为二进制文件。JavaScript引擎以一段程序的形式存在，负责将源代码翻译为机器码，并通过 CPU来执行翻译后的机器码\n对比Java是先编译后执行的，能够将代码语法错误立即反馈给你。在JavaScript 中，只有当引擎尝试执行到有问题的那行代码时，才知道哪里出了问题。\n在 Web 开发中，引擎并不会被开发者直接使用到。JavaScript 引擎是运行在一个环境中的，这个环境提供了代码在执行时能够利用的附加特性。\n对比Java，Java 运行时环境（JRE）提供了访问所支持类库的方式，并且扮演了程序与操作系统之间的桥梁的角色。\nJavaScript 运行时是指 JavaScript 代码执行的环境。Web 浏览器和 Node.js 是两种常见的 JavaScript 运行环境。\n\nweb浏览器\n\nNode.js\n\n\n事件循环机制JavaScript 代码是在单一线程中执行的，但是JavaScript 运行时是存在线程池的\nJavaScript 代码分为立即调用代码和事件回调代码\n事件循环机制是处理回调的机制。创建回调时，通常把它与一个特定事件关联起来。当特定事件发生时，运行时环境会将相关回调推入一个所谓的事件处理队列。事件循环机制会持续监控队列，并且按照先来后到的顺序执行其中的回调。\nv8https://v8.js.cn/docs/\n","categories":["技术学习"],"tags":["前端","JavaScript","ES6"]},{"title":"LearningNotes","url":"/2024/03/08/LearningNotes/","content":"数据结构数据结构笔记\n","categories":["大学笔记"],"tags":["学习"]},{"title":"二战腾讯","url":"/2024/03/07/%E4%BA%8C%E6%88%98%E8%85%BE%E8%AE%AF/","content":"无笔试，面试初试部门：技术架构团队(WXG)形式：视频时长：一个半小时时间：2024&#x2F;3&#x2F;8 10:00\n内容回忆\n问了一下项目经历\n 我投的是前端岗位，然后揪着我的后端项目问了快20min，我真的忘了我那个后端做的是什么了(感觉越讲越乱，有点崩溃)，我发现面试都喜欢问登录和注册问题\n 后续面试前还是要把自己所有项目都过一遍，讲清楚业务场景，功能逻辑以及技术栈的使用\n\nJavaScript\n 现在有点后悔，当时JavaScript ES5的语法书只看到了第十三章，只看了DOM和BOM，后面的就没看了，然后八股文也还没来得及看完，面试的时候很多都不会答(叹气)\n 这里只能先记录一下子问到过的点，我之后重新彻底学一遍\n 事件循环、runtime、异步(setTimeout、setInterval、promise、async&#x2F;await的区别)、JS底层逻辑、js和浏览器、内存泄露、跨域问题、查错调试、原型链\n\nVue.js\n 一来先问我为什么要学习vue框架以及怎么学习vue的，项目中遇到的一个难题以及如何解决\n 这里只能先记录一下子问到过的点，我之后重新彻底学一遍\n vue2和vue3的优劣(选项式和组合式API)、vue3的响应式实现、reactive和ref、跨域问题\n\n算法题\n 我最怕的事情还是发生了，算法题刚刚开始练习，js用的都不太顺手，一上来还要手撕代码，我以为手撕完就结束了，结果还要我自己讲解算法逻辑，分析时间复杂度和空间复杂度，看着我写的稀烂的代码，我讲的巨尴尬\n 题目分为两种，一种是 纯算法，一种是 实现封装函数功能\n 今天一类题是解决配对问题，我曾经好像一年前力扣刷过类似的，但是忘记解法了，当时用的还是C++写的，转换成JS逻辑反应了半天，等我去力扣找一下重新做一下\n 二类题是实现String里面indexOf方法，Array里面的reduce方法，Function里面的bind方法。我写倒是没问题，只是代码风格很偏Java和C++，被评价逻辑是对的，但是不符合语言规范，这里主要是怎么用原型链调用自身我真忘了，写不出来了\n\nbind方法 调用方法查看https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind 讲的蛮抽象的，简单讲就是修改this对象的指向以及传递参数 几个参考的文章 https://www.cnblogs.com/echolun/p/12178655.html https://juejin.cn/post/7207587475169476667\n\nreduce方法 调用方法参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce 参数如下： reduce(callbackFn, initialValue) callbackFn(accumulator,currentValue,currentIndex,array) 实现参考https://zhuanlan.zhihu.com/p/356678016\n  Array.prototype.myReduce = function(reducer, initialValue) &#123;const hasInitial = arguments.length &gt; 1;let ret = hasInitial ? initialValue : this[0];for (let i = hasInitial ? 0 : 1; i &lt; this.length; i++) &#123;    ret = reducer.call(undefined, ret, this[i], i, this);&#125;return ret;&#125;\n\n 等我把js再学得透彻点后就去看v8源码，那个是c++写的JavaScript引擎底层逻辑，可以看看一些内置对象的实现\n\n\n反思整场面试长达一个半小时，两个面试官轮流面试我，我也是第一次参加这种技术面试，有点赶鸭子上架，JS语法、Vue语法还有算法都没准备好，加上面试前一天晚上临时熬到三点，恶补算法，看来用处不大, 算法还是要一步一步稳扎稳打的来\nJS和vue的基础语法是不可能考的，问的都是比较难的的点，我也知道这些是重要考点但还没来得及复习到或者没理解透(悲)，所以还是要 重新系统的过一遍，把重难点彻底掌握倒背如流\n后期还是要整一下自己的 前端项目，不然我的简历上只能放后端项目，还要被揪着问后端问题\n这里放一个本次面试涉及到的知识点汇总，需要重新学过\n 事件循环\n runtime\n 异步(setTimeout、setInterval、promise、async&#x2F;await的区别)\n JS底层逻辑\n js和浏览器\n 内存泄露\n 跨域问题\n 查错调试\n 原型链\n vue2和vue3的优劣(选项式和组合式API)\n vue3的响应式实现\n reactive和ref\n 跨域问题\n\n","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"vue学习笔记","url":"/2024/03/04/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"这份笔记主要记录的是vue2和补充vue3的语法\n\n\n看了一下这个vue2全家桶列举挺完整全面的https://blog.csdn.net/qq_44663761/article/details/122328822?spm=1001.2101.3001.6650.16&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-16-122328822-blog-135767247.235%5Ev43%5Econtrol&amp;utm_relevant_index=17\nvue3的补充更新语法https://24kcs.github.io/vue3_study/chapter4/01_Composition%20API_%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86.html\nvue3的关键在于理解Composition (组合) API和setup的使用\nvue基本语法v-for绑定迭代v-on绑定事件，简写形式”@”v-model绑定数据\n&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt;    &lt;button v-on:click=&quot;handleBtnClick&quot;&gt;提交&lt;/button&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;var app=new Vue(&#123;        el:&#x27;#app&#x27;,        data:&#123;            list:[&#x27;first&#x27;,&#x27;second&#x27;],            inputValue:&#x27;&#x27;        &#125;,        methods:&#123;            handleBtnClick:function()&#123;                this.list.push(this.inputValue)                this.inputValue=&#x27;&#x27;            &#125;        &#125;    &#125;)\n\nv-bind绑定对象，简写形式”:”component全局组件\n&lt;todo-item v-bind:content=&quot;item&quot; v-for=&quot;item in list&quot;&gt;&lt;/todo-item&gt;Vue.component(&quot;TodoItem&quot;, &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;);\n\n局部组件\nvar TodoItem = &#123;    props: [&quot;content&quot;],    template: &quot;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [&quot;first&quot;, &quot;second&quot;],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,    &#125;,  &#125;);\n\n父子组件传值父组件v-bind的格式向子组件传递，然后props里接收子组件$emit向上一层触发事件，父组件监听获取\n&lt;todo-item          v-bind:content=&quot;item&quot;          v-bind:index=&quot;index&quot;          v-for=&quot;(item, index) in list&quot;          @delete=&quot;handleItemDelete&quot;        &gt;        &lt;/todo-item&gt;var TodoItem = &#123;    props: [&#x27;content&#x27;, &#x27;index&#x27;],    template: &quot;&lt;li @click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&quot;,    methods: &#123;      handleItemClick: function () &#123;        this.$emit(&quot;delete&quot;, this.index);      &#125;,    &#125;,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      TodoItem: TodoItem,    &#125;,    data: &#123;      list: [],      inputValue: &quot;&quot;,    &#125;,    methods: &#123;      handleBtnClick: function () &#123;        this.list.push(this.inputValue);        this.inputValue = &quot;&quot;;      &#125;,      handleItemDelete: function (index) &#123;        this.list.splice(index, 1);      &#125;,    &#125;,  &#125;);      \n\n生命周期函数是指vue实例在某一个时间点会自动执行的函数图里是vue2的，vue3在命名上多了on和setup2.x 版本生命周期相对应的组合式 APIbeforeCreate -&gt; 使用 setup()created -&gt; 使用 setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured  \ntemplate插值表达式用两个大括号\n&lt;div v-text=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出字符串&lt;div v-html=&quot;name+&#x27; abc&#x27;&quot;&gt;&lt;/div&gt; 输出解析成html格式的字符串&lt;div&gt;&#123;&#123;name+&#x27; abc&#x27;&#125;&#125;&lt;/div&gt; 输出字符串var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      name: &quot;&lt;h1&gt;ella&lt;/h1&gt;&quot;,    &#125;,      &#125;);\n\ncomputed属性会有缓存，methods没有缓存性能较差watch监听变化也有缓存\n&lt;div&gt;    &#123;&#123;fullName&#125;&#125;    &#123;&#123;age&#125;&#125;&lt;/div&gt; var app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      firstName:&quot;Ella&quot;,      lastName:&quot;L&quot;,      age:20    &#125;,    computed:&#123;        fullName:function()&#123;            return this.firstName+&quot; &quot;+this.lastName        &#125;    &#125;,    watch:&#123;        firstName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,        lastName:function()&#123;            this.fullName=this.firstName+&quot; &quot;+this.lastName        &#125;,            &#125;,  &#125;);\n\nset和get设置方法\ncomputed: &#123;      fullName: &#123;        get: function () &#123;          return this.firstName + &quot; &quot; + this.lastName;        &#125;,        set:function(value)&#123;            var arr=value.split(&quot; &quot;);            this.firstName=arr[0];            this.lastName=arr[1];        &#125;      &#125;,    &#125;,\n\n样式绑定.通过v-band绑定class或者style来实现可以绑定对象也可以是数组\n&lt;style&gt;    .activated&#123;        color: aquamarine;    &#125;&lt;/style&gt;&lt;div @click=&quot;handleDivClick&quot;     :class=&quot;&#123;activated:isActivated&#125;&quot;    或者&quot;[activated]&quot;&gt;Ella&lt;/div&gt;methods: &#123;    handleDivClick:function()&#123;    this.isActivated=!this.isActivated;    或者this.activated=this.activated===&quot;activated&quot;?&quot;&quot;:&quot;activated&quot;;    &#125;&#125;,再或者&lt;div :style=&quot;styleObj&quot;&gt;hello world&lt;/div&gt;绑定style直接设置\n\n条件渲染v-if 对应的值为false直接在dom上不存在v-show 对应的值为false，dom上存在，不显示v-if可以写循环，必须连在一起\n&lt;div v-if=&quot;show===&#x27;a&#x27;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;show ===&#x27;b&#x27;&quot;&gt;B&lt;/div&gt;&lt;div v-else&gt;C&lt;/div&gt;\n\nkey值唯一可以保证不被复用在控制台直接用下标[]修改数组内容是不会改变页面显示要使用相应的修改函数才可以push pop shift unshift splice sort reverse或者直接改变数组引用对象也可以对象也可以循环，用set方法修改内容Vue.set(app.list,”number”,18)app.$set(app.list,”number”,18)Vue.set(target, key, val)\n&lt;div v-for=&quot;(item, index) of list&quot;           :key=&quot;item.id&quot;&gt;           &#123;&#123;item.text&#125;&#125;---&#123;&#123;index&#125;&#125;      &lt;/div&gt; 数组&lt;div v-for=&quot;(item, key) of list&quot;&gt;           &#123;&#123;item&#125;&#125;--&#123;&#123;key&#125;&#125;      &lt;/div&gt; 对象\n\n&lt;table&gt;里面有&lt;tbody&gt;里面有&lt;tr&gt;里面有&lt;td&gt;&lt;tbody&gt;里面不能直接用template，但是可以用is语句来指向template子组件ul,ol,select标签同理子组件里data必须是函数，不能是父组件中的对象，因为子组件都拥有独立数据不共享\n用ref来操作dom\n&lt;div  ref=&quot;hello&quot;             @click=&quot;handleClick&quot; &gt;hello world&lt;/div&gt;methods: &#123;      handleClick: function()&#123;        console.log(this.$refs.hello)；        console.log(this.$refs.hello.innerHTML)      &#125;    &#125;,\n\n\n父子组件传递父组件向子组件传数据，要在父组件components里先注册，然后标签里传参，子组件用props接收属性数据，且最好不要修改，克隆一个副本修改子组件向父组件传值调用$emit(方法名)，父组件在标签里用@监听方法然后触发事件子组件的\n&lt;div id=&quot;app&quot;&gt;      &lt;counter :count=&quot;0&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;注意在这里定义的事件是和父组件绑定的，要子组件$emit      &lt;counter :count=&quot;1&quot; @change=&quot;handelIncrease&quot;&gt;&lt;/counter&gt;      &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt;    &lt;/div&gt;var counter = &#123;    props: [&quot;count&quot;],    data: function () &#123;      return &#123;        number: this.count,      &#125;;    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&quot;,这里定义的事件才是子组件自定义事件，和子组件里面的method绑定    methods: &#123;      handleClick: function () &#123;        this.number++;        this.$emit(&quot;change&quot;, 1);      &#125;,    &#125;,  &#125;;  var vm = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      total: 1,    &#125;,    components: &#123;      counter: counter,    &#125;,    methods: &#123;      handelIncrease: function (step) &#123;        this.total += step;      &#125;,    &#125;,  &#125;);\n\n传参校验非props特性会显示在dom标签里，父组件传子组件不接收绑定原生事件只需要在事件后加上.native非父子组件传值bus 发布订阅模式 观察者模式\n&lt;div id=&quot;app&quot;&gt;      &lt;child content=&quot;ella&quot; &gt;&lt;/child&gt;      &lt;child content=&quot;syray&quot;&gt;&lt;/child&gt;    &lt;/div&gt;Vue.prototype.bus = new Vue();  Vue.component(&quot;child&quot;, &#123;    data:function()&#123;        return&#123;            selfContent:this.content        &#125;    &#125;,    props: &#123;      content: String,    &#125;,    template: &quot;&lt;div @click=&#x27;handleClick&#x27;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&quot;,    methods:&#123;        handleClick:function()&#123;            this.bus.$emit(&#x27;change&#x27;,this.selfContent)        &#125;    &#125;,    mounted:function()&#123;        var this_=this;        this.bus.$on(&#x27;change&#x27;,function(msg)&#123;            this_.selfContent=msg;        &#125;)    &#125;  &#125;);  var vm = new Vue(&#123;    el: &quot;#app&quot;,  &#125;);\n\n插槽\n&lt;div id=&quot;app&quot;&gt;      &lt;child&gt;        &lt;p slot=&quot;head&quot;&gt;ella1&lt;/p&gt;        &lt;p slot=&quot;foot&quot;&gt;ella2&lt;/p&gt;      &lt;/child&gt;    &lt;/div&gt; template: `&lt;div&gt;                    &lt;p&gt;hello&lt;/p&gt;                    &lt;slot name=&#x27;head&#x27;&gt;default&lt;/slot&gt;                    &lt;slot name=&#x27;foot&#x27;&gt;default&lt;/slot&gt;               &lt;/div&gt;`,\n\n\n动态组件v-once是创建一次就放入内存中，提高性能，不会反复创建\n&lt;div id=&quot;app&quot;&gt;      &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;      &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;  Vue.component(&#x27;child-one&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;one&lt;/div&gt;&#x27;  &#125;)  Vue.component(&#x27;child-two&#x27;,&#123;    template:&#x27;&lt;div v-once&gt;two&lt;/div&gt;&#x27;  &#125;)    var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        type:&#x27;child-one&#x27;    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.type=this.type===&#x27;child-one&#x27;?&#x27;child-two&#x27;:&#x27;child-one&#x27;;        &#125;    &#125;  &#125;);\n\nCSS动画效果是通过在某一时间上自动往标签上增加一些样式实现的\n//过渡效果&lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;&lt;/style&gt;//弹跳效果&lt;style&gt;        @keyframes bounce-in &#123;            0%&#123;                transform:scale(0);            &#125;            50%&#123;                transform:scale(1.5);            &#125;            100%&#123;                transform:scale(1);            &#125;        &#125;        .v-enter-active&#123;            transform-origin: left center;            animation: bounce-in 1s;        &#125;        .v-leave-active&#123;            transform-origin: left center;            animation: bounce-in 1s reverse;        &#125;&lt;/style&gt;&lt;transition&gt;    &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;&lt;/transition&gt;    &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;//配合使用css动画库&lt;link    rel=&quot;stylesheet&quot;    href=&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot;    /&gt;    &lt;style&gt;        .v-enter,        .v-leave-to&#123;            opacity: 0;        &#125;        .v-enter-active,        .v-leave-active&#123;            transition:opacity 3s;        &#125;    &lt;/style&gt;&lt;div id=&quot;app&quot;&gt;        &lt;transition         type=&quot;transition&quot;        //这里可以自定义入场和出场动画时长        :duration=&quot;&#123;enter:5000,leave:10000&#125;&quot;        appear        enter-active-class=&quot;animate__animated animate__swing v-enter-active&quot;        leave-active-class=&quot;animate__animated animate__flip v-leave-active&quot;        appear-active-class=&quot;animate__animated animate__flash&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt;//jS动画&lt;div id=&quot;app&quot;&gt;        &lt;transition             @before-enter=&quot;handleBeforeEnter&quot;            @enter=&quot;handleEnter&quot;            @after-enter=&quot;handleAfterEnter&quot;&gt;            &lt;h1 v-if=&quot;show&quot;&gt;ella&lt;/h1&gt;        &lt;/transition&gt;        &lt;button @click=&quot;handleBtnClick&quot;&gt;change&lt;/button&gt;    &lt;/div&gt; var vm = new Vue(&#123;    el: &quot;#app&quot;,    data:&#123;        show:true    &#125;,    methods:&#123;        handleBtnClick:function()&#123;            this.show=!this.show;        &#125;,        handleBeforeEnter:function(el)&#123;            el.style.color=&#x27;red&#x27;        &#125;,        handleEnter:function(el,done)&#123;            setTimeout(()=&gt;&#123;                el.style.color=&#x27;green&#x27;            &#125;,2000)            setTimeout(()=&gt;&#123;                done()            &#125;,4000)        &#125;,        handleAfterEnter:function(el)&#123;            el.style.color=&#x27;blue&#x27;;        &#125;    &#125;  &#125;);//velocity库handleEnter:function(el,done)&#123;            Velocity(el,&#123;opacity:1&#125;,&#123;duration:1000,complete:done&#125;)        &#125;,\n\n\n动画封装\nVue3\n指令语法\n数组变更方法push()pop()shift()unshift()splice()sort()reverse()非变更方法filter(), concat(), slice()reverse()和sort()调用之前创建一个原数组的副本\n事件处理内敛事件 方法事件\n生命周期不要用箭头函数，否则无法用this访问组件实例\nwatch侦听器\n路由动态路由匹配 :传递routes:{}里面的的路由地址可以有相对路径，可以嵌套子路径&lt;router-link to&#x3D;””&gt;&lt;&#x2F;router-link&gt;里面必须是绝对路径$router.push(“”)JS实现页面跳转 ?传递使用命名路由跳转的时候注意要用v-bind:to&#x3D;”{name:’’,params:{}}”\n组件注意data是一个函数要返回return，组件之间不共享\n\n问题axios发送post请求会405\nbind()方法主要是可以改变原本函数的this指向\nref用法this.$ref.取到的是dom元素&#x2F;组件实例\n开发注意小知识点\n&lt;router-link&gt;传参是v-bind:to:to&#x3D;”{path:’&#x2F;root’,query:{id:value}}”\nv-bind:class以键值对的形式绑定操作\nimporthttps://blog.csdn.net/qq_40323256/article/details/101867706注意export导出的引入要{}，export default不需要\n\n前后端分离问题汇总完整逻辑https://blog.csdn.net/qq_42345108/article/details/108249173\n\nelement UI表单 验证https://blog.csdn.net/qq_41008567/article/details/115939951\naxioshttps://www.axios-http.cn/docs/intro请求&#x2F;响应前进行拦截拦截器逻辑顺序\n在vue.config.js里定义devServer的代理服务器和api前缀指向 \n然后定义utils文件夹里的request.js，在该文件里引入axios，创建axios对象和要访问的URL即前面定义的API前缀，然后定义请求和响应拦截器，最后export定义的request对象 \n在apis文件夹里引入定义好的request对象，开始编写具体的request函数，包括后台接口的url，http协议方法，传递的参数 \n在vue视图里引入apis里的request函数并调用，注意调用后的返回值这里同样可以直接在vue组件里面使用类似下方结构来调用\n\n\n\naxios.post(&quot;/users/payMent&quot;,&#123;                addressId:addressId,                orderTotal:this.orderTotal              &#125;).then((response)=&gt;&#123;                  let res = response.data;                  if(res.status==&quot;0&quot;)&#123;                      this.$router.push(&#123;                          path:&#x27;/orderSuccess?orderId=&#x27;+res.result.orderId                      &#125;)                  &#125;              &#125;)\n\nget请求参数不同posthttps://zhuanlan.zhihu.com/p/275695831\n\nvuex状态管理模式解构简写\n\nimport &#123; mapState &#125; from &#x27;vuex&#x27;computed:&#123;  ...mapState([&#x27;nickName&#x27;,&#x27;cartCount&#x27;])&#125;,\n\n\nstate唯一数据源，单一状态树computed里面定义this.$store.state.\ngetter可以派生出一些新的状态可以直接在state数据上包装而不用重新定义数据，类似数据库里视图的概念this.$store.state.getters\nmutation更改state的唯一方法是提交mutationthis.$store.commit()\naction提交的是mutation，而不是直接变更状态可以异步操作调用this.$store.dispatch(“f”)定义f(a){a.commit()}\nmodule将多个store对象分割成模块\n\n\nthisthis对象问题https://juejin.cn/post/7109889547537743886this.$https://segmentfault.com/a/1190000040894587\n\nvue插件extend和component类似https://juejin.cn/post/7239715295484821565\n\nwebpackhttps://cloud.tencent.com/developer/article/1797938\n\n跨域问题\n\n\necharts实战vue3部分问题解决方案\nvscode插件加载不全，重载几遍就好了\n.&#x2F;APP.vue找不到https://blog.csdn.net/XSL_HR/article/details/128437240\nrouter-view不渲染由于没有后端支持，创建路由的history部分要用hashhttps://blog.csdn.net/weixin_43575792/article/details/122655356\n基本都是围绕setup里面响应式数据声明出的问题ref和reactivereactive对象赋值是深拷贝地址会变化，如果不是每个内部属性挨个赋值响应式对象，整体对象就会失去响应性，reactive返回的是对原始对象的引用，使用toRefs来解构toRef是将对象的属性转化为ref对象，浅拷贝，跟原本对象的属性对应地址引用是同一个，可以修改\nvuex和vue-router部分有了更新\n\n","categories":["技术学习"],"tags":["前端","Vue.js","vue2","vue3"]},{"title":"一战腾讯","url":"/2024/03/06/%E4%B8%80%E6%88%98%E8%85%BE%E8%AE%AF/","content":"无笔试，面试初试(已挂)部门：qq的PC端的某前端开发岗(PCG)形式：电话时长：15min时间：2024&#x2F;3&#x2F;6 11:00\n内容回忆\n投的前端岗位，为什么简历上无前端项目经历？\n 当时写简历的时候觉得自己搞得全栈项目只做了部分功能，不太好意思写，总不能把跟着视频网站敲的项目放上去吧……但其实蓝鲸项目是有前端部分的，但貌似被面试官忽略了(尴尬)\n\n介绍自己开发过最难的一个前端项目，里面实现了哪些功能技术点，用的什么技术栈？\n 因为确实没有做过很复杂的前端项目，自己搭建后端服务器和数据库做的全栈项目只完成了一部分，而且重点放在页面实现和美化上了，前后端交互的部分太简单了，也没有尝试过部署项目(还是太摆烂了)。我自己开发中遇到的比较多的都是页面渲染和JS交互逻辑的问题，而且都是服务器是本地搭建的，数据也很多是静态数据，所以在前后端交互上答得不太好(悲)\n\n登录与注册页面的原生逻辑是怎样实现的(不用插件)，如何保持浏览器登录状态？\n 这里回答的有点不对题，我回答的是登录进去后在应用中如何保持登录状态(jwt返回的token值保存在localStorage里)，被打断了，应该是用户点进登录页面后浏览就要自动识别呈现是登录页还是注册页，面完后才想起来可能是回答cookie相关  \n 才发现应该想问的是如何实现单点登录(悲，是JavaScript里面的，只顾着看Vue.js了)，参考这个网址 https://vue3js.cn/interview/JavaScript/single_sign.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88\n\n是否了解过axios的使用过程，封装的源码逻辑？(vuex)\n 我其实没看过封装的源码(流汗)，只能按照自己的理解说，能感觉到应该没说到点子上\n\n我的项目中用了很多封装好的模块，被提问不用封装模块该怎么用JS原生代码实现？\n 前面介绍自己的项目时说了一堆花里胡哨的功能，引入了一堆组件插件，回旋镖打在自己身上了(汗流浃背了)\n\n怎么处理跨域问题？(还有一些前后端交互的部分)\n 我说了两个，但感觉面试官觉得这两个方法都不是他想听的?\n\n\n反思整场面试都在围绕项目开发中的问题，算法&#x2F;数据结构、JS&#x2F;HTML&#x2F;CSS&#x2F;Vue语法、计算机网络、操作系统、后端&#x2F;数据库语法 全部都 没问，然后我复习的基本是这些内容。本以为具体项目开发二面三面才会，没想到一来就是项目开发里的问题，感觉就是婉拒了(bushi)。然后就是一直问有没有看过源码和封装逻辑，这个确实忽略了，都是直接用了，回答的时候很尴尬  \n总之，这次面试确实是太赶了，临时决定要投一下试试，很多东西都没准备好，果然挂了。现在的我对于前端知识很多处在一个知其然不知其所以然的状态，接下来还是要 搞一个复杂的项目实战，并且不能依赖插件，要看源码，尝试自己动手封装 ，当然 计算机基础知识和算法题 也要好好刷(也有点庆幸这次没问算法，不然挂的更快)，后续实习投递都有笔试或者现场手撕代码的\n没关系，第一次面试而已，来日方长~","categories":["面试辛酸史"],"tags":["前端","面试","腾讯"]},{"title":"前端面试知识点汇总","url":"/2024/03/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"记录了我自己准备前端面试时复习的内容  \n\n\n参考了 https://vue3js.cn/interview/\nHTML CSSJavaScript\n回调函数嵌套 函数体在完成某种操作后由内向外调用某个外部函数函数作为参数传递给另外一个函数回调地狱回调函数是一个this对象的方法时，必须保证this对象的上下文，Call和Apply函数来保存this\n\nES6\nvar let const作用域. 变量提升. 重复声明. 暂时性死区\n数组新增\n… 数组变成参数序列 浅拷贝 解构赋值 参数最后一位 iterator对象转成数组\n构造函数 Array.from() Array.of()\n实例对象方法 copyWithin() 复制覆盖 find(). findIndex() 查找 fill() 填充 entries()，keys()，values() 遍历 includes() 判断是否包含 flat()，flatMap() 扁平化（层数）\n\n\n对象新增\n简写\n属性名表达式\nsuper指向当前对象的原型对象\n扩展运算符 解构赋值 浅拷贝\n属性遍历 数值键-&gt;字符串键-&gt;symbol键 for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n方法 Object.is() 严格相等 +0不等于-0，NaN等于自身 Object.assign() 对象合并 浅拷贝替换 Object.getOwnPropertyDescriptors() Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.fromEntries()\n\n\n函数新增\n参数 尾参数\nlength name\n箭头函数 参数&#x3D;&gt;返回值\n\n\nSet Map\nSet add() delete() has() clear() keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 数组字符串去重 filter 并集交集差集\nMap set() get() has() delete() clear() keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历 Map 的所有成员 weak没有遍历属性\n\n\npromise Promise(function(resolve, reject) {})then()catch()finally()Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\ngeneratorfunction关键字与函数名之间有一个星号函数体内部使用yield表达式，定义不同的内部状态通过next方法才会遍历，直到一个yield表达式暂停，返回值是yield表达式的值，下一次next方法继续，直到returnnext可以带一个参数，当做一个yield表达式的返回值返回的是Iterator对象，可以通过for…of进行遍历\n异步处理回调函数Promise 对象generator 函数 可以控制迭代async&#x2F;await 本质上generator\nproxy用于创建一个对象的代理，从而实现基本操作的拦截和自定义var proxy &#x3D; new Proxy(target, handler)Reflect 的所有属性和方法都是静态的（ Math 对象），提供拦截 JavaScript 操作的方法get() set() deleteProperty()Proxy.revocable(target, handler);取消代理在复杂操作前对操作进行校验或对所需资源进行管理拦截和监视外部对对象的访问使用 Proxy 保障数据类型的准确性使用Proxy实现观察者模式，观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\nmodule静态化 在编译时就完成模块加载export：用于规定模块的对外接口import：用于输入其他模块提供的功能\ndecorator装饰器命名相当于一个注释，在不改变原有代码情况下，对类和类属性原来功能进行扩充不能修饰函数\n\nVue.jsNode.jsNode.js 是一个开源与跨平台的 JavaScript 运行时环境事件驱动、非阻塞和异步输入输出模型\n算法\n前端diff算法 深度优先算法 时间复杂度:O(n) 最小量更新patch 比较虚拟DOM根节点是否同一类型，不同直接替换|patchVnode 进一步比较两个虚拟节点 有无text和children|updateChildren 都有子节点的情况下比较更新真实节点 四个指针，指向oldVnode子节点列表中的第一个节点和最后一个节点以及指向newVnode子节点列表中的第一个节点和最后一个节点，节点比较过，前的指针++，后的指针–\noldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)\noldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)，相同的话移动真实节点OE之后\noldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)，相同的话移动真实节点OS之前\noldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)\n如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置\nold先处理完，新增newS和newE之间的节点\nnew先处理完，删除oldS和oldE之间的节点key的设置 判断两个虚拟节点是否为相同节点不建议用index作为循环项的key，因为操作过程中index会改变，一些相同节点index变了会被当成新的节点，用id的话每个节点key都不同，便于更新时复用节点\n\n\n排序\n数据结构数组栈队列链表树图堆散列表  \n经典算法\n\n网络协议\nHTTPC&#x2F;S模式 可以传输任意类型数据对象  明文传输，无身份验证 不安全默认端口80无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间无状态：HTTP协议无法根据之前的状态进行本次的请求处理  \n\nHTTPS加密传输  让HTTP运行安全的SSL&#x2F;TLS协议(TCP&#x2F;IP 协议与应用层协议之间)上默认端口443  因为加密和多次握手，性能相对较差通信过程:\n\n首先客户端通过URL访问服务器建立SSL连接\n服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端\n客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级\n客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站\n服务器利用自己的私钥解密出会话密钥\n服务器利用会话密钥加密与客户端之间的通信\n\n\nSSL\n\n对称加密：加密和解密使用的秘钥是同一个，秘钥发送的过程中容易被窃取\n非对称加密：有公钥和私钥，公钥加密后只能用私钥解密，私钥加密后也只能用公钥解密  \n混合加密： 发送者用会话密钥加密消息（对称），用公钥加密的会话密钥（非对称），两个一起发送 消息接收者用自己的私钥解密出会话密钥，用会话密钥解密消息\n\n 摘要算法： 会话密钥 对称的 明文和摘要一起加密 验证信息的完整性  散列函数、哈希函数 把消息数据转化成一个特殊字符串，接收者比对接收到的明文计算出的消息摘要和接收到的信息摘要  \n 数字签名： 公私钥 非对称  身份验证 摘要私钥加密成数字签名，公钥解开后再比对原文验证  \n CA验证机构:     1. 服务器有一套公钥和私钥，把公钥发给CA机构     2. CA机构用机构私钥给服务器公钥署数字签名，颁发公钥证书(服务器公钥+数字签名)     3. 浏览器中预设了机构公钥，客户端拿到服务器的公钥证书，可以自行解密数字签名，得到服务器公钥，跟公钥证书比对     4. 客户端用服务器公钥加密报文，服务器用服务器私钥解密\n\nUDP\n\nTCP\n\n\nGit\necharts可视化最重要的就是id问题，不能重复\n\nprovide inject导入echarts对象\n获取后端数据\nonMounted里初始化渲染，因为要获取dom元素\n看文档setOption，notMerge: true\n自适应大小window.onresize &#x3D; function () {myChart1.resize();}\n放echarts的容器要预先设置大小才会渲染\n\nexpressMongoDB","categories":["技术学习"],"tags":["前端","面试"]},{"title":"算法学习笔记","url":"/2024/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前言最近在准备面试，投递岗位主要是前端，但是本人也有点想转后端，所以算法题必刷不可。本笔记用于记录刷题过程中遇到的中等及以上难度的题和一些特殊算法思想，语言大部分会用 JavaScript 来刷题，也有的会用C++和Java数据结构部分回顾直接看我大二上的数据结构复习笔记，感觉网上查到的没有总结的特别好和全面的(如果我还有精力，会考虑把之前专业课的笔记也放上来。以前的笔记都是OneNote里写的，不是Markdown语法，还都是全英的，整理起来有点复杂)目前先看了一下算法基础，可以参考以下文章的介绍，基本上js扫盲没问题，然后开始力扣刷题https://juejin.cn/post/7087134135193436197\n力扣目前是先把LeetCode75刷完，进行算法扫盲  \n唉，没想到上一次刷力扣都是一年前了，这一次争取刷题量大一点，坚持的久一点，会持续更新的  \n算法，启动！\n题库LeetCode75本题库涉及到的知识点一览\n\n 数组 &#x2F; 字符串 334\n 双指针\n 滑动窗口 1493 1004\n 前缀和\n 哈希表 &#x2F; 哈希集合\n 栈 735\n 队列\n 链表\n 二叉树 - 深度优先搜索\n 二叉树 - 广度优先搜索\n 二叉搜索树\n 图 - 深度优先搜索 1261\n 图 - 广度优先搜索\n 堆 &#x2F; 优先队列 215\n 二分查找\n 回溯\n 动态规划 - 一维 1137\n 动态规划 - 多维 72\n 位运算\n 前缀树\n 区间集合\n 单调栈 739 901\n\n334.递增的三元子序列题目：\n给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。\n\n解析：\n\n双向遍历 其实本质上就是找到数组中的一个元素，左边有值比它小，右边有值比它大。那么新创建两个长度为n的MIN和MAX数组，即MIN[i]表示nums[0]到nums[i]中的最小值，MAX[i]表示nums[0]到nums[i]中的最大值，然后遍历nums数组找到MIN[i-1]&lt;nums[i]&lt;MAX[i+1]的返回true  \n 整个逻辑需要遍历数组三遍，额外创建两个数组\n\n贪心算法 简单说就是寻找局部最优解，再把每次迭代后的最优解叠加\n 本题目怎么联想到贪心呢，因为看完题目后三元组中的第一个肯定是越小越容易满足递增的情况，所以就是要找到最小的做first，第二小的做second，这样遍历只用找到比second大就返回true  \n 那么迭代思路就是先令nums[0]为first，second为正无穷，开始遍历。遇到nums[i]&gt;second的返回true;遇到first&lt;nums[i]&lt;second，second换成更小的nums[i]；遇到first&gt;&#x3D;nums[i]，first换成更小的nums[i]。\n 注意第三种情况second是没变的，那么新的first位置是在second后面的，只要后续遍历找到一个nums[i]大于second，曾经的first肯定排在second前面，那么就找到了；如果nums[i]小于second大于新的first，second就直接更新了，那么又回到了first位置在second前面的情况。\n\n\n/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var increasingTriplet = function (nums) &#123;    const len = nums.length;    if (len &lt; 3) &#123;        return false    &#125;    let first = nums[0]    let second = Number.MAX_VALUE;    for (let i = 1; i &lt; len; i++) &#123;        const num = nums[i]        if (num &gt; second) &#123;            return true        &#125; else if (num &gt; first) &#123;            second = num        &#125; else &#123;            first = num        &#125;    &#125;    return false&#125;;\n\n215.数组中的第K个最大元素题目：\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n\n解析：\n\n快排 之前看快排的时候只记得二分递归，其实忽略了每一次查找中的中间值的最终位置会被确定下来，可以利用这一点在查找的过程中就 确定某些顺序位置上的值 。简单来说就是某次二分时中间值被放到了了nums[k]的位置(降序)，那么这个中间值就是第k大的元素\n 用Java和js写了一下快排，注意这里我用的是倒序，所以k传参的时候记得要-1\n\n\nclass Solution &#123;    int quickselect(int[] nums, int l, int r, int k) &#123;        if (l == r) return nums[k];        int x = nums[l], i = l - 1, j = r + 1;        while (i &lt; j) &#123;            do i++; while (nums[i] &gt; x);            do j--; while (nums[j] &lt; x);            if (i &lt; j)&#123;                int tmp = nums[i];                nums[i] = nums[j];                nums[j] = tmp;            &#125;        &#125;        if (k &lt;= j) return quickselect(nums, l, j, k);        else return quickselect(nums, j + 1, r, k);    &#125;    public int findKthLargest(int[] _nums, int k) &#123;        int n = _nums.length;        return quickselect(_nums, 0, n - 1, k-1);    &#125;&#125;\n\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var findKthLargest = function (nums, k) &#123;    let quickselect = (nums, l, r, k) =&gt; &#123;        if (l == r) return nums[k];        let x = nums[l], i = l - 1, j = r + 1;        while (i &lt; j) &#123;            do i++; while (nums[i] &gt; x);            do j--; while (nums[j] &lt; x);            if (i &lt; j) &#123;                let tmp = nums[i];                nums[i] = nums[j];                nums[j] = tmp;            &#125;        &#125;        if (k &lt;= j) return quickselect(nums, l, j, k);        else return quickselect(nums, j + 1, r, k);    &#125;    return quickselect(nums, 0, nums.length - 1, k - 1);&#125;;\n\n\n堆排序 最大值或者最小值堆和优先队列很适合查找这些有优先级顺序的问题，本题可以建立一个最大堆，做 k−1次删除操作后堆顶元素就是答案。\n 不过理论上时间复杂度是o(nlog(n))&#x3D;o(n)+o(klog(n))，即建堆和删除操作，这个方法纯粹是复习下堆相关的算法，Java方法基本就是JavaScript改一下声明，就不贴代码了\n (突然发现Java和JavaScript语法还蛮像的，只不过JavaScript没有class和函数类型的概念，其他数据结构以及思路是一样的)\n\n\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var findKthLargest = function (nums, k) &#123;    let heapSize = nums.length    function buildMaxHeap(nums, heapSize) &#123;        //这里的i是最后一个非叶子节点        for (let i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123;            maxHeapify(nums, i, heapSize)        &#125;    &#125;    // 从左向右，自上而下的冒泡    function maxHeapify(nums, i, heapSize) &#123;        //左子节点        let l = i * 2 + 1        //右子节点        let r = i * 2 + 2        let largest = i        if (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest]) &#123;            largest = l        &#125;        if (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest]) &#123;            largest = r        &#125;        if (largest !== i) &#123;            swap(nums, i, largest) // 进行节点调整            // 继续调整下面的非叶子节点，直到叶子节点            maxHeapify(nums, largest, heapSize)        &#125;    &#125;    function swap(a, i, j) &#123;        let temp = a[i];        a[i] = a[j];        a[j] = temp;    &#125;    buildMaxHeap(nums, heapSize) // 构建好了一个最大堆    // 最大堆是最大元素和最后一个元素交换，再删去最后一个元素    for (let i = nums.length - 1; i &gt;= nums.length - k + 1; i--) &#123;        swap(nums, 0, i)        --heapSize        // 重新调整最大堆        maxHeapify(nums, 0, heapSize);    &#125;    return nums[0]&#125;;\n\n72.编辑距离题目：\n给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数。你可以对单词字符进行单个插入&#x2F;删除&#x2F;替换操作\n\n解析：\n这个题目我一看不就是虚拟DOM的diff算法吗，指路https://vue3js.cn/interview/vue/diff.html，这个题目就是一个简化版先放着，等我学一下动态规划再回头来解这个题\n1137.第N个泰波那契数题目：\n泰波那契序列 Tn 定义如下：T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 &#x3D; Tn + Tn+1 + Tn+2给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n\n解析：\n题目不难，可以递归，但是一旦数据过多会超时；也可以用动态规划，把状态方程换成递推关系式  \n官方题解用到的矩阵快速幂方法很有意思，记录一下，这样做时间复杂度O(logn)本题是同样的思路，这里直接贴官方题解了快速幂指路https://www.cnblogs.com/bigsai/p/15169985.html\nvar tribonacci = function(n) &#123;    if (n === 0) &#123;        return 0;    &#125;    if (n &lt;= 2) &#123;        return 1;    &#125;    const q = [[1, 1, 1], [1, 0, 0], [0, 1, 0]];    const res = pow(q, n);    return res[0][2];&#125;;const pow = (a, n) =&gt; &#123;    //单位矩阵    let ret = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];    while (n &gt; 0) &#123;        //判断奇偶用        if ((n &amp; 1) === 1) &#123;            ret = multiply(ret, a);        &#125;        //二进制移位本质上就是除以2或乘以2        n &gt;&gt;= 1;        a = multiply(a, a);    &#125;    return ret;&#125;const multiply = (a, b) =&gt; &#123;    const c = new Array(3).fill(0).map(() =&gt; new Array(3).fill(0));    for (let i = 0; i &lt; 3; i++) &#123;        for (let j = 0; j &lt; 3; j++) &#123;            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];        &#125;    &#125;    return c;&#125;\n\n1071.字符串的最大公因子题目：\n对于字符串 s 和 t，只有在 s &#x3D; t + t + t + … + t + t（t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 x 能除尽 str2\n\n解析：\n这题虽然是简单题，但是背后的思想还蛮重要的\n辗转相除法     GCD（被除数，除数）&#x3D; GCD（除数，余数）\n理解辗转相除的关键在于被除数和除数有相同的因数，那么被除数和除数的余数跟它们也有一样的因数，反之亦然\n辗转相除指路，我觉得这篇文章讲的很清楚https://zhuanlan.zhihu.com/p/324578532  \n把文章中证明过程贴一下\n本题目的逻辑在于如果它们有公因子abc，那么str1就是m个 abc 的重复，str2是n个abc的重复，连起来就是m+n个abc，那么理论上先后顺序不重要，m+n个abc跟n+m个abc是一样的。即如果 str1 + str2 &#x3D;&#x3D;&#x3D; str2 + str1 就意味着有解，str1 + str2 !&#x3D;&#x3D; str2 + str1 也是无解的充要条件。当确定有解的情况下，最优解是长度为 gcd(str1.length, str2.length) 的字符串。\n/** * @param &#123;string&#125; str1 * @param &#123;string&#125; str2 * @return &#123;string&#125; */var gcdOfStrings = function(str1, str2) &#123;  if (str1 + str2 !== str2 + str1) return &#x27;&#x27;  //余数为0的时候除数就是最大约数  const gcd = (a, b) =&gt; (0 === b ? a : gcd(b, a % b))  return str1.substring(0, gcd(str1.length, str2.length))&#125;;\n\n739.每日温度题目：\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n解析：\n单调栈 即栈中放的数据单调有序\n所有找下一个最大&#x2F;小值距离当前值的距离都可以用单调栈。 本方法用空间换时间，空间复杂度o(n)额外维护一个数组，时间复杂度o(n)只用正向遍历一遍\n单调递减栈步骤如下：维护一个数组下标的单调栈，正向遍历数组，当栈为空的时候直接当前下标入栈；不为空的时候比较栈顶元素对应的数组数值temperatures[stack[stack.length-1]]和当前遍历数组数值temperatures[i]，temperatures[i]&gt;temperatures[stack[stack.length-1]]的话，栈顶元素pop出来，该元素对应的距离为i-stack[stack.length-1]，然后循环直至栈为空或者不满足大于的条件，最后i进栈\npop的时候更新距离是因为遍历数组是按正序遍历的，那么满足大小条件的一定是右边第一个\n/** * @param &#123;number[]&#125; temperatures * @return &#123;number[]&#125; */var dailyTemperatures = function(temperatures) &#123;    const len=temperatures.length    let ans=new Array(len).fill(0)    let stack=[]    for(let i=0;i&lt;len;i++)&#123;        while(stack.length&amp;&amp;temperatures[i]&gt;temperatures[stack[stack.length-1]])&#123;            const index=stack.pop()            ans[index]=i-index        &#125;        stack.push(i)    &#125;    return ans&#125;;\n\n901.股票价格跨度题目：\n设计一个算法收集某些股票的每日报价，并返回该股票当日价格的跨度 。当日股票价格的 跨度 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。例如，如果未来 7 天股票的价格是 [100,80,60,70,60,75,85]，那么股票跨度将是 [1,1,1,2,1,4,6] 。实现 StockSpanner 类：StockSpanner() 初始化类对象。int next(int price) 给出今天的股价 price ，返回该股票当日价格的 跨度 。\n\n解析：\n单调栈 即栈中放的数据单调有序\n本题是倒着过去的，找出一个元素左边第一个大于该元素 ，本质上也是用当前元素的价格和栈顶元素价格比较，小的就弹出来，直到一个更大的，返回两个元素下标差，把当前元素入栈\n需要注意的是因为本题是通过调用一个next函数返回值，所以把下标和价格储存成一个二元数对更方便。为了防止栈空，把第一个栈元素设置为下标-1和价格无穷大\n/**  * @param &#123;number&#125; price * @return &#123;number&#125; */var StockSpanner = function() &#123;    this.stack = [];    this.stack.push([-1, Number.MAX_VALUE]);    this.idx = -1;&#125;;StockSpanner.prototype.next = function(price) &#123;    this.idx++;    while (price &gt;= this.stack[this.stack.length - 1][1]) &#123;        this.stack.pop();    &#125;    let ret = this.idx - this.stack[this.stack.length - 1][0];    this.stack.push([this.idx, price]);    return ret;&#125;;\n\n735.小行星碰撞题目：\n给定一个整数数组 asteroids，表示在同一行的小行星。对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。\n\n解析：\n题目规则简化是数组相邻元素左正右负就只留下绝对值更大的，不断碰撞直到只剩下左正右负的相邻元素  \n代码逻辑是用栈来模拟行星碰撞，逐一遍历数组，将元素依次压入栈中，当出现左正右负时，先比较其和栈顶元素绝对值大小，同时修改alive状态，直到左正右负消失，alive的值决定是否push元素\n/** * @param &#123;number[]&#125; asteroids * @return &#123;number[]&#125; */var asteroidCollision = function (asteroids) &#123;    const stack = []    for (const aster of asteroids) &#123;        //代表每次遍历要压入栈的那个行星是否爆炸        let alive = true;        while (alive &amp;&amp; stack.length &gt; 0 &amp;&amp; stack[stack.length - 1] &gt; 0 &amp;&amp; aster &lt; 0) &#123;            //入栈元素大于栈顶元素绝对值才设置alive为true            alive = stack[stack.length - 1] &lt; -aster;            if (stack[stack.length - 1] &lt;= -aster) &#123;                stack.pop();            &#125;        &#125;        if (alive) &#123;            stack.push(aster);        &#125;    &#125;    const size = stack.length;    const ans = new Array(size).fill(0);    for (let i = size - 1; i &gt;= 0; i--) &#123;        ans[i] = stack.pop();    &#125;    return ans;&#125;;\n\n605.种花问题题目：\n假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。\n\n解析：\n虽然是简单题，但是我官方贪心的解答没看懂(尴尬)。我自己做就是两个思路，跳格子和连续三个0，不解释了。\nclass Solution &#123;    public boolean canPlaceFlowers(int[] flowerbed, int n) &#123;        int len = flowerbed.length;        int i = 0;        while (i &lt; len &amp;&amp; n &gt; 0) &#123;            //当前i为1，i+1必然为0，那么只有i+2才可能为0            if (flowerbed[i] == 1) &#123;                i += 2;            &#125; else if (i == flowerbed.length - 1||flowerbed[i + 1] == 0 ) &#123;                //当前i为0且i+1为0，那么当前i可以种花                //注意末尾为0也是可以种花的                //这里有一个编译上的小错误注                //开始我把i+1==0放在第一个判断，会出现out of bounds的错误，要把判断i==末尾长度先判断                i += 2;                n--;            &#125; else &#123;                i += 3;            &#125;        &#125;        return n &lt;= 0;    &#125;&#125;\n\nvar canPlaceFlowers = function (flowerbed, n) &#123;    const len = flowerbed.length;    for (let i = 0; i &lt; len; i++) &#123;        if ((i === 0 || flowerbed[i - 1] === 0) &amp;&amp; flowerbed[i] === 0 &amp;&amp; (i === len - 1 || flowerbed[i + 1] === 0)) &#123;            n--;            i++;         &#125;    &#125;    return n &lt;= 0;&#125;;\n\n1261.在受污染的二叉树中查找元素题目：\n给出一个满足下述规则的二叉树：\n\nroot.val &#x3D;&#x3D; 0\n如果 treeNode.val &#x3D;&#x3D; x 且 treeNode.left !&#x3D; null，那么 treeNode.left.val &#x3D;&#x3D; 2 * x + 1\n如果 treeNode.val &#x3D;&#x3D; x 且 treeNode.right !&#x3D; null，那么 treeNode.right.val &#x3D;&#x3D; 2 * x + 2现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。请你先还原二叉树，然后实现 FindElements 类：\n\n\nFindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。\nbool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。\n\n\n解析：\n深度优先，从根节点开始左右赋值，递归到节点为空止，然后哈希表查找即可\nvar FindElements = function(root) &#123;    this.valSet = new Set();    const dfs = (node, val) =&gt; &#123;        if (node == null) &#123;            return;        &#125;        node.val = val;        this.valSet.add(val);        dfs(node.left, val * 2 + 1)        dfs(node.right, val * 2 + 2)    &#125;    dfs(root, 0);&#125;;FindElements.prototype.find = function(target) &#123;    return this.valSet.has(target);&#125;;\n\n151.反转字符串中的单词题目：\n给你一个字符串 s ，请你反转字符串中单词的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格\n\n解析：\n没啥特别的需要解释，主要是熟练使用js里面string的内置函数\ntrim():去除字符串的头尾空格split(&#x2F;\\s&#x2F;)和split(&#x2F;\\s+&#x2F;):以单空格和连续多个空格划分成数组reverse():数组元素反转join(‘ ‘):数组拼接字符串\nvar reverseWords = function(s) &#123;    return s.trim().split(/\\s+/).reverse().join(&#x27; &#x27;);&#125;;\n\n这里记录一下我自己对于一些js内置函数的实现，可能有漏洞\nfunction  trim(str)&#123;    for(var  i  =  0  ;  i&lt;str.length  &amp;&amp;  str[i]==&quot;  &quot;  ;  i++  )  ;    for(var  j  =str.length;  j&gt;0  &amp;&amp;  str.[j-1]==&quot;  &quot;  ;  j--)  ;    if(i&gt;j)  return  &quot;&quot;;      return  str.substring(i,j);  &#125;function substring(string,start,end)&#123;    let newString    for(let i=start;i&lt;=end;i++)&#123;        newstring+=string[i]    &#125;    return newString&#125;function slice(arr,start,end)&#123;    let newArr=new Array(end-start+1)    for(let i=start,n=0;i&lt;=end;i++,n++)&#123;        newstring[n]=arr[i]    &#125;    return newArr&#125;\n\n1004.最大连续1的个数题目：\n给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。\n\n解析：\n\n二分查找\n 题目本质上是求找出一个最长的子数组，该子数组内最多允许有k个0\n 对于数组A的区间[left,right] 而言，只要它包含不超过k个0，就可以得到满足要求并且长度为right−left+1 的区间\n 遍历所有的节点作为right，每个都找到合适的left(二分法查找)，然后比较返回区间最大的\n /** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var longestOnes = function (nums, k) &#123;    const n = nums.length    const pre = new Array(n + 1).fill(0)    for (let i = 1; i &lt;= n; i++) &#123;        pre[i] = pre[i - 1] + (1 - nums[i - 1])    &#125;    let ans = 0;    for (let right = 0; right &lt; n; ++right) &#123;        const left = binarySearch(pre, pre[right + 1] - k)        ans = Math.max(ans, right - left + 1)    &#125;    return ans&#125;;const binarySearch = (pre, target) =&gt; &#123;    let i = 0, j = pre.length - 1    while (i &lt; j) &#123;        const mid = Math.floor((j - i) / 2) + i        if (pre[mid] &lt; target) &#123;            i = mid + 1        &#125; else &#123;            j = mid        &#125;    &#125;    return j&#125;\n\n滑动窗口\n 滑动窗口的套路就是左右边界指针，右指针右移，判断区间条件是否满足，不满足条件后开始移动左指针，然后返回最大区间\n class Solution &#123;    public int longestOnes(int[] nums, int k) &#123;        int len = nums.length, right = 0, left = 0, zeros = 0, res = 0;        while (right &lt; len) &#123;            if (nums[right] == 0) &#123;                zeros++;            &#125;            while (zeros &gt; k) &#123;                if (nums[left] == 0) &#123;                    zeros--;                &#125;                left++;            &#125;            res = Math.max(res, right - left + 1);            right++;        &#125;        return res;    &#125;&#125;\n\n1493.删掉一个元素以后全为1的最长子数组题目：\n给你一个二进制数组 nums ，你需要从中删掉一个元素。请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。如果不存在这样的子数组，请返回 0 。\n\n解析：滑动窗口类的题目\n\n递推官方的思路跟滑动窗口没啥关系，主要是递推的思路\n 假设当前的下标是i，知道 「以第i-1位结尾的最长连续全1子数组」 和 「以第i+1位开头的最长连续全1子数组」的长度分别是多少，这两个量的和就是删除第i位之后最长的且只包含1的非空子数组的长度\n 所以需要额外维护两个数组，遍历三遍\n class Solution &#123;    public int longestSubarray(int[] nums) &#123;        int n = nums.length;        //pre(i) 为「以第i位结尾的最长连续全1子数组」        int[] pre = new int[n];        //suf(i)为「以第i位开头的最长连续全1子数组」        int[] suf = new int[n];        pre[0] = nums[0];        for (int i = 1; i &lt; n; ++i) &#123;            //当前值为0的话重新计数，为1的话+1            pre[i] = nums[i] != 0 ? pre[i - 1] + 1 : 0;         &#125;        suf[n - 1] = nums[n - 1];        for (int i = n - 2; i &gt;= 0; --i) &#123;            suf[i] = nums[i] != 0 ? suf[i + 1] + 1 : 0;        &#125;        int ans = 0;        for (int i = 0; i &lt; n; ++i) &#123;            int preSum = i == 0 ? 0 : pre[i - 1];            int sufSum = i == n - 1 ? 0 : suf[i + 1];            ans = Math.max(ans, preSum + sufSum);        &#125;        return ans;    &#125;&#125;\n\n 官方思路还可以优化，只用遍历一次，额外维护两个数组p0(i) 为「以第i位结尾的最长连续全1子数组」和p1(i) 为「以第i位结尾，并可以在某处删除一个0的最长连续全1子数组」。这两个数组的递推式在遇到1时是一样的，区别在遇到0时，p0重新计数，但是p1可以通过删除当前0达到连续全1  \n class Solution &#123;    public int longestSubarray(int[] nums) &#123;        int ans = 0;        int p0 = 0, p1 = 0;        for (int num : nums) &#123;            if (num == 0) &#123;                p1 = p0;                p0 = 0;            &#125; else &#123;                ++p0;                ++p1;            &#125;            ans = Math.max(ans, p1);        &#125;        if (ans == nums.length) &#123;            --ans;        &#125;        return ans;    &#125;&#125;\n\n滑动窗口\n 类似上一题的思路，这道题就是滑动区间最多只能有一个0\n class Solution &#123;    public int longestSubarray(int[] nums) &#123;        int len = nums.length, right = 0, left = 0, zeros = 0, res = 0;        while (right &lt; len) &#123;            if (nums[right] == 0) &#123;                zeros++;            &#125;            while (zeros &gt; 1) &#123;                if (nums[left] == 0) &#123;                    zeros--;                &#125;                left++;            &#125;            res = Math.max(res, right - left );            right++;        &#125;        return res;    &#125;&#125;\n\n2789.合并后数组的最大元素题目：\n给你一个下标从 0 开始、由正整数组成的数组 nums 。你可以在数组上执行下述操作 任意 次：选中一个同时满足 0 &lt;&#x3D; i &lt; nums.length - 1 和 nums[i] &lt;&#x3D; nums[i + 1] 的整数 i 。将元素 nums[i + 1] 替换为 nums[i] + nums[i + 1] ，并从数组中删除元素 nums[i] 。返回你可以从最终数组中获得的 最大 元素的值。\n\n解析：\n贪心+倒序遍历数组题目的意思抽象出来就是用两个有序的数字的和替换原来的两个数字。那么为了和最大，应该尽可能多合并，最大的数合并。\n按照题目要求，应该是一个递增的数组，那么后面的数更大一点，所以从后往前遍历，尽可能多的合并\n//官方解法var maxArrayValue = function(nums) &#123;    let sum=nums[nums.length-1];    for(let i=nums.length-2;i&gt;=0;i--)&#123;        sum=nums[i]&lt;=sum?nums[i]+sum:nums[i];    &#125;    return sum;&#125;;//其实可以一行代码搞定，因为最近在看reduce的函数实现，reduce做这种回调求和可以秒var maxArrayValue = function (nums) &#123;    return nums.reverse().reduce(        (accumulator, currentValue) =&gt; currentValue &lt;= accumulator ? accumulator + currentValue : currentValue,    )&#125;;\n\n875.爱吃香蕉的珂珂题目：\n珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。\n\n解析：\n经典的 二分法，当一个题目有 范围和 单调性的时候考虑二分法\n本题的速度是有范围的整数，单调性体现在吃香蕉的速度越快，耗时越少；速度越慢，耗时越多\n当二分查找猜测的速度恰好使得珂珂在规定的时间内吃完香蕉的时候，还应该去尝试更小的速度是不是还可以保证在规定的时间内吃完香蕉。\n最慢速度为每小时吃一根香蕉，最快为每小时吃max(piles)根香蕉，然后尝试中点速度mid。如果以这个速度能够在h小时内吃完香蕉，那么这个速度应该是速度上界；如果吃不完那么这个速度应该是速度下界。\n具体一点是，如果在速度speed下可以在h小时内吃掉所有香蕉，则最小速度一定小于或等于speed，因此将上界调整为speed；否则，最小速度一定大于 speed，因此将下界调整为speed+1\n空间复杂度是o(1)，时间复杂度是o(nlogm)，m是piles数组的最大值，二分查找要进行logm轮，每一轮要把数组遍历一遍\nclass Solution &#123;    public int minEatingSpeed(int[] piles, int h) &#123;        int low = 1, high = 0;        for (int pile : piles) &#123;            high = Math.max(high, pile);        &#125;        int res = high;        while (low &lt; high) &#123;            int mid = (high + low) / 2;            int time = getTime(piles, mid);            if (time &lt;= h) &#123;                //当所花时间更少的时候，还要继续二分，因为要找到最慢的速度                res = mid;                high = mid;            &#125; else &#123;                low = mid + 1;            &#125;        &#125;        return res;    &#125;    public int getTime(int[] piles, int speed) &#123;        int time = 0;        for (int pile : piles) &#123;            //最精妙的地方，不用ceil()就实现了向上取整，执行效率大幅提高            //这里如果有余数最少是1，加上speed-1会大于等于speed，相当于向上取整            //不是speed是怕pile和speed可以整除            int curTime = (pile + speed - 1) / speed;            time += curTime;        &#125;        return time;    &#125;&#125;\n\n\n未完待续~","categories":["技术学习"],"tags":["前端","算法"]}]